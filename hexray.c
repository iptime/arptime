/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc();
// int __fastcall insert_nf_to_rule(_DWORD, _DWORD); weak
// int __fastcall get_rsync_config(_DWORD); weak
// int __fastcall get_fakedns(_DWORD); weak
// int __fastcall read_rt_db(_DWORD); weak
// int __fastcall set_samba_config(_DWORD); weak
// int __fastcall fw_add_db(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD); weak
// int __fastcall read_wifi_sched_config(_DWORD, _DWORD); weak
// int __fastcall get_link_status(_DWORD, _DWORD); weak
// int __fastcall wireless_api_get_max_mbss(_DWORD); weak
// int __fastcall syslog_save(_DWORD); weak
// int __fastcall delete_rt_entry_list(_DWORD, _DWORD, _DWORD); weak
// int __fastcall wireless_get_multibridge_enable(_DWORD); weak
// int __fastcall dhcpd_start(_DWORD); weak
// int __fastcall pptpserver_set_config(_DWORD, _DWORD); weak
// int __fastcall _register_frame_info(_DWORD, _DWORD); weak
// int __fastcall syslog_get_status(_DWORD); weak
// int __fastcall dmztwinip_write_config(_DWORD, _DWORD); weak
// int __fastcall parse_sched_value(_DWORD, _DWORD); weak
// int __fastcall clear_active_wl(_DWORD); weak
// int __fastcall get_si(_DWORD, _DWORD); weak
// int __fastcall wireless_api_del_mbss(_DWORD, _DWORD); weak
// int __fastcall set_smtp_password(_DWORD); weak
// int __fastcall get_remote_addr(_DWORD); weak
// int __fastcall set_dhclient_block_private_ip(_DWORD); weak
// int __fastcall dhcpd_set_dns(_DWORD, _DWORD); weak
// int __fastcall istatus_set_intvalue_direct(_DWORD, _DWORD); weak
// int __fastcall set_nologin(_DWORD); weak
// int __fastcall set_autodns(_DWORD); weak
// int inet_aton(const char *cp, struct in_addr *inp);
// int __fastcall print_http_header(_DWORD); weak
// int __fastcall get_wansetup_status(_DWORD); weak
// int __fastcall tc_count_file_read(_DWORD); weak
// int __fastcall set_csrf_op(_DWORD); weak
// int __fastcall syslog_get_email_status(_DWORD, _DWORD, _DWORD); weak
// int __fastcall wireless_api_start_ap_scan(_DWORD); weak
// int __fastcall get_intvalue_post(_DWORD, _DWORD, _DWORD); weak
// int __fastcall dmztwinip_apply_dmz(_DWORD, _DWORD, _DWORD); weak
// int __fastcall make_virtual_host_page(_DWORD); weak
// char *getenv(const char *name);
// int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// const unsigned __int16 **_ctype_b_loc(void);
// int __fastcall get_plantynet_freedevice_num(_DWORD); weak
// int system(const char *command);
// int __fastcall set_dhcp_access_policy(_DWORD); weak
// int __fastcall trunk_read_config(_DWORD, _DWORD, _DWORD); weak
// int __fastcall free_mount_list(_DWORD); weak
// int get_iptv_config(void); weak
// int __fastcall get_wbm_popup_flag(_DWORD); weak
// int __fastcall get_ipmac_bind(_DWORD); weak
// int __fastcall set_led_silent_control(_DWORD); weak
// int __fastcall ifup(_DWORD); weak
// int __fastcall macdb_read(_DWORD, _DWORD); weak
// int __fastcall get_wan_ifname(_DWORD, _DWORD); weak
// int __fastcall get_ip_by_hwaddr(_DWORD, _DWORD); weak
// int __fastcall get_plantynet_status(_DWORD); weak
// int __fastcall hwinfo_get_fan_control_default(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall get_system_running_time(_DWORD); weak
// int __fastcall get_wan_type(_DWORD, _DWORD); weak
// int __fastcall set_csrf_whites(_DWORD); weak
// int __fastcall get_hwaddr_cloned(_DWORD, _DWORD); weak
// int __fastcall quote_r(_DWORD, _DWORD); weak
// int __fastcall clear_hostscan_log(_DWORD); weak
// int __fastcall set_wireless_conf(_DWORD, _DWORD); weak
// int __fastcall ddnsapi_get_refresh_flag(_DWORD); weak
// int __fastcall iconfig_get_intvalue_direct(_DWORD); weak
// int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_hwaddr_by_ip(_DWORD, _DWORD); weak
// int __fastcall get_http_auth_method(_DWORD); weak
// int __fastcall get_hostinfo_from_bridge(_DWORD, _DWORD, _DWORD); weak
// unsigned int sleep(unsigned int seconds);
// int __fastcall init_fw_rule(_DWORD); weak
// int __fastcall dmztwinip_read_config(_DWORD, _DWORD); weak
// int __fastcall remove_user_system(_DWORD, _DWORD); weak
// int __fastcall get_hostinfo_from_arp(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_hwaddr_kernel(_DWORD, _DWORD); weak
// int __fastcall read_wireless_conf(_DWORD, _DWORD); weak
// int __fastcall delete_fw_rule(_DWORD, _DWORD); weak
// int __fastcall signal_save(_DWORD); weak
// int __fastcall get_hwaddr_org(_DWORD, _DWORD); weak
// int __fastcall get_plantynet_service(_DWORD); weak
// int __fastcall accesslist_get_ip(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall local_gateway_is_default_gateway(_DWORD); weak
// int __fastcall get_url_redirect_option(_DWORD); weak
// int __fastcall get_timeserver_conf(_DWORD); weak
// int putchar(int c);
// int __fastcall signal_nas(_DWORD); weak
// int __fastcall set_torrent_config(_DWORD); weak
// int __fastcall set_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall wireless_api_get_ap_list(_DWORD); weak
// int __fastcall set_iptv_config(_DWORD); weak
// int __fastcall get_fan_config(_DWORD); weak
// int __fastcall get_url_redirect_usermsg(_DWORD); weak
// int __fastcall hwinfo_get_language_postfix(_DWORD); weak
// char *strcat(char *dest, const char *src);
// int feof(FILE *stream);
// int __cdecl dhcpd_get_all_dynamic_lease(_DWORD); weak
// int __fastcall ddnsapi_remove_host(_DWORD); weak
// int __fastcall read_dos_config(_DWORD); weak
// int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD); weak
// int __fastcall get_eport_stat(_DWORD, _DWORD); weak
// int __fastcall set_upnp(_DWORD); weak
// int __fastcall get_ftpd_config(_DWORD); weak
// int __fastcall set_http_auth_method(_DWORD); weak
// int __fastcall hwinfo_get_reboot_duration(_DWORD); weak
// int __fastcall get_urlsvc_config(_DWORD); weak
// int __fastcall wizard_api_set_mode(_DWORD); weak
// int __fastcall free_fw_list(_DWORD); weak
// int __fastcall wireless_api_get_station_list(_DWORD); weak
// int __fastcall wireless_api_get_current_mbss_num(_DWORD); weak
// int setenv(const char *name, const char *value, int replace);
// int __fastcall get_use_captcha_code(_DWORD); weak
// int strcasecmp(const char *s1, const char *s2);
// int __fastcall get_media_config(_DWORD); weak
// int __fastcall istatus_get_value_direct(_DWORD, _DWORD); weak
// int __fastcall decode_string(_DWORD); weak
// int __fastcall save_password(_DWORD, _DWORD); weak
// int __fastcall set_hwaddr_cloned(_DWORD, _DWORD); weak
// int __fastcall get_itunes_db_folder(_DWORD); weak
// void *malloc(size_t size);
// int __fastcall get_firmware_version2(_DWORD); weak
// int __fastcall class_make_couple(_DWORD, _DWORD); weak
// int __fastcall send_system_reboot_signal(_DWORD); weak
// int __fastcall set_plantynet_service(_DWORD); weak
// int __cdecl get_remote_mgmt_port(_DWORD, _DWORD, _DWORD); weak
// int httpcon_check_session_url(void); weak
// char *strrchr(const char *s, int c);
// int __fastcall strtomac(_DWORD, _DWORD); weak
// int get_captcha(void); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int __fastcall is_valid_pf_ipv4(_DWORD); weak
// int __fastcall set_autosaving(_DWORD); weak
// int __fastcall trunk_add_config(_DWORD, _DWORD); weak
// int __fastcall wireless_api_get_best_channel(_DWORD, _DWORD, _DWORD); weak
// int __fastcall fw_read_status(_DWORD, _DWORD); weak
// int scandir(const char *dir, struct dirent ***namelist, int (*selector)(const struct dirent *), int (*cmp)(const void *, const void *));
// int __fastcall read_sched_array(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_temperature(_DWORD); weak
// int __fastcall get_dhcp_auto_detect_status(_DWORD); weak
// int __fastcall clear_url_redirection(_DWORD); weak
// int __fastcall iconv_to_utf8(_DWORD, _DWORD, _DWORD); weak
// int __fastcall set_dhcp_auto_detect(_DWORD); weak
// size_t strlen(const char *s);
// int __fastcall get_default_gateway(_DWORD, _DWORD); weak
// int __fastcall set_url_redirect_cycle(_DWORD); weak
// int __fastcall stop_hostscan(_DWORD); weak
// int __fastcall set_autoreboot_config(_DWORD); weak
// int __fastcall sysconf_nat_set(_DWORD, _DWORD); weak
// char *ctime(const time_t *timer);
// int __fastcall set_url_redirect_autoconfirm(_DWORD); weak
// int __fastcall wds_remove(_DWORD, _DWORD); weak
// int __fastcall wireless_api_get_run(_DWORD); weak
// int __fastcall get_media_db_folder(_DWORD); weak
// int __fastcall set_admin_email(_DWORD); weak
// int stat(const char *file, struct stat *buf);
// int __fastcall get_smtp_auth(_DWORD); weak
// int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall get_file_string(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_itunes_db_filename(_DWORD); weak
// int __fastcall pppoe_stop(_DWORD); weak
// int __fastcall get_firmup_status(_DWORD); weak
// int __fastcall dhcpd_remove_static_lease(_DWORD, _DWORD); weak
// int __fastcall get_csrf_whites(_DWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __fastcall convert_mac(_DWORD); weak
// int __fastcall signal_start(_DWORD); weak
// int __fastcall netdetect_write_option(_DWORD, _DWORD); weak
// int __fastcall portforward_update_by_file(_DWORD, _DWORD); weak
// int __fastcall set_smtp_account(_DWORD); weak
// int __fastcall delete_pf_rule(_DWORD, _DWORD); weak
// int __fastcall firewall_update_by_file(_DWORD, _DWORD, _DWORD); weak
// int make_auth(void); weak
// int __fastcall set_jumbo_frame_control(_DWORD); weak
// int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int hwinfo_get_max_firmware_size(void); weak
// int init_pf_netfilter(void); weak
// int __fastcall get_idle_timeout(_DWORD); weak
// int __fastcall get_smtp_password(_DWORD); weak
// int __fastcall get_netaddr(_DWORD, _DWORD); weak
// int __fastcall hwinfo_get_mtu(_DWORD); weak
// int __fastcall set_firmupcheck_status(_DWORD); weak
// int __fastcall get_file_value(_DWORD, _DWORD); weak
// int __fastcall dhcpd_get_op(_DWORD); weak
// int __fastcall set_arp_protection(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_cupsd_status(_DWORD); weak
// int __fastcall print_item(_DWORD, _DWORD); weak
// int __fastcall set_media_config(_DWORD); weak
// int __fastcall portforward_add_rule(_DWORD, _DWORD, _DWORD); weak
// int add_rt_entry(void); weak
// int __fastcall init_url_redirection(_DWORD); weak
// int __fastcall dhclient_stop(_DWORD); weak
// int __fastcall set_cupsd_config(_DWORD); weak
// int __fastcall ddnsapi_read_config(_DWORD, _DWORD); weak
// int __fastcall check_valid_account(_DWORD); weak
// int __fastcall set_wbm_popup_flag(_DWORD); weak
// int __fastcall conv_time(_DWORD, _DWORD, _DWORD); weak
// int __fastcall convert_mac2(_DWORD); weak
// int __fastcall set_usb_tethering_op(_DWORD); weak
// int __fastcall dhcpd_set_op(_DWORD); weak
// int __fastcall get_nologin(_DWORD); weak
// int set_ftm_flag(void); weak
// int init_pf_rule(void); weak
// int __fastcall set_itunes_config(_DWORD); weak
// int __fastcall add_remotepc_config(_DWORD); weak
// int __fastcall dhcpd_flush_dynamic_lease(_DWORD); weak
// int __fastcall str(_DWORD); weak
// int __fastcall syslog_set_status(_DWORD); weak
// int __fastcall get_wan_link(_DWORD); weak
// int __fastcall httpcon_set_session_timeout(_DWORD); weak
// int __fastcall netdetect_set_option_rule(_DWORD, _DWORD); weak
// int __fastcall check_nas_service(_DWORD, _DWORD); weak
// int __fastcall print_html_apply_wait(_DWORD, _DWORD, _DWORD); weak
// int __fastcall validate_mac_addr(_DWORD); weak
// int __fastcall check_invalid_hwaddr(_DWORD); weak
// int get_process_list(void); weak
// int __fastcall wireless_get_channel_list(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall ddnsapi_add_config(_DWORD); weak
// int __fastcall set_urlsvc_config(_DWORD); weak
// int __fastcall get_dhcp_access_policy(_DWORD); weak
// int fclose(FILE *stream);
// int syslog_clear(void); weak
// int __fastcall free_fw_status_list(_DWORD); weak
// int __fastcall set_default_gateway2(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int set_multicast_forward_flag(void); weak
// int __fastcall get_sniff_port(_DWORD); weak
// int __fastcall set_pppoe_relay_enabled(_DWORD); weak
// int __fastcall get_autosaving(_DWORD); weak
// int __fastcall get_cupsd_config(_DWORD); weak
// int __fastcall syslog_get_count(_DWORD); weak
// int __fastcall istatus_get_intvalue_direct(_DWORD); weak
// int __fastcall get_wan_hw_ifname(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// int __fastcall get_wan_ipinfo(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall saveconf(_DWORD); weak
// int __fastcall check_unpermitted_chars(_DWORD); weak
// int __fastcall get_service_enable(_DWORD); weak
// int __fastcall get_value_post_multipart_file(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall get_led_silent_control(_DWORD); weak
// int __fastcall plantynet_service_event(_DWORD, _DWORD); weak
// int __fastcall macdb_search(_DWORD, _DWORD); weak
// int __fastcall set_multicast_forward_wireless(_DWORD); weak
// int __fastcall get_fuse_fsname(_DWORD, _DWORD); weak
// int chmod(const char *file, __mode_t mode);
// int __fastcall trunk_remove_config(_DWORD, _DWORD); weak
// int __fastcall get_filesize(_DWORD); weak
// int __fastcall get_dhcp_auto_detect(_DWORD); weak
// int __fastcall get_wireless_ifname(_DWORD); weak
// int __fastcall validate_ipv4_addr(_DWORD); weak
// int __fastcall get_cupsd_printer_status(_DWORD); weak
// int __fastcall encode_ipcloud_crypt(_DWORD, _DWORD); weak
// int __fastcall get_manual_dns_flag(_DWORD, _DWORD); weak
// int __fastcall iconfig_get_value_direct(_DWORD, _DWORD); weak
// int __fastcall pptpserver_get_index_pptpinfo(_DWORD, _DWORD); weak
// time_t time(time_t *timer);
// int __fastcall get_pppoe_ifname(_DWORD, _DWORD); weak
// int __fastcall set_rsync_config(_DWORD); weak
// int __fastcall get_media_db_filename(_DWORD); weak
// int __fastcall hwinfo_get_default_ip(_DWORD); weak
// int __fastcall get_samba_config(_DWORD); weak
// int __fastcall pptpserver_get_config(_DWORD, _DWORD); weak
// int __fastcall signal_wan(_DWORD); weak
// int __fastcall is_usb_removed(_DWORD); weak
// char *strtok(char *s, const char *delim);
// int __fastcall get_ledswitch_status(_DWORD); weak
// int __fastcall macauth_set_policy(_DWORD, _DWORD); weak
// int __fastcall set_wan_type(_DWORD, _DWORD); weak
// int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int netdetect_get_on_off(void); weak
// int __fastcall hwinfo_get_firmup_duration(_DWORD); weak
// int __fastcall get_value_post_multipart(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall set_fan_config(_DWORD); weak
// int post_process(void); weak
// int __fastcall free_process_list(_DWORD); weak
// int __fastcall convert_url_to_new(_DWORD, _DWORD); weak
// int __fastcall get_apcplan_flag(_DWORD); weak
// int __fastcall get_arp_protection(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_autoreboot_config(_DWORD); weak
// int __fastcall get_timezone_abbr_from_config(_DWORD); weak
// int __fastcall print_start_main_table(_DWORD); weak
// int __fastcall set_mtu_value(_DWORD, _DWORD); weak
// int __fastcall set_smtp_server(_DWORD); weak
// int __fastcall class_create(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall set_upnp_relay(_DWORD); weak
// int __fastcall get_mount_devpath(_DWORD, _DWORD); weak
// int __fastcall read_real_ipclone_leasetime(_DWORD, _DWORD); weak
// int __fastcall iconv_to_local(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD); weak
// int __fastcall etr(_DWORD); weak
// int __fastcall set_pppoe_status(_DWORD, _DWORD); weak
// int get_firmupcheck_status(void); weak
// int clear_port_statistics(void); weak
// int __fastcall dhcpd_get_dynamic_lease(_DWORD, _DWORD); weak
// int __fastcall print_sub_title(_DWORD, _DWORD); weak
// int __fastcall read_ftp_private_port(_DWORD, _DWORD); weak
// int __fastcall strtoupper(_DWORD); weak
// int __fastcall set_hostname(_DWORD); weak
// int __fastcall stop_wan(_DWORD); weak
// int __cdecl class_find(_DWORD, _DWORD, _DWORD); weak
// int __fastcall discover_upper_upnp_igd(_DWORD); weak
// int system2(const char *, ...); weak
// int __fastcall wireless_macauth_kickmac(_DWORD, _DWORD); weak
// int __fastcall macdb_free(_DWORD); weak
// int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD); weak
// char *fgets(char *s, int n, FILE *stream);
// int __fastcall set_device_removed(_DWORD, _DWORD); weak
// int __fastcall get_csrf_op(_DWORD); weak
// int __fastcall get_upnp_relay(_DWORD); weak
// int syslog_msg(_DWORD, const char *, ...); weak
// int __fastcall get_afp_config(_DWORD); weak
// int sscanf(const char *s, const char *format, ...);
// int __fastcall init_fw_netfilter(_DWORD); weak
// int __fastcall wireless_api_get_mimo(_DWORD); weak
// int __fastcall sysconf_nat_get(_DWORD); weak
// int httpcon_auth(void); weak
// char *strncpy(char *dest, const char *src, size_t n);
// int __fastcall convert_euckr_to_utf8(_DWORD, _DWORD); weak
// int __fastcall get_url_redirect_btnmsg(_DWORD); weak
// int __fastcall read_portconfig(_DWORD, _DWORD); weak
// int __fastcall get_hostscan(_DWORD); weak
// int __fastcall set_url_redirect_btnmsg(_DWORD); weak
// int __fastcall set_hwaddr_kernel(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_dhclient_block_private_ip(_DWORD); weak
// int __cdecl filter_add_to_class(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall print_html_progress_bar(_DWORD); weak
// int __fastcall get_smtp_account(_DWORD); weak
// int __fastcall set_active_wl(_DWORD, _DWORD); weak
// int __fastcall apply_dos_config(_DWORD); weak
// int __fastcall gen_sched_get_active_id(_DWORD, _DWORD); weak
// int __fastcall get_readable_sizestr(_DWORD, _DWORD); weak
// int __fastcall dhcpd_get_all_static_lease(_DWORD, _DWORD); weak
// int __fastcall wireless_apply_macauth(_DWORD, _DWORD); weak
// int __fastcall get_ipcloud_rand_str(_DWORD); weak
// int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall write_ftp_private_port(_DWORD, _DWORD); weak
// int __fastcall print_nbsp(_DWORD); weak
// int __fastcall ddnsapi_get_host_count(_DWORD); weak
// int __fastcall set_apcplan_flag(_DWORD); weak
// int __fastcall wireless_api_run_mbss(_DWORD); weak
// int __fastcall get_itunes_config(_DWORD); weak
// int __fastcall set_ftpd_config(_DWORD); weak
// int __fastcall Base64encode(_DWORD, _DWORD, _DWORD); weak
// int __fastcall print_end_main_table(_DWORD); weak
// int __fastcall fw_read_db(_DWORD, _DWORD); weak
// int __fastcall sysget_ui_version(_DWORD); weak
// int __fastcall dhcpd_read_config(_DWORD); weak
// int __fastcall set_system_dns(_DWORD); weak
// int __fastcall iconfig_remove_config_tag(_DWORD); weak
// int __fastcall get_igmp_proxy(_DWORD); weak
// int __fastcall dmztwinip_apply_off(_DWORD, _DWORD); weak
// int __fastcall remove_url_redir_freedevice(_DWORD); weak
// int unlink(const char *name);
// int __fastcall send_wol_packet(_DWORD); weak
// int __fastcall hwinfo_get_max_wds(_DWORD); weak
// int __fastcall netdetect_comment_for_specified_port(_DWORD, _DWORD); weak
// int __fastcall set_url_redirect_usermsg(_DWORD); weak
// int fflush(FILE *stream);
// int __fastcall nas_service_upnp_relay_init(_DWORD); weak
// int __fastcall pf_line_spchar_validate(_DWORD); weak
// void *memset(void *s, int c, size_t n);
// int __cdecl tc_reconfig(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall get_localbroadaddr(_DWORD, _DWORD); weak
// int __fastcall macauth_get_policy(_DWORD); weak
// char *inet_ntoa(struct in_addr in);
// int __fastcall netdetect_get_history_by_index(_DWORD); weak
// int __fastcall add_url_redir_freedevice(_DWORD); weak
// int __fastcall ddnsapi_read_config_by_service_type(_DWORD, _DWORD, _DWORD); weak
// int __fastcall set_fakedns(_DWORD); weak
// int __fastcall get_usb_mode(_DWORD); weak
// int __fastcall read_pppoe_option(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int __fastcall portforward_remove_rules(_DWORD, _DWORD, _DWORD); weak
// int __fastcall wireless_check_8021x_enabled(_DWORD); weak
// int __fastcall hwinfo_get_max_macauth(_DWORD); weak
// int __fastcall set_nas_user_system(_DWORD, _DWORD); weak
// int __fastcall wireless_api_enable_bss(_DWORD, _DWORD); weak
// int __fastcall is_mobile_agent(_DWORD); weak
// int __fastcall get_macclone_in_giga(_DWORD); weak
// int __fastcall print_item_desc(_DWORD); weak
// int __fastcall dhcpd_commit_config(_DWORD); weak
// int __fastcall br(_DWORD); weak
// int __fastcall add_plantynet_freedevice(_DWORD, _DWORD); weak
// int __cdecl syslog_max_count(_DWORD); weak
// int __fastcall get_num_of_mountdev(_DWORD); weak
// int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD); weak
// int __fastcall is_factory_test_mode(_DWORD); weak
// int __fastcall get_mtu_value(_DWORD, _DWORD); weak
// int __fastcall wireless_api_clear_station_info(_DWORD); weak
// int __fastcall class_destroy(_DWORD); weak
// int __fastcall get_hw_value_post(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_url_redirect_autoconfirm(_DWORD); weak
// int __fastcall get_dhcp_auto_restart(_DWORD); weak
// int __fastcall dhcpd_add_static_lease(_DWORD, _DWORD); weak
// int __fastcall tc_count_file_write(_DWORD); weak
// in_addr_t inet_addr(const char *cp);
// int __fastcall wireless_api_stop_ap_scan(_DWORD); weak
// int init_tr_netfilter(void); weak
// int __fastcall hwinfo_get_conntrack_default(_DWORD); weak
// int __fastcall wireless_api_get_current_channelspec(_DWORD, _DWORD); weak
// int __cdecl get_remote_mgmt_flag(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_wifi_switch_status(_DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int __fastcall print_input_select(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall set_use_local_gateway(_DWORD); weak
// int __fastcall get_pvalue(_DWORD, _DWORD); weak
// int __cdecl dhcpd_stop(_DWORD); weak
// int __fastcall get_upnp(_DWORD); weak
// int __fastcall start_hostscan(_DWORD); weak
// int __fastcall print_start_content_table(_DWORD); weak
// int sprintf(char *s, const char *format, ...);
// int __fastcall get_ifexist(_DWORD); weak
// int __fastcall get_torrent_config(_DWORD); weak
// int __fastcall read_mbssid_conf(_DWORD, _DWORD); weak
// int __fastcall get_url_redirect_usermsg2(_DWORD); weak
// int __fastcall check_wan_connected(_DWORD); weak
// int __fastcall get_wan_ip(_DWORD, _DWORD); weak
// int __fastcall class_id_list_get(_DWORD); weak
// int __fastcall set_firmup_status(_DWORD); weak
// int __fastcall get_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall wds_get_config(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_mount_list(_DWORD, _DWORD); weak
// int __fastcall get_twinip_wan_virtual_ip(_DWORD); weak
// int __fastcall set_use_captcha_code(_DWORD); weak
// int __fastcall print_blank_line(_DWORD, _DWORD); weak
// int __fastcall file_exists(_DWORD); weak
// int __fastcall istatus_set_value_direct(_DWORD, _DWORD); weak
// int __fastcall get_domain_name_server(_DWORD, _DWORD); weak
// int __fastcall remove_remotepc_config(_DWORD); weak
// int __fastcall get_timeserver_list(_DWORD, _DWORD); weak
// int __fastcall portforward_modify_rule(_DWORD, _DWORD, _DWORD); weak
// int check_remote_connection(void); weak
// int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall get_pvalue_array(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_use_local_gateway(_DWORD); weak
// int __fastcall wireless_get_wwan_enable(_DWORD); weak
// int check_unpermitted_ssid_chars(void); weak
// int __fastcall macauth_read_trylist(_DWORD, _DWORD); weak
// int __fastcall class_priority_order_write(_DWORD, _DWORD, _DWORD); weak
// int __fastcall set_wan_ipconfig(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall collapse(_DWORD, _DWORD); weak
// int __fastcall httpcon_get_session_timeout(_DWORD); weak
// int __fastcall set_wansetup_status(_DWORD, _DWORD); weak
// int __fastcall eth2wan(_DWORD, _DWORD); weak
// int __fastcall ddnsapi_get_status(_DWORD, _DWORD); weak
// int __fastcall check_ippool_range(_DWORD, _DWORD); weak
// int __fastcall defaultconf(_DWORD); weak
// int __fastcall get_remotepc_config(_DWORD, _DWORD); weak
// int __fastcall macauth_get_count(_DWORD); weak
// int __fastcall set_url_redirect_usermsg2(_DWORD); weak
// int __fastcall wizard_api_set_status(_DWORD, _DWORD); weak
// void exit(int status);
// int __fastcall set_smtp_auth(_DWORD); weak
// int __fastcall plantynet_service_request(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall remove_plantynet_freedevice(_DWORD); weak
// int get_usb_tethering_op(void); weak
// int __fastcall iconfig_set_intvalue_direct(_DWORD, _DWORD); weak
// int __fastcall set_usb_mode(_DWORD); weak
// int raise(int sig);
// int __fastcall add_gen_schedule(_DWORD, _DWORD); weak
// int get_multicast_forward_flag(void); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall wizard_api_get_status(_DWORD, _DWORD); weak
// int __fastcall check_wifi_regulation(_DWORD); weak
// int __fastcall wireless_api_get_mbridge_status(_DWORD, _DWORD); weak
// int __fastcall get_subnet_range(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int strcmp(const char *s1, const char *s2);
// int tethering_is_running(void); weak
// int __fastcall set_macclone_in_giga(_DWORD); weak
// int __fastcall get_smtp_server(_DWORD); weak
// int __fastcall wireless_api_add_mbss(_DWORD, _DWORD, _DWORD); weak
// int __fastcall set_lan_ipconfig(_DWORD, _DWORD, _DWORD); weak
// int __fastcall syslog_get_filename(_DWORD); weak
// int __fastcall remove_gen_schedule(_DWORD, _DWORD); weak
// int __fastcall maccmp(_DWORD, _DWORD); weak
// int __fastcall pptpserver_add_user(_DWORD); weak
// int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD); weak
// int __fastcall check_unpermitted_password_chars(_DWORD); weak
// int __fastcall get_ip_value_post(_DWORD, _DWORD, _DWORD); weak
// int __fastcall set_url_redirect_option(_DWORD, _DWORD); weak
// int __fastcall fw_delete_rules(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl get_led_silent_state(_DWORD); weak
// int __fastcall syslog_set_email_status(_DWORD, _DWORD); weak
// int __fastcall insert_tr_to_rule(_DWORD, _DWORD); weak
// int __fastcall ddnsapi_clear_status_by_service_type(_DWORD); weak
// int __fastcall write_rt_db(_DWORD); weak
// int __fastcall pptpserver_disconnect_user(_DWORD); weak
// int __fastcall netdetect_read_current_history(_DWORD); weak
// int __fastcall print_end_content_table(_DWORD); weak
// int __fastcall apply_jumbo_frame_control(_DWORD); weak
// void free(void *ptr);
// int __fastcall portforward_read_db(_DWORD, _DWORD); weak
// int atoi(const char *nptr);
// int __fastcall get_iptime_service_network(_DWORD); weak
// int __fastcall restore_backup_config(_DWORD); weak
// int __fastcall get_plantynet_freedevice(_DWORD, _DWORD, _DWORD); weak
// int __cdecl get_usb_tethering_status(_DWORD); weak
// int __fastcall check_same_network(_DWORD, _DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int __fastcall dhcpd_search_static_lease(_DWORD, _DWORD); weak
// int __fastcall remove_all_gen_schedule(_DWORD); weak
// int __fastcall set_ipmac_bind(_DWORD); weak
// int __fastcall dmztwinip_apply_twinip(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall signal_toggle(_DWORD); weak
// int syslog_set_sendmail(void); weak
// int __fastcall get_internet_connected_time(_DWORD); weak
// int __fastcall check_bandwidth_limitation(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall free_portforward_list(_DWORD); weak
// int __fastcall set_ifconfig(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_id_password(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int __fastcall ddnsapi_set_refresh_flag(_DWORD, _DWORD); weak
// int __fastcall get_admin_email(_DWORD); weak
// int __fastcall unlock_file(_DWORD); weak
// int __fastcall pptpserver_user_count(_DWORD); weak
// int wireless_api_get_operation_mode(void); weak
// int __fastcall class_get(_DWORD); weak
// int __fastcall set_default_gateway(_DWORD, _DWORD); weak
// char *strdup(const char *s);
// int __fastcall signal_update(_DWORD); weak
// int __fastcall wireless_api_apply_mbssid(_DWORD); weak
// int __fastcall set_sniff_port(_DWORD); weak
// int __fastcall tc_close(_DWORD); weak
// int __fastcall write_wireless_conf(_DWORD, _DWORD); weak
// int __fastcall dhcpd_remove_dynamic_lease(_DWORD, _DWORD); weak
// int puts(const char *s);
// int __fastcall write_file(_DWORD, _DWORD); weak
// int __fastcall get_jumbo_frame_control(_DWORD); weak
// int __fastcall fw_modify_db(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall set_dhcp_auto_restart(_DWORD, _DWORD); weak
// int __fastcall get_hostname(_DWORD); weak
// int __fastcall set_afp_config(_DWORD); weak
// int __fastcall check_default_gateway(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_firmupcheck_version(_DWORD); weak
// int __fastcall save_pppoe_option(_DWORD, _DWORD); weak
// int __fastcall strtolower(_DWORD); weak
// int __fastcall ddnsapi_remove_by_service_type(_DWORD); weak
// int __fastcall set_url_redirect_whitelist(_DWORD); weak
// int __fastcall get_ifstatus(_DWORD); weak
// int __fastcall set_domain_name_server(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_send_email(_DWORD); weak
// int __fastcall get_remotepc_num(_DWORD); weak
// int __cdecl tc_open(_DWORD); weak
// int __fastcall get_pppoe_status(_DWORD); weak
// int __fastcall print_file(_DWORD); weak
// int __fastcall write_file_intval(_DWORD, _DWORD); weak
// int __fastcall set_manual_dns_flag(_DWORD, _DWORD, _DWORD); weak
// int __fastcall portforward_upnp_relay_init(_DWORD); weak
// int __fastcall set_nas_user(_DWORD, _DWORD, _DWORD); weak
// int __fastcall fw_spchar_validate(_DWORD); weak
// int __fastcall get_default_id_password(_DWORD, _DWORD); weak
// int __fastcall istatus_remove_status_tag(_DWORD); weak
// int __fastcall bcm_wireless_macauth_kickall(_DWORD); weak
// int __fastcall wds_add(_DWORD); weak
// int __fastcall get_timed_status(_DWORD); weak
// char *strcpy(char *dest, const char *src);
// int __fastcall set_send_email(_DWORD); weak
// int __fastcall pptpserver_remove_user(_DWORD); weak
// int __fastcall lock_file(_DWORD); weak
// int __fastcall macdb_write(_DWORD, _DWORD); weak
// int __fastcall wireless_api_support_onlyb(_DWORD); weak
// int __fastcall _deregister_frame_info(_DWORD); weak
// int __fastcall check_twinip_enable(_DWORD); weak
// int __fastcall remove_captcha(_DWORD); weak
void sub_11CF0();
int *sub_11D34();
const char *__fastcall sub_11D88(int a1, int a2, const char *a3);
int __fastcall sub_11F2C(int a1, int a2);
int __fastcall sub_1218C(int a1);
int __fastcall sub_122D8(int a1, int a2, const char *a3);
int __fastcall sub_12348(int a1, const char *a2, const char *a3);
int __fastcall sub_124A0(int a1, char *a2, const char *a3);
int __fastcall sub_1251C(const char **a1, const char *a2);
void __fastcall sub_125AC(const char *a1, const char *a2);
void __fastcall sub_127B0(int a1, const char *a2);
int __fastcall sub_12B70(int a1);
int __fastcall sub_12BB4(int a1, const char **a2);
int sub_13284(); // weak
int __fastcall sub_132A4(int a1, int a2);
void *__fastcall sub_13300(int a1);
void *__fastcall sub_133EC(int a1);
int __fastcall sub_134F8(int a1);
int __fastcall sub_135C8(int a1);
int __fastcall sub_135E0(_DWORD *a1, const char *a2);
int __fastcall sub_13A0C(int a1, const char *a2);
int __fastcall sub_13A58(int a1);
int __fastcall sub_13DE8(_DWORD *a1, _DWORD *a2, char *a3, int a4);
int __fastcall sub_13EB0(int a1, int a2, int a3);
int __fastcall sub_14334(int a1);
int __fastcall sub_145E0(int a1, int a2, const char *a3);
int __fastcall sub_1466C(int a1, int a2);
int __fastcall sub_146D0(int a1);
int __fastcall sub_1472C(int a1);
int __fastcall sub_1478C(int a1);
int __fastcall sub_147EC(int a1);
const char *__fastcall sub_1497C(char *s1);
int __fastcall sub_149CC(int result);
void *__fastcall sub_14A54(int a1);
int __fastcall sub_14B34(const char *a1);
signed int sub_14CC8();
int __fastcall sub_14D08(int a1, int a2);
int __fastcall sub_14D20(int a1);
signed int __fastcall sub_14E00(unsigned int a1, int a2, int a3);
int __fastcall sub_14FF4(int a1, int a2, int a3);
signed int __fastcall sub_15018(int a1);
int __fastcall sub_15158(int a1, int a2);
int __fastcall sub_15324(int a1);
int __fastcall sub_1535C(int a1, int a2, int a3);
void *__fastcall sub_15410(int a1);
void *__fastcall sub_1551C(int a1, int a2, int a3, int a4);
int __fastcall sub_15664(int a1, const char *a2, int a3);
int __fastcall sub_157CC(int a1, _BYTE *a2, int a3);
char *__fastcall sub_159DC(const char *a1, int a2, signed int *a3, _DWORD *a4);
signed int __fastcall sub_15C10(int a1, int a2, char *a3);
int __fastcall sub_15D88(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_15DE4(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_15E70(int a1, int a2, int a3);
int __fastcall sub_15F18(int a1);
void *__fastcall sub_15F34(const char *a1);
int sub_16030();
signed int __fastcall sub_16038(int a1);
void *sub_16094();
void *sub_160D0();
signed int __fastcall sub_1611C(const char *a1);
int __fastcall sub_16278(int a1, const char *a2);
int __fastcall sub_1633C(int a1);
int __fastcall sub_16404(void *a1);
signed int __fastcall sub_1648C(const char *a1);
int __fastcall sub_164F8(const char *a1);
int __fastcall sub_1655C(time_t a1, char *a2, size_t a3, int a4);
signed int __fastcall sub_167D8(char *a1, time_t a2);
int __fastcall sub_1682C(int a1, int a2, int a3);
int __fastcall sub_16878(int a1);
signed int __fastcall sub_17428(const char *a1, const char *a2);
signed int __fastcall sub_177D4(int a1, char *a2, size_t a3);
signed int __fastcall sub_1793C(int a1, const char *a2, int a3);
char *__fastcall sub_17B4C(char *s1, const char *a2);
char *__fastcall sub_17C0C(char *s1, const char *a2);
int __fastcall sub_17CCC(int a1);
int __fastcall sub_17F88(int a1, int a2, int a3);
int __fastcall sub_181D8(int result, int a2);
int __fastcall sub_1820C(int a1, int a2, int a3, int a4);
int __fastcall sub_18280(const char *a1, int a2);
int __fastcall sub_18314(int a1, int a2, const char *a3, int a4, int a5, int a6, int a7);
int __fastcall sub_184D4(const char *a1);
int __fastcall sub_189D4(int a1);
int __fastcall sub_18B20(int a1);
int __fastcall sub_18D40(int a1, int a2, int a3);
int __fastcall sub_18DE0(int a1);
int sub_18E38();
int __fastcall sub_18F48(int a1);
int __fastcall sub_18F64(int a1, int a2, int a3, const char *a4);
void __fastcall sub_1903C(int a1);
int __fastcall sub_19220(int a1);
int __fastcall sub_1979C(int a1);
int __fastcall sub_19964(int a1);
const char *__fastcall sub_19BD8(int a1);
int sub_19D98();
int sub_1A028();
int sub_1A270();
int __fastcall sub_1A564(int a1);
int __fastcall sub_1B168(int a1);
void *__fastcall sub_1B2A8(const char *a1);
int sub_1B328();
int __fastcall sub_1BC58(const char *a1, int a2, int a3);
int __fastcall sub_1BDA8(int a1, int a2, const char *a3);
int __fastcall sub_1BEE0(int a1, const char *a2, int a3);
int __fastcall sub_1C040(int a1, int a2, const char *a3);
int __fastcall sub_1C1F4(int a1);
int __fastcall sub_1C85C(int a1, int a2);
int __fastcall sub_1D13C(int a1);
int sub_1D330();
int __fastcall sub_1D51C(char *s2, int a2, int a3);
signed int __fastcall sub_1D568(int a1, _DWORD *a2);
int sub_1D5BC();
unsigned int __fastcall sub_1D884(const char *a1, const char *a2);
int sub_1D8A8();
int sub_1DC20();
signed int __fastcall sub_1DF3C(int a1);
int __fastcall sub_1DFE8(int a1, int a2);
signed int __fastcall sub_1E274(int a1);
void __fastcall sub_1E460(int a1, int a2);
int sub_1E844();
int __fastcall sub_1EB1C(int a1);
int __fastcall sub_1ED78(int a1);
int __fastcall sub_1F090(int a1, int a2, int a3);
int sub_1F0F0();
int __fastcall sub_1F128(int a1, int a2, char *a3);
int sub_1F1A8();
int __fastcall sub_1F204(int a1);
int __fastcall sub_1F29C(int a1);
int __fastcall sub_1F354(int a1);
int __fastcall sub_1F3F0(int a1);
int sub_1F488();
int __fastcall sub_1F638(int a1);
int __fastcall sub_1F6D0(int a1, int a2, char *a3);
int sub_1F750();
int sub_1FA00();
int sub_1FC78();
int sub_1FD20();
int __fastcall sub_1FD60(int a1);
int __fastcall sub_1FE34(int a1);
int __fastcall sub_1FF84(const char *a1);
int __fastcall sub_20164(const char *a1, int a2);
int __fastcall sub_201D8(int a1);
int sub_20B30();
int __fastcall sub_20D14(int a1, int a2);
int __fastcall sub_21898(int a1);
int __fastcall sub_21BC4(int a1);
FILE *sub_21D28();
int __fastcall sub_21E64(int a1);
int __fastcall sub_222AC(int a1);
int __fastcall sub_23004(int a1, int a2, int a3);
signed int __fastcall sub_23508(int a1);
int __fastcall sub_2355C(int a1);
int __fastcall sub_238E4(int a1);
int __fastcall sub_23B30(int a1, int a2, int a3);
int __fastcall sub_24104(int a1, int *a2, int a3);
int __fastcall sub_24590(int a1, int a2, int a3);
int sub_246E4();
int sub_2471C(); // weak
int sub_2472C(); // weak
int __fastcall sub_24738(int a1, int a2);
int __fastcall sub_248E8(int a1);
signed int __fastcall sub_24E24(int a1, int a2, int a3, int a4);
signed int __fastcall sub_24E88(int a1, char *a2, int a3);
signed int __fastcall sub_2510C(_DWORD *a1, int a2, const char *a3);
signed int __fastcall sub_251D4(_DWORD *a1, int a2);
int __fastcall sub_2522C(int a1);
int __fastcall sub_255E4(int a1, int a2);
int __fastcall sub_25814(int a1, int a2);
int __fastcall sub_25B64(int a1);
int __fastcall sub_26080(int a1, int a2, int a3);
const char *__fastcall sub_260D4(int a1, int a2, int a3);
void *__fastcall sub_263E8(int a1);
void *__fastcall sub_26430(int a1);
void *__fastcall sub_2645C(int a1, int a2);
int __fastcall sub_2648C(int a1);
int __fastcall sub_26778(int a1, int a2, int a3);
int __fastcall sub_2688C(int a1, int a2, int a3);
int __fastcall sub_268B8(int a1, int a2, int a3);
int __fastcall sub_26968(int a1, int a2, int a3);
int __fastcall sub_26A20(int a1, int a2, int a3);
int __fastcall sub_26A90(int a1, int a2, int a3);
int __fastcall sub_26ABC(int a1, int a2, int a3);
int __fastcall sub_26B14(int a1, int a2, int a3);
int __fastcall sub_26B40(int a1, int a2, int a3);
int __fastcall sub_26B6C(int a1, int a2, int a3);
int __fastcall sub_26B98(const char *a1, int a2, int a3);
int __fastcall sub_26D5C(const char *a1, int a2, int a3, int a4);
int __fastcall sub_26DC8(int a1, int a2, int a3);
int __fastcall sub_27104(int a1);
int __fastcall sub_27B0C(int a1, int a2);
int __fastcall sub_27B68(int a1, int a2, int a3);
const char *__fastcall sub_27E14(int a1);
const char *__fastcall sub_27E5C(int a1);
int __fastcall sub_28BA8(int a1);
int __fastcall sub_28F7C(int a1);
const char *__fastcall sub_28FDC(int a1);
int __fastcall sub_2904C(int a1);
int __fastcall sub_2AB48(const char *a1, int a2, int a3);
int __fastcall sub_2AC18(int a1, int a2, int a3);
const char *__fastcall sub_2B12C(int a1, int a2);
void __fastcall sub_2B298(int a1);
int __fastcall sub_2B9D4(int a1, int a2);
int __fastcall sub_2BA30(int a1, int a2, int a3, int a4, signed int a5);
const char *__fastcall sub_2BF4C(int a1, int a2, int a3);
int __fastcall sub_2C16C(const char *a1, void *a2);
int __fastcall sub_2C1D0(int a1);
int __fastcall sub_2CCBC(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_2CD78(int a1, int a2);
char *__fastcall sub_2D160(int a1, char *a2, int a3, int a4, char *a5);
int __fastcall sub_2D280(const char *a1, const char *a2, int a3);
int sub_2D354();
int __fastcall sub_2D46C(int a1);
int __fastcall sub_2D590(int a1);
int __fastcall sub_2D770(int a1);
int __fastcall sub_2D90C(int a1);
int __fastcall sub_2DAB8(int a1);
int __fastcall sub_2DCD0(int a1);
int __fastcall sub_2DF74(int a1);
int __fastcall sub_2E224(int a1);
int __fastcall sub_2E5E8(int a1);
int sub_2E798();
int __fastcall sub_2E89C(int a1);
int __fastcall sub_2EAF0(int a1);
int __fastcall sub_2EAF8(int a1);
int __fastcall sub_2EB00(int a1, int a2);
int __fastcall sub_2EDE0(int a1, int a2);
int __fastcall sub_2F188(const char *a1);
_BYTE *__fastcall sub_2F698(_BYTE *result);
int sub_2F6C0();
int sub_2F6F8();
int sub_2F718();
int sub_2F7B4();
int __fastcall sub_2FA90(int result, int a2);
int __fastcall sub_2FDCC(int a1, int a2);
int __fastcall sub_30078(int a1, int a2, int a3);
const char *__fastcall sub_306AC(const char *a1, const char *a2, int a3, signed int a4);
_DWORD *__fastcall sub_307E4(const char *a1);
int __fastcall sub_30F68(int result);
int __fastcall sub_30F78(int a1, int a2, int a3);
signed int __fastcall sub_310B4(const char *a1);
signed int __fastcall sub_31288(const char *a1);
int __fastcall sub_3134C(int a1);
int __fastcall sub_327D0(int a1, int a2);
int __fastcall sub_32934(int a1, const char *a2);
int __fastcall sub_32FC4(int a1, const char *a2);
int __fastcall sub_3328C(int a1);
FILE *__fastcall sub_333D0(int a1, int a2);
int sub_33468();
signed int __fastcall sub_33950(int a1);
int sub_34554();
signed int __fastcall sub_34784(const char *a1, int a2);
int __fastcall sub_347E0(int a1);
int __fastcall sub_34C10(int a1);
int __fastcall sub_34F34(int a1);
_BYTE *__fastcall sub_3542C(_BYTE *result);
int sub_35454();
int __fastcall sub_3548C(unsigned int a1);
int sub_3555C();
int __fastcall sub_35838(int a1, char *a2);
signed int __fastcall sub_3599C(const char **a1, const char *a2);
char *__fastcall sub_359F4(int a1);
const char *__fastcall sub_35A68(char *src);
int __fastcall sub_35AD0(int result);
const char *__fastcall sub_35AE0(const char *a1, const char *a2, int a3, signed int a4);
void *__fastcall sub_35C18(const char *a1);
int __fastcall sub_368B0(int a1, int a2, int a3);
int __fastcall sub_36DE4(int a1, int a2, int a3);
int __fastcall sub_37724(int a1, int a2);
int __fastcall sub_37770(int a1);
signed int __fastcall sub_377A4(const char *a1);
int __fastcall sub_37AB4(int a1, const char *a2);
int sub_38488();
int __fastcall sub_386A0(int a1, int a2);
FILE *__fastcall sub_38810(int a1, int a2);
int __fastcall sub_3971C(int a1);
int __fastcall sub_397F0(int a1);
const char *__fastcall sub_399F0(int a1);
int __fastcall sub_39AE0(int a1);
int sub_39C60();
int __fastcall sub_3A1E0(int a1);
int __fastcall sub_3A22C(const char *a1, int a2);
int __fastcall sub_3A5B4(const char *a1, int a2);
int __fastcall sub_3A788(int a1);
int __fastcall sub_3ADA8(int a1, int a2, int a3);
int __fastcall sub_3B188(int a1);
signed int __fastcall sub_3C39C(int a1, signed int *a2);
int __fastcall sub_3CB10(int a1);
int __fastcall sub_3CC70(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __fastcall sub_3CF78(int a1, int a2);
signed int __fastcall sub_3D4B4(int a1, signed int *a2);
int sub_3D57C();
int __fastcall sub_3D694(signed __int64 a1, char *a2);
int __fastcall sub_3D780(int a1);
int __fastcall sub_3D844(_DWORD *a1, const char *a2, unsigned int **a3);
FILE *__fastcall sub_3DA9C(unsigned int **a1);
int sub_3DD88();
int __fastcall sub_3DD98(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __fastcall sub_3E240(int *a1);
int __fastcall sub_3E4C4(int *a1);
int __fastcall sub_3E8D4(_DWORD *a1);
int __fastcall sub_3E934(_DWORD *a1);
int __fastcall sub_3E9C4(int a1);
int __fastcall sub_3EAC4(int a1);
int __fastcall sub_3EC54(int a1);
int sub_3EE1C();
int sub_3F0FC();
int __fastcall sub_3F604(int a1);
const char *__fastcall sub_3F7AC(int a1);
int __fastcall sub_3F810(int a1);
int __fastcall sub_3F8F8(int a1, int a2);
int __fastcall sub_3F9A4(int a1);
int __fastcall sub_3FB98(int a1, int a2);
int __fastcall sub_3FE94(int a1);
signed int __fastcall sub_40050(signed int result, int a2, _QWORD *a3);
int __fastcall sub_40174(int a1, signed int a2, int a3, signed int a4);
const char *__fastcall sub_40428(int a1);
int __fastcall sub_4046C(int a1);
int __fastcall sub_41844(int a1);
int __fastcall sub_41ADC(int a1);
int __fastcall sub_42220(int a1);
int sub_423E4();
_BOOL4 __fastcall sub_42748(int a1);
signed int __fastcall sub_4277C(int a1);
void *__fastcall sub_42A70(int a1, const char *a2);
int __fastcall sub_42B80(int a1);
int sub_42F8C();
int sub_4332C();
int __fastcall sub_43540(int a1);
int __fastcall sub_436F8(int a1);
__int64 __fastcall sub_437AC(int a1, int a2, int a3, int a4);
int sub_43960();
int __fastcall sub_43DD0(int a1);
FILE *__fastcall sub_444C8(int a1);
int __fastcall sub_445BC(int a1, int a2);
int __fastcall sub_4473C(int a1);
int __fastcall sub_467A0(int a1);
int __fastcall sub_46BC4(int a1);
int __fastcall sub_46C08(_DWORD); // weak
signed int __fastcall sub_46C0C(const char *a1);
const char *__fastcall sub_46C58(int a1);
const char *__fastcall sub_46F64(int a1);
int __fastcall sub_470B4(int a1);
int __fastcall sub_478F4(int a1);
int sub_47DA8();
const char *__fastcall sub_47F4C(int a1);
int sub_47F74();
signed int __fastcall sub_48278(int a1, int a2);
int __fastcall sub_485C4(int a1);
char *__fastcall sub_48788(int a1, const char *a2);
int __fastcall sub_48820(int a1, int a2);
int __fastcall sub_48C10(int result, const char *a2, int a3);
int __fastcall sub_48D4C(int result, const char *a2, int a3);
int __fastcall sub_49034(int a1, int a2, int a3);
int __fastcall dir_filter(int a1);
int __fastcall sub_490F0(int a1, int a2);
signed int __fastcall sub_49160(int a1, int a2);
int sub_49288(); // weak
char *__fastcall sub_492E8(const char *a1);
void *sub_49370();
void *__fastcall sub_493F8(const char *a1);
int sub_4950C();
signed int __fastcall sub_495C0(int a1);
void __fastcall sub_4A628(int a1);
int sub_4B1B8();
int sub_4B37C();
int sub_4B7D0();
int sub_4BAC0();
int __fastcall sub_4BD0C(int a1, int a2, int a3, char a4);
int sub_4BF54();
int sub_4C1E4();
int sub_4C564();
int sub_4C8E0();
int sub_4CCA8();
int sub_4CF68();
int __fastcall sub_4D0DC(int a1, int a2, int a3);
int __fastcall sub_4D2B0(const char *a1, int a2);
int __fastcall sub_4D448(const char *a1, int a2);
int __fastcall sub_4D4BC(int a1);
int __fastcall sub_4D828(int a1);
int __fastcall sub_4E274(int a1);
int sub_4E54C();
unsigned int __fastcall sub_4EB80(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_4EC28(unsigned int a1, unsigned int a2);
int __fastcall sub_4EC48(int a1, int a2);
int __fastcall sub_4EC50(int result, unsigned int a2);
int __fastcall sub_4ED24(int a1, unsigned int a2);
int __fastcall sub_4ED50(int result, int a2, int a3, unsigned int a4);
unsigned int __fastcall sub_4EEE8(unsigned int result);
int __fastcall sub_4EF94(unsigned int a1, unsigned int a2, int a3, int a4);
int __fastcall sub_4F12C(unsigned int a1, unsigned int a2, int a3, int a4);
unsigned int __fastcall sub_4F28C(int a1);
int __fastcall sub_4F2E8(__int64 a1, __int64 a2);
int __fastcall sub_4F370(__int64 a1, __int64 a2, _QWORD *a3);
unsigned __int64 __fastcall sub_4F3AC(unsigned int a1, signed int a2, unsigned int a3, signed int a4);
signed int __fastcall sub_4F810(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int *off_10000 = (int *)0x7F13C; // weak
_UNKNOWN loc_4EC1C; // weak
_UNKNOWN loc_4ED14; // weak
_UNKNOWN loc_4F034; // weak
_UNKNOWN loc_4F0C4; // weak
_UNKNOWN loc_4F10C; // weak
_UNKNOWN loc_4F120; // weak
_UNKNOWN loc_4F324; // weak
_UNKNOWN unk_4FC79; // weak
_UNKNOWN unk_50630; // weak
_UNKNOWN unk_50E6D; // weak
_UNKNOWN unk_515B9; // weak
_UNKNOWN unk_516E1; // weak
_UNKNOWN unk_518CC; // weak
_UNKNOWN unk_51C70; // weak
_UNKNOWN unk_51FC2; // weak
_UNKNOWN unk_51FD4; // weak
char *off_53BAC = "system"; // weak
char *off_53BB8 = "시스템 요약 정보"; // weak
_UNKNOWN unk_55260; // weak
_UNKNOWN unk_555C0; // weak
_UNKNOWN unk_5572C; // weak
_UNKNOWN unk_55785; // weak
_UNKNOWN unk_5581B; // weak
_UNKNOWN unk_55B27; // weak
_UNKNOWN unk_55C62; // weak
_UNKNOWN unk_568FA; // weak
_UNKNOWN unk_569E1; // weak
_UNKNOWN unk_56D46; // weak
_UNKNOWN unk_57CFC; // weak
_UNKNOWN unk_57D79; // weak
_UNKNOWN unk_57D9D; // weak
_UNKNOWN unk_586BD; // weak
_UNKNOWN unk_58EAA; // weak
_UNKNOWN unk_591FE; // weak
_UNKNOWN unk_592C1; // weak
_UNKNOWN unk_5998A; // weak
_UNKNOWN unk_59DCA; // weak
_UNKNOWN unk_5BD8A; // weak
_UNKNOWN unk_5BF6E; // weak
_UNKNOWN unk_5BFCF; // weak
_UNKNOWN unk_5C5EA; // weak
_UNKNOWN unk_5C75F; // weak
_UNKNOWN unk_5CAB4; // weak
_UNKNOWN unk_5D82D; // weak
_UNKNOWN unk_5E254; // weak
_UNKNOWN unk_5E284; // weak
_UNKNOWN unk_5E6AE; // weak
_UNKNOWN unk_5E723; // weak
_UNKNOWN unk_5E950; // weak
_UNKNOWN unk_5E962; // weak
_UNKNOWN unk_5E98F; // weak
_UNKNOWN unk_5E9A5; // weak
_UNKNOWN unk_5E9FA; // weak
_UNKNOWN unk_5EA00; // weak
_UNKNOWN unk_5EA0D; // weak
_UNKNOWN unk_5EA14; // weak
_UNKNOWN unk_5EB15; // weak
_UNKNOWN unk_5EB25; // weak
_UNKNOWN unk_5F528; // weak
_UNKNOWN unk_5F56C; // weak
_UNKNOWN unk_5F59E; // weak
_UNKNOWN unk_6058E; // weak
_UNKNOWN unk_60979; // weak
_UNKNOWN unk_61BDB; // weak
_UNKNOWN unk_61F57; // weak
_UNKNOWN unk_62D12; // weak
_UNKNOWN unk_63754; // weak
_UNKNOWN unk_63959; // weak
_UNKNOWN unk_63990; // weak
_UNKNOWN unk_639AE; // weak
_UNKNOWN unk_63EA7; // weak
_UNKNOWN unk_63EBA; // weak
_UNKNOWN unk_640C8; // weak
_UNKNOWN unk_642D0; // weak
_UNKNOWN unk_644C9; // weak
_UNKNOWN unk_64515; // weak
_UNKNOWN unk_64517; // weak
_UNKNOWN unk_648CE; // weak
_UNKNOWN unk_66A98; // weak
_UNKNOWN unk_66FE1; // weak
_UNKNOWN unk_6922F; // weak
_UNKNOWN unk_694FB; // weak
_UNKNOWN unk_69512; // weak
_UNKNOWN unk_69AA7; // weak
_UNKNOWN unk_6A267; // weak
_UNKNOWN unk_6A627; // weak
_UNKNOWN unk_6A632; // weak
_UNKNOWN unk_6AE5B; // weak
_UNKNOWN unk_6B198; // weak
_UNKNOWN unk_6B545; // weak
_UNKNOWN unk_6B810; // weak
_UNKNOWN unk_6B8FA; // weak
_UNKNOWN unk_6B906; // weak
_UNKNOWN unk_6B90F; // weak
_UNKNOWN unk_6BB3D; // weak
_UNKNOWN unk_6C6BC; // weak
_UNKNOWN unk_6C6FA; // weak
_UNKNOWN unk_6CA43; // weak
_UNKNOWN unk_6CAEC; // weak
_UNKNOWN unk_6CC01; // weak
_UNKNOWN unk_6D12D; // weak
_UNKNOWN unk_6DF00; // weak
_UNKNOWN unk_6E88F; // weak
_UNKNOWN unk_6E894; // weak
_UNKNOWN unk_6EE4F; // weak
_UNKNOWN unk_6F526; // weak
_UNKNOWN unk_6F755; // weak
_UNKNOWN unk_6F79E; // weak
_UNKNOWN unk_6F93D; // weak
_UNKNOWN unk_6F951; // weak
_UNKNOWN unk_70C4D; // weak
_UNKNOWN unk_720DA; // weak
_UNKNOWN unk_724B1; // weak
_UNKNOWN unk_74392; // weak
_UNKNOWN unk_752F2; // weak
_UNKNOWN unk_7534C; // weak
_UNKNOWN unk_7603A; // weak
_UNKNOWN unk_7606E; // weak
_UNKNOWN unk_76948; // weak
_UNKNOWN unk_774DC; // weak
_UNKNOWN unk_77656; // weak
_UNKNOWN unk_777B1; // weak
_UNKNOWN unk_7797F; // weak
_UNKNOWN unk_779C8; // weak
_UNKNOWN unk_779CB; // weak
_UNKNOWN unk_77AF5; // weak
_UNKNOWN unk_77AF8; // weak
_UNKNOWN unk_77AFF; // weak
_UNKNOWN unk_7834B; // weak
_UNKNOWN unk_78375; // weak
_UNKNOWN unk_792FC; // weak
_UNKNOWN unk_79625; // weak
_UNKNOWN unk_7971E; // weak
_UNKNOWN unk_7B066; // weak
_UNKNOWN unk_7B390; // weak
_UNKNOWN unk_7B480; // weak
_UNKNOWN unk_7B52B; // weak
_UNKNOWN unk_7BDC2; // weak
_UNKNOWN unk_7C1D2; // weak
_UNKNOWN unk_7CFAC; // weak
_UNKNOWN unk_7DC8B; // weak
_UNKNOWN unk_7E062; // weak
_UNKNOWN unk_7E3AA; // weak
_UNKNOWN unk_7F2B0; // weak
_UNKNOWN unk_7F2FC; // weak
_UNKNOWN unk_7F83C; // weak
_UNKNOWN unk_7FB64; // weak
_UNKNOWN unk_8083F; // weak
_UNKNOWN unk_809D6; // weak
_UNKNOWN unk_80E9F; // weak
_UNKNOWN unk_815D2; // weak
_UNKNOWN unk_81C49; // weak
_UNKNOWN unk_81D70; // weak
_UNKNOWN unk_81E66; // weak
_UNKNOWN unk_81E9C; // weak
_UNKNOWN unk_81ECE; // weak
_UNKNOWN unk_81F18; // weak
_UNKNOWN unk_82010; // weak
_UNKNOWN unk_82079; // weak
_UNKNOWN unk_82938; // weak
_UNKNOWN unk_8295A; // weak
_UNKNOWN unk_82B7A; // weak
_UNKNOWN unk_82D09; // weak
_UNKNOWN unk_82FE9; // weak
_UNKNOWN unk_830D5; // weak
_UNKNOWN unk_848E8; // weak
_UNKNOWN unk_854DD; // weak
_UNKNOWN unk_86169; // weak
_UNKNOWN unk_862E4; // weak
_UNKNOWN unk_86341; // weak
_UNKNOWN unk_864C0; // weak
_UNKNOWN unk_864E6; // weak
_UNKNOWN unk_86556; // weak
_UNKNOWN unk_865DB; // weak
_UNKNOWN unk_866ED; // weak
_UNKNOWN unk_867CF; // weak
int dword_8F008 = 0; // weak
_UNKNOWN unk_8FAE0; // weak
_UNKNOWN unk_8FB60; // weak
_UNKNOWN unk_8FB64; // weak
_UNKNOWN unk_8FB68; // weak
_UNKNOWN unk_8FB6C; // weak
_UNKNOWN unk_8FB70; // weak
_UNKNOWN unk_8FB74; // weak
_UNKNOWN unk_8FB78; // weak
_UNKNOWN unk_8FB7C; // weak
_UNKNOWN unk_8FB80; // weak
void *off_8FB84 = (void *)0x524D3; // weak
void *off_8FBA0 = (void *)0x524D3; // weak
_DWORD dword_8FE74[228] =
{
  0,
  12385,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  676812631,
  1347703880,
  41,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  5242960,
  4294967295,
  0,
  1,
  12641,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3951855340,
  2968235174,
  2760633236,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  6,
  502996475,
  17,
  1462851377,
  2,
  12897,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3953964522,
  3052054691,
  2829314988,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  6,
  608969804,
  4294967295,
  0,
  3,
  13153,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1299081559,
  88,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  6,
  439032363,
  4294967295,
  0,
  4,
  13409,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1852785765,
  7955819,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  6,
  305533494,
  4294967295,
  0,
  5,
  13665,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1394627405,
  1634038388,
  1735289197,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  116328175,
  6,
  116328175
}; // idb
char aGmt0[5] = "gmt0"; // weak
_UNKNOWN country_names; // weak
int stdout; // weak
char byte_91218; // weak
_UNKNOWN unk_91234; // weak
_UNKNOWN unk_91274; // weak
_UNKNOWN unk_912F4; // weak
_UNKNOWN unk_91374; // weak
_UNKNOWN unk_913B4; // weak
_UNKNOWN unk_91434; // weak
int dword_91534; // weak
_UNKNOWN unk_91538; // weak
_UNKNOWN unk_91558; // weak
_UNKNOWN unk_91658; // weak
_UNKNOWN unk_916D8; // weak
_UNKNOWN unk_916F8; // weak
_UNKNOWN unk_91718; // weak
int dword_91758; // weak
_UNKNOWN unk_9175C; // weak
char byte_917DC[128]; // idb
_UNKNOWN unk_9185C; // weak
_UNKNOWN unk_918DC; // weak
int dword_919DC; // weak
int (__fastcall *dword_919E0)(_DWORD); // weak
int (__fastcall *dword_919E4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_919E8; // weak
int dword_919EC; // weak
int dword_919F0; // weak
int dword_919F4; // weak
int dword_919F8; // weak
int (__fastcall *dword_919FC)(_DWORD); // weak


//----- (0000FFE0) --------------------------------------------------------
void init_proc()
{
  ;
}

//----- (00011CB4) --------------------------------------------------------
#error "11CC0: positive sp value has been found (funcsize=3)"

//----- (00011CF0) --------------------------------------------------------
void sub_11CF0()
{
  if ( !byte_91218 )
    byte_91218 = 1;
}
// 11C90: using guessed type int __fastcall _deregister_frame_info(_DWORD);
// 91218: using guessed type char byte_91218;

//----- (00011D34) --------------------------------------------------------
int *sub_11D34()
{
  return &dword_8F008;
}
// 100DC: using guessed type int __fastcall _register_frame_info(_DWORD, _DWORD);
// 8F008: using guessed type int dword_8F008;

//----- (00011D88) --------------------------------------------------------
const char *__fastcall sub_11D88(int a1, int a2, const char *a3)
{
  int v3; // r5@1
  int v4; // r6@1
  const char *v5; // r4@1
  const char *result; // r0@21
  int v7; // [sp+0h] [bp-38h]@10

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !strcmp(a3, "default") )
  {
    defaultconf(0);
  }
  else if ( !strcmp(v5, "lanip_chg") )
  {
    sub_1EB1C(v3);
  }
  else if ( !strcmp(v5, "nat") )
  {
    sub_34F34(v3);
  }
  if ( !strcmp(v5, "current_wireless") )
    sub_134F8(v3);
  if ( !strcmp(v5, "wireless_scan_start") )
  {
    get_value(v3, "ifname", &v7, 32);
    sub_135C8((int)&v7);
  }
  if ( !strcmp(v5, "manual_config_wizard") )
    sub_467A0(v3);
  if ( !strcmp(v5, "manual_wireless_wizard") )
    sub_2E5E8(v3);
  if ( !strcmp(v5, "restore") )
    sub_444C8(v4);
  if ( !strcmp(v5, (const char *)&unk_4FC79) )
    sub_333D0(v3, v4);
  if ( !strcmp(v5, "fw_restore") )
    sub_38810(v3, v4);
  result = (const char *)strcmp(v5, "igmp");
  if ( !result )
    result = sub_47F4C(v3);
  return result;
}
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 116D8: using guessed type int __fastcall defaultconf(_DWORD);

//----- (00011F2C) --------------------------------------------------------
int __fastcall sub_11F2C(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r6@1
  int v4; // r1@3
  int result; // r0@5
  const char *v6; // r0@8
  int v7; // r0@12
  int v8; // [sp+0h] [bp-250h]@19
  char v9; // [sp+100h] [bp-150h]@1
  char dest; // [sp+180h] [bp-D0h]@1
  char v11; // [sp+200h] [bp-50h]@14
  char v12; // [sp+220h] [bp-30h]@14

  v2 = a2;
  v3 = a1;
  strcpy(&dest, "");
  strcpy(&v9, "");
  if ( v2 )
  {
    get_value_post(v2, "tmenu", &dest, 127);
  }
  else
  {
    v4 = get_pvalue(v3, "tmenu");
    if ( v4 )
      sf_strncpy(&dest, v4, 128);
  }
  result = strcmp(&dest, "menu_titlebar");
  if ( result )
  {
    result = strcmp(&dest, "navi_titlebar");
    if ( result )
    {
      if ( !strcmp(&dest, "titlebar") )
      {
        v6 = "/home/httpd/js/toptitle.js";
      }
      else if ( !strcmp(&dest, "navi_menu_basic") || !strcmp(&dest, "navi_menu_advance") )
      {
        v6 = "/home/httpd/js/navimenu.js";
      }
      else
      {
        print_file("/home/httpd/js/navimenu.js");
        print_file("/home/httpd/js/string.js");
        v7 = print_file("/home/httpd/js/common.js");
        if ( dword_919FC )
          dword_919FC(v7);
        get_netaddr("br0", &v12);
        get_localbroadaddr("br0", &v11);
        puts("<script>");
        printf(
          "function CheckIPNetworkObj(ifr,ip)\n"
          "\t\t{\n"
          "\t\t\tfor( i = 1 ; i <= 4 ; i++ )\t\t\t\tif( ifr.document.getElementsByName(ip+i)[0].value == '' )\t\t\t\t\tre"
          "turn 0;\t\t\tip1=Number(ifr.document.getElementsByName(ip+1)[0].value);\t\t\tip2=Number(ifr.document.getElemen"
          "tsByName(ip+2)[0].value);\t\t\tip3=Number(ifr.document.getElementsByName(ip+3)[0].value);\t\t\tip4=Number(ifr."
          "document.getElementsByName(ip+4)[0].value);\t\t\tipstr = ip1+'.'+ip2+'.'+ip3+'.'+ip4;\t\t\tif( ipstr == '%s')\t"
          "\t\t{\t\t\t\treturn ifr.document.getElementsByName(ip+4)[0];\t\t\t}\t\t\tif( ipstr == '%s')\t\t\t{\t\t\t\tretu"
          "rn ifr.document.getElementsByName(ip+4)[0];\t\t\t}\t\t\treturn 0;\t\t}\n"
          "\n",
          &v12,
          &v11);
        printf(
          "function CheckIPNetwork(ip)\n"
          "\t\t{\n"
          "\t\t\tfor( i = 1 ; i <= 4 ; i++ )\t\t\t\tif( document.getElementsByName(ip+i)[0].value == '' )\t\t\t\t\treturn"
          " 0;\t\t\tip1=Number(document.getElementsByName(ip+1)[0].value);\t\t\tip2=Number(document.getElementsByName(ip+"
          "2)[0].value);\t\t\tip3=Number(document.getElementsByName(ip+3)[0].value);\t\t\tip4=Number(document.getElements"
          "ByName(ip+4)[0].value);\t\t\tipstr = ip1+'.'+ip2+'.'+ip3+'.'+ip4;\t\t\tif( ipstr == '%s')\t\t\t{\t\t\t\treturn"
          " document.getElementsByName(ip+4)[0];\t\t\t}\t\t\tif( ipstr == '%s')\t\t\t{\t\t\t\treturn document.getElements"
          "ByName(ip+4)[0];\t\t\t}\t\t\treturn 0;\t\t}\n"
          "\n",
          &v12,
          &v11);
        puts("</script>");
        if ( !strcmp(&dest, "wizard") )
          print_file("/home/httpd/js/netconf.js");
        if ( !strcmp(&dest, "iframe") || !strcmp(&dest, "popup") )
          print_file("/home/httpd/js/wirelessconf.js");
        snprintf((char *)&v8, 0xFFu, "/home/httpd/js/%s.js", &dest);
        if ( !strcmp(&dest, "basicapp") )
          snprintf((char *)&v8, 0xFFu, "/home/httpd/js/nasconf.js");
        v6 = (const char *)&v8;
      }
      result = print_file(v6);
    }
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10958: using guessed type int __fastcall get_netaddr(_DWORD, _DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11264: using guessed type int __fastcall get_localbroadaddr(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 919FC: using guessed type int (__fastcall *dword_919FC)(_DWORD);

//----- (0001218C) --------------------------------------------------------
int __fastcall sub_1218C(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r0@3
  char *v4; // r1@3
  const char *v5; // r0@4
  const char *v6; // r0@8
  int v7; // r0@14
  int v9; // [sp+0h] [bp-2C8h]@13
  char v10; // [sp+80h] [bp-248h]@13
  char dest; // [sp+1C0h] [bp-108h]@11

  v1 = a1;
  v2 = (const char *)get_pvalue(a1, "helpmenu");
  if ( v2 && !strcmp(v2, "1") )
  {
    v3 = "<head><title>%s</title>\n";
    v4 = "도움말";
  }
  else
  {
    v5 = (const char *)get_pvalue(v1, "tmenu");
    if ( v5 && !strcmp(v5, "wizard") )
    {
      v3 = "<head><title>%s</title>\n";
      v4 = "인터넷 연결 마법사";
    }
    else
    {
      v6 = (const char *)get_pvalue(v1, "tmenu");
      if ( v6 && !strcmp(v6, "wirelesswizard") )
      {
        v3 = "<head><title>%s</title>\n";
        v4 = "무선 설정 마법사";
      }
      else
      {
        strcpy(&dest, "");
        get_hostname(&dest);
        if ( !dest )
        {
          get_si("pi", &v9);
          printf("<head><title>%s %s</title>\n", &v10, &v9);
          goto LABEL_14;
        }
        v3 = "<head><title>%s</title>\n";
        v4 = &dest;
      }
    }
  }
  printf(v3, v4);
LABEL_14:
  v7 = printf("<style>");
  dword_919E0(v7);
  printf("</style>");
  return puts("</head>");
}
// 10124: using guessed type int __fastcall get_si(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11B10: using guessed type int __fastcall get_hostname(_DWORD);
// 919E0: using guessed type int (__fastcall *dword_919E0)(_DWORD);

//----- (000122D8) --------------------------------------------------------
int __fastcall sub_122D8(int a1, int a2, const char *a3)
{
  int v3; // r4@1
  const char *v4; // r5@1
  int result; // r0@5

  v3 = a1;
  v4 = a3;
  if ( !strcmp(a3, "selectmac") )
    sub_1903C(v3);
  if ( !strcmp(v4, "searchwireless") )
    sub_2355C(v3);
  result = strcmp(v4, "mcgroup_list");
  if ( !result )
    result = sub_47F74();
  return result;
}

//----- (00012348) --------------------------------------------------------
int __fastcall sub_12348(int a1, const char *a2, const char *a3)
{
  const char *v3; // r4@1
  int v4; // r5@1
  const char *v5; // r6@1
  const char *v6; // r0@1
  int v7; // r6@3
  int v8; // r0@3
  int v9; // r0@5
  int result; // r0@5
  char *v11; // r7@6
  char v12[512]; // [sp+8h] [bp-2D8h]@3
  char s; // [sp+208h] [bp-D8h]@6
  char v14; // [sp+288h] [bp-58h]@3
  char dest; // [sp+2A8h] [bp-38h]@3

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = (const char *)get_pvalue(a1, "saveconfig");
  if ( v6 && !strcmp(v6, "1") )
  {
    strcpy(&dest, "");
    strcpy(&v14, "");
    get_value(v4, "tmenu", &dest, 32);
    get_value(v4, "smenu", &v14, 32);
    v7 = snprintf(v12, 0x200u, "timepro.cgi?tmenu=%s&smenu=%s&savesave=1", &dest, &v14);
    v8 = strcmp(v3, "wirelessconf5g");
    if ( !v8 )
      v8 = snprintf(&v12[v7], 0x200u, "&wl_mode=1");
    print_start_main_table(v8);
    v9 = print_html_apply_wait("모든 설정을 저장합니다. 잠시만 기다려 주십시오.", 2, v12);
    result = print_end_main_table(v9);
  }
  else
  {
    snprintf(&s, 0x80u, "%s_%s", v3, v5);
    v11 = sub_17B4C((char *)v3, v5);
    result = sub_16030();
    if ( !result && v11 )
      result = ((int (__fastcall *)(int))v11)(v4);
  }
  return result;
}
// 10AE4: using guessed type int __fastcall print_html_apply_wait(_DWORD, _DWORD, _DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 12348: using guessed type char var_2D8[512];

//----- (000124A0) --------------------------------------------------------
int __fastcall sub_124A0(int a1, char *a2, const char *a3)
{
  char *v3; // r7@1
  const char *v4; // r6@1
  int v5; // r4@1
  char *v6; // r3@1
  int result; // r0@2
  char s; // [sp+8h] [bp-98h]@1

  v3 = a2;
  v4 = a3;
  v5 = a1;
  snprintf(&s, 0x80u, "%s_%s", a2, a3);
  v6 = sub_17C0C(v3, v4);
  if ( v6 )
  {
    result = ((int (__fastcall *)(_DWORD))v6)(v5);
  }
  else
  {
    result = strcmp(&s, "background_reboot");
    if ( !result )
      result = sub_1979C(v5);
  }
  return result;
}

//----- (0001251C) --------------------------------------------------------
int __fastcall sub_1251C(const char **a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r5@1
  int result; // r0@1

  v2 = (int)a1;
  v3 = a2;
  result = strcmp(*a1, "/ndbin/netdetect.cgi");
  if ( !result )
  {
    result = check_remote_connection();
    if ( !result )
    {
      result = netdetect_get_on_off();
      if ( result )
      {
        if ( !strcmp(v3, "nd-warning") || strcmp(v3, "nd-report") )
          result = sub_41844(v2);
        else
          result = sub_41ADC(v2);
      }
    }
  }
  return result;
}
// 10DC0: using guessed type int netdetect_get_on_off(void);
// 11618: using guessed type int check_remote_connection(void);
// 919DC: using guessed type int dword_919DC;

//----- (000125AC) --------------------------------------------------------
void __fastcall sub_125AC(const char *a1, const char *a2)
{
  const char *v2; // r4@1
  const char *v3; // r5@1

  v2 = a1;
  v3 = a2;
  if ( !strcmp(a2, "lan_pcinfo") )
  {
    sub_1E460(0, (int)v2);
  }
  else if ( !strcmp(v3, "static_lease") )
  {
    sub_1DFE8(0, (int)v2);
  }
  else if ( !strcmp(v3, "macauth_dblist") )
  {
    sub_25814(0, (int)v2);
  }
  else if ( !strcmp(v3, "macauth_pcinfo") )
  {
    sub_255E4(0, (int)v2);
  }
  else if ( !strcmp(v3, "macauth_bsslist") )
  {
    sub_248E8(0);
  }
  else if ( !strcmp(v3, "sysconf_misc") )
  {
    sub_20D14(0, (int)v2);
  }
  else if ( !strcmp(v3, "upnp_sysconf_misc") )
  {
    sub_20B30();
  }
  else if ( !strcmp(v3, "user_portforward") )
  {
    sub_32934(0, v2);
  }
  else if ( !strcmp(v3, "upnp_portforward") )
  {
    sub_32FC4(0, v2);
  }
  else if ( !strcmp(v3, "trigger_portforward") )
  {
    sub_3328C(0);
  }
  else if ( !strcmp(v3, "restore_portforward") )
  {
    sub_327D0(0, (int)v2);
  }
  else if ( !strcmp(v3, "firewall") )
  {
    sub_37AB4(0, v2);
  }
  else if ( !strcmp(v3, "macsearch_firewall") )
  {
    sub_38488();
  }
  else if ( !strcmp(v3, (const char *)&unk_74392) )
  {
    sub_386A0(0, (int)v2);
  }
}

//----- (000127B0) --------------------------------------------------------
void __fastcall sub_127B0(int a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r5@1
  const char *v4; // r0@2

  v2 = a1;
  v3 = a2;
  if ( !strcmp(a2, "hostscan") )
  {
    v4 = (const char *)get_pvalue(v2, "stat");
    sub_2F188(v4);
  }
  if ( !strcmp(v3, "channelscan") )
  {
    sub_14334(v2);
  }
  else if ( !strcmp(v3, "checkssid") )
  {
    sub_2EAF0(v2);
  }
  else if ( !strcmp(v3, "wl_advanced") )
  {
    sub_2648C(v2);
  }
  else if ( !strcmp(v3, "bss_list") )
  {
    sub_2904C(v2);
  }
  else if ( !strcmp(v3, "wl_apply") )
  {
    sub_238E4(v2);
  }
  else if ( !strcmp(v3, "ap_list") )
  {
    sub_27E5C(v2);
  }
  else if ( !strcmp(v3, "ap_list_wds") )
  {
    sub_2C1D0(v2);
  }
  else if ( !strcmp(v3, "nas_service") )
  {
    sub_4A628(v2);
  }
  else if ( !strcmp(v3, "wifi_sched") )
  {
    sub_2B298(v2);
  }
  else if ( !strcmp(v3, "checkssid2") )
  {
    sub_2EAF8(v2);
  }
  else if ( !strcmp(v3, "apscan") )
  {
    sub_13A58(v2);
  }
  else if ( !strcmp(v3, "macauth_pcinfo") )
  {
    sub_255E4(v2, 0);
  }
  else if ( !strcmp(v3, "macauth_dblist") )
  {
    sub_25814(v2, 0);
  }
  else if ( !strcmp(v3, "macauth_bsslist") )
  {
    sub_248E8(v2);
  }
  else if ( !strcmp(v3, "sysconf_misc") )
  {
    sub_20D14(v2, 0);
  }
  else if ( !strcmp(v3, "upnp_sysconf_misc") )
  {
    sub_20B30();
  }
  else if ( !strcmp(v3, "lan_pcinfo") )
  {
    sub_1E460(v2, 0);
  }
  else if ( !strcmp(v3, "static_lease") )
  {
    sub_1DFE8(v2, 0);
  }
  else if ( !strcmp(v3, "user_portforward") )
  {
    sub_32934(v2, 0);
  }
  else if ( !strcmp(v3, "upnp_portforward") )
  {
    sub_32FC4(v2, 0);
  }
  else if ( !strcmp(v3, "trigger_portforward") )
  {
    sub_3328C(v2);
  }
  else if ( !strcmp(v3, "restore_portforward") )
  {
    sub_327D0(v2, 0);
  }
  else if ( !strcmp(v3, "firewall") )
  {
    sub_37AB4(v2, 0);
  }
  else if ( !strcmp(v3, "macsearch_firewall") )
  {
    sub_38488();
  }
  else if ( !strcmp(v3, (const char *)&unk_74392) )
  {
    sub_386A0(v2, 0);
  }
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00012B70) --------------------------------------------------------
int __fastcall sub_12B70(int a1)
{
  int result; // r0@1
  int v2; // r4@1

  result = get_pvalue(a1, "ip");
  v2 = result;
  if ( result )
  {
    puts("<script>");
    printf("RefreshOpener('%s');\n", v2);
    result = printf("</script>");
  }
  return result;
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00012BB4) --------------------------------------------------------
int __fastcall sub_12BB4(int a1, const char **a2)
{
  const char **v2; // r4@1
  int v3; // r0@4
  const char *v4; // r5@4
  const char *v5; // r0@5
  const char *v6; // r0@7
  int v7; // r0@11
  const char *v8; // r5@11
  int v9; // r0@13
  int v10; // r1@13
  char *v11; // r2@13
  const char *v12; // r0@18
  int v13; // r0@20
  int v14; // r0@21
  const char *v15; // r0@22
  int v16; // r0@24
  const char *v17; // r0@49
  void *v18; // r0@56
  void (__fastcall *v19)(void *); // r3@56
  void (__fastcall *v20)(const char **, int, char *, const char *); // r12@66
  const char **v21; // r0@66
  int v22; // r1@66
  char *v23; // r2@66
  const char *v24; // r3@66
  int v25; // r1@69
  int v26; // r2@69
  int v28; // [sp+0h] [bp-B0h]@42
  char s1; // [sp+40h] [bp-70h]@12
  char v30; // [sp+80h] [bp-30h]@51

  v2 = a2;
  if ( istatus_get_intvalue_direct("killhttpd") == 1 || !httpcon_check_session_url() || httpcon_auth() )
  {
    sub_16038((int)&dword_919DC);
    v3 = get_pvalue(v2, "flag");
    v4 = (const char *)v3;
    if ( v3 )
    {
      print_http_header(v3);
      puts("<html>");
      sub_1218C((int)v2);
      sub_1251C(v2, v4);
      v5 = "</html>";
LABEL_25:
      printf(v5);
      return 0;
    }
    if ( strcmp(*v2, "/ndbin/netdetect.cgi") )
    {
      v6 = (const char *)get_pvalue(v2, "page");
      if ( v6 && !strcmp(v6, "url_redirect") )
      {
        print_http_header(0);
        sub_478F4((int)v2);
        return 0;
      }
      if ( !strcmp(*v2, "/cgibin/login-cgi/urlredir.cgi") )
        return 0;
      v7 = post_process();
      v8 = (const char *)v7;
      if ( v7 )
      {
        if ( !get_value_post(v7, "commit", &s1, 64) )
          goto LABEL_18;
        v9 = 0;
        v10 = (int)v8;
        v11 = &s1;
      }
      else
      {
        v11 = (char *)get_pvalue(v2, "commit");
        if ( !v11 )
        {
LABEL_18:
          v12 = (const char *)get_pvalue(v2, "savesave");
          if ( v12 )
          {
            v12 = (const char *)strcmp(v12, "1");
            if ( !v12 )
            {
              v13 = syslog_msg(1, "모든 설정이 저장됨 ");
              v12 = (const char *)saveconf(v13);
            }
          }
          v14 = print_http_header(v12);
          if ( is_factory_test_mode(v14) )
          {
            v15 = (const char *)get_pvalue(v2, "factory_test_mode");
            if ( v15 && !strcmp(v15, "off") )
            {
              v16 = set_ftm_flag();
              defaultconf(v16);
              v5 = "OK";
              goto LABEL_25;
            }
          }
          else if ( get_pvalue(v2, "factory_test_mode") )
          {
            v5 = "NG";
            goto LABEL_25;
          }
          if ( get_value(v2, "tmenu", &s1, 64) && !strcmp(&s1, "iframe_ddns_status") )
          {
            sub_4332C();
            return 0;
          }
          if ( get_value(v2, "tmenu", &s1, 64) && !strcmp(&s1, "iframe_nas_status") )
          {
            sub_4D828((int)v2);
            return 0;
          }
          if ( get_value(v2, "tmenu", &s1, 64) && !strcmp(&s1, "iframe_usb_apply") )
          {
            sub_485C4((int)v2);
            return 0;
          }
          if ( get_value(v2, "tmenu", &s1, 64) && !strcmp(&s1, "iframe_firmware_status") )
          {
            sub_1A564((int)v2);
            return 0;
          }
          puts("<html>");
          sub_11F2C((int)v2, (int)v8);
          sub_1218C((int)v2);
          if ( v8 )
          {
            if ( get_value_post(v8, "tmenu", &s1, 64) && get_value_post(v8, "smenu", &v28, 64) )
            {
              if ( !strcmp(&s1, "iframe") )
                sub_125AC(v8, (const char *)&v28);
              else
                dword_919E4(0, v8, &s1, &v28);
            }
            free((void *)v8);
            goto LABEL_85;
          }
          if ( get_value(v2, "tmenu", &s1, 64) )
          {
            if ( get_value(v2, "smenu", &v28, 64) )
            {
              v17 = (const char *)get_pvalue(v2, "mf_flag");
              if ( v17 )
                v8 = (const char *)(strcmp(v17, "plantynet") == 0);
              if ( !get_value(v2, "helpframe", &v30, 32) || strcmp(&v30, "1") )
              {
                if ( !strcmp(&s1, "iframe") )
                {
                  sub_127B0((int)v2, (const char *)&v28);
LABEL_85:
                  puts("</html>");
                  fflush((FILE *)stdout);
                  return 0;
                }
                if ( !strcmp(&s1, "main_frame") )
                {
                  v18 = (void *)v8;
                  v19 = (void (__fastcall *)(void *))dword_919F8;
LABEL_57:
                  v19(v18);
                  goto LABEL_85;
                }
                if ( !strcmp(&s1, "popup") )
                {
                  sub_122D8((int)v2, (int)&s1, (const char *)&v28);
                  goto LABEL_85;
                }
                if ( !strcmp(&s1, "background") )
                {
                  if ( !strcmp((const char *)&v28, "reboot") )
                    sub_19220((int)v2);
                  goto LABEL_85;
                }
                if ( !strcmp(&s1, "menu_titlebar") )
                {
                  v19 = (void (__fastcall *)(void *))dword_919EC;
LABEL_65:
                  v18 = v2;
                  goto LABEL_57;
                }
                v20 = (void (__fastcall *)(const char **, int, char *, const char *))dword_919E4;
                v21 = v2;
                v22 = 0;
                v23 = &s1;
                v24 = (const char *)&v28;
LABEL_84:
                v20(v21, v22, v23, v24);
                goto LABEL_85;
              }
            }
            else
            {
              if ( !strcmp(&s1, "navi_menu_basic") )
              {
                sub_17CCC((int)v2);
                goto LABEL_85;
              }
              if ( !strcmp(&s1, "navi_menu_advance") )
              {
                sub_17F88((int)v2, v25, v26);
                goto LABEL_85;
              }
              if ( !strcmp(&s1, "titlebar") )
              {
                v19 = (void (__fastcall *)(void *))dword_919F4;
                goto LABEL_65;
              }
              if ( strcmp(&s1, "main_body") )
              {
                if ( strcmp(&s1, "navi_titlebar") )
                {
                  if ( !strcmp(&s1, "RefreshOpener") )
                  {
                    sub_12B70((int)v2);
                  }
                  else if ( !strcmp(&s1, "wizard") )
                  {
                    sub_46BC4((int)v2);
                  }
                  else if ( !strcmp(&s1, "wirelesswizard") )
                  {
                    sub_2E89C((int)v2);
                  }
                  goto LABEL_85;
                }
                v19 = (void (__fastcall *)(void *))dword_919F0;
                goto LABEL_65;
              }
            }
            v19 = (void (__fastcall *)(void *))dword_919E8;
            goto LABEL_65;
          }
          v21 = v2;
          v23 = "main_frame";
          v22 = 0;
          v20 = (void (__fastcall *)(const char **, int, char *, const char *))dword_919E4;
          v24 = "main_frame";
          goto LABEL_84;
        }
        v9 = (int)v2;
        v10 = (int)v8;
      }
      sub_11D88(v9, v10, v11);
      goto LABEL_18;
    }
  }
  return 0;
}
// 101C0: using guessed type int __fastcall print_http_header(_DWORD);
// 106AC: using guessed type int httpcon_check_session_url(void);
// 10A60: using guessed type int set_ftm_flag(void);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10DF0: using guessed type int post_process(void);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11024: using guessed type int httpcon_auth(void);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 1139C: using guessed type int __fastcall is_factory_test_mode(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 116D8: using guessed type int __fastcall defaultconf(_DWORD);
// 91214: using guessed type int stdout;
// 919DC: using guessed type int dword_919DC;
// 919E4: using guessed type int (__fastcall *dword_919E4)(_DWORD, _DWORD, _DWORD, _DWORD);
// 919E8: using guessed type int dword_919E8;
// 919EC: using guessed type int dword_919EC;
// 919F0: using guessed type int dword_919F0;
// 919F4: using guessed type int dword_919F4;
// 919F8: using guessed type int dword_919F8;

//----- (000132A4) --------------------------------------------------------
int __fastcall sub_132A4(int a1, int a2)
{
  int v2; // r6@1
  int v4; // [sp+0h] [bp-410h]@1
  char v5; // [sp+200h] [bp-210h]@1

  v2 = a2;
  sf_strncpy(&v5, a1, 512);
  sf_strncpy(&v4, v2, 512);
  strtoupper(&v5);
  strtoupper(&v4);
  return strcmp(&v5, (const char *)&v4);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);

//----- (00013300) --------------------------------------------------------
void *__fastcall sub_13300(int a1)
{
  char *v1; // r0@2
  const char *v2; // r1@2

  switch ( a1 )
  {
    case 1:
      v1 = (char *)&unk_91234;
      v2 = "개방 모드";
      break;
    case 2:
      v1 = (char *)&unk_91234;
      v2 = "공유 모드";
      break;
    case 3:
      v1 = (char *)&unk_91234;
      v2 = "자동인증";
      break;
    case 4:
      v1 = (char *)&unk_91234;
      v2 = "802.1x(기업용) - WPA";
      break;
    case 5:
      v1 = (char *)&unk_91234;
      v2 = "WPAPSK";
      break;
    default:
      v1 = (char *)&unk_91234;
      v2 = "UNKNOWN";
      break;
    case 8:
      v1 = (char *)&unk_91234;
      v2 = "802.1x(기업용) - WPA2";
      break;
    case 9:
      v1 = (char *)&unk_91234;
      v2 = "WPA2PSK";
      break;
    case 10:
      v1 = (char *)&unk_91234;
      v2 = (const char *)&unk_50630;
      break;
    case 11:
      v1 = (char *)&unk_91234;
      v2 = "802.1x(기업용) - WPA/WPA2";
      break;
  }
  strcpy(v1, v2);
  return &unk_91234;
}

//----- (000133EC) --------------------------------------------------------
void *__fastcall sub_133EC(int a1)
{
  char *v1; // r0@2
  const char *v2; // r1@2

  switch ( a1 )
  {
    case 0:
      v1 = (char *)&unk_91274;
      v2 = "암호화 사용안함";
      break;
    case 1:
      v1 = (char *)&unk_91274;
      v2 = "WEP";
      break;
    case 2:
      v1 = (char *)&unk_91274;
      v2 = "WEP-128BIT";
      break;
    case 3:
      v1 = (char *)&unk_91274;
      v2 = "TKIP";
      break;
    case 4:
      v1 = (char *)&unk_91274;
      v2 = "AES(CCMP)";
      break;
    case 5:
      v1 = (char *)&unk_91274;
      v2 = "TKIP/AES";
      break;
    default:
      v1 = (char *)&unk_91274;
      v2 = "UNKNOWN";
      break;
  }
  strcpy(v1, v2);
  return &unk_91274;
}

//----- (000134F8) --------------------------------------------------------
int __fastcall sub_134F8(int a1)
{
  int *v1; // r0@5
  char *v2; // r1@5
  int v4; // [sp+0h] [bp-5A0h]@5
  char s1; // [sp+570h] [bp-30h]@1

  if ( !get_value(a1, "ifname", &s1, 32) )
    strcpy(&s1, "eth2");
  if ( strcmp(&s1, "noapply") )
  {
    if ( !strcmp(&s1, "both") )
    {
      read_wireless_conf(&v4, "eth2");
      set_wireless_conf(&v4, "eth2");
      read_wireless_conf(&v4, "eth1");
      v1 = &v4;
      v2 = "eth1";
    }
    else
    {
      read_wireless_conf(&v4, &s1);
      v1 = &v4;
      v2 = &s1;
    }
    set_wireless_conf(v1, v2);
  }
  return 0;
}
// 1037C: using guessed type int __fastcall set_wireless_conf(_DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000135C8) --------------------------------------------------------
int __fastcall sub_135C8(int a1)
{
  int v1; // r4@1

  v1 = a1;
  ifup(a1);
  return wireless_api_start_ap_scan(v1);
}
// 10214: using guessed type int __fastcall wireless_api_start_ap_scan(_DWORD);
// 102E0: using guessed type int __fastcall ifup(_DWORD);

//----- (000135E0) --------------------------------------------------------
int __fastcall sub_135E0(_DWORD *a1, const char *a2)
{
  const char *v2; // r7@1
  _DWORD *v3; // r6@1
  _DWORD *v4; // r5@1
  void *v5; // r0@1
  int v6; // r0@1
  int v7; // r4@1
  const char *v8; // r0@3
  void *v9; // r0@8
  const char *v10; // r3@8
  int v11; // r0@10
  int v12; // r10@10
  int v13; // r9@10
  int v14; // r11@11
  int v15; // r1@11
  const char *v16; // r0@11
  int v17; // r0@15
  const char *v18; // r0@16
  void *v19; // r0@17
  int v20; // r3@17
  int v21; // r1@25
  int v22; // r2@25
  int v23; // r0@25
  int v25; // [sp+14h] [bp-5D4h]@11
  char v26; // [sp+18h] [bp-5D0h]@1
  int v27; // [sp+588h] [bp-60h]@1
  int v28; // [sp+5A8h] [bp-40h]@8
  int v29; // [sp+5BCh] [bp-2Ch]@1

  v2 = a2;
  v3 = a1;
  get_active_wl(0, &v27, &v29);
  v4 = v3;
  v5 = memset(&v26, 0, 0x570u);
  v6 = get_wireless_ifname(v5);
  read_wireless_conf(&v26, v6);
  strcmp(v2, "wizard");
  printf("<table width=%d class=wizard_content_table>");
  printf("<input type=hidden name=apidx value=%d>\n", 0);
  v7 = 0;
  while ( v7 < *v3 )
  {
    printf("<input type=hidden name=ssid value='%s'>\n", &v3[53 * v7 + 12]);
    printf("<input type=hidden name=bssid value='%s'>\n", &v3[53 * v7 + 44]);
    printf("<input type=hidden name=encrypt_type value='%d'>\n", v4[63]);
    printf("<input type=hidden name=auth_type value='%d'>\n", v4[64]);
    printf(
      "<tr id=scan_tr_%d class=%s onclick=\"OnClickAPScan(%d,document.aplist_fm.apidx,%d)\" onSelectStart=\"return false;"
      "\" onDrag=\"return false;\" ",
      v7,
      "big_td",
      v7,
      0);
    if ( !strcmp(v2, "wizard") )
    {
      v8 = "ondblclick=\"OnDBLClickAPScan(%d)\"";
LABEL_7:
      printf(v8, v7);
      goto LABEL_8;
    }
    if ( !strcmp(v2, "wds") || !strcmp(v2, "mbridge") )
    {
      v8 = "ondblclick=\"OnDBLClickAPScanNoWizard(%d)\"";
      goto LABEL_7;
    }
LABEL_8:
    putchar(62);
    printf("<td class=big_td valign=center>");
    v9 = sub_160D0();
    printf("<img src='%s'>", v9);
    printf("</td><td class=big_td valign=top>");
    sf_strncpy(&v28, &v3[53 * v7 + 44], 20);
    convert_mac(&v28);
    printf("<a name=\"search_ap_%d\">", v7);
    v10 = "공개되지않은 무선 네트워크";
    if ( *((_BYTE *)v4 + 48) )
      v10 = (const char *)&v3[53 * v7 + 12];
    printf("<span id=scan_text_2_%d><b>%s</b></span>", v7, v10);
    v11 = printf("</a>");
    br(v11);
    printf("<span id=scan_text_0_%d class=%s> ", v7, "gray_text");
    v12 = v4[54];
    v13 = v4[55];
    if ( v12 == v13 )
    {
      printf("(%s %d - %s)", "채널", v4[54], &v28);
    }
    else
    {
      v14 = v4[56];
      v25 = sub_4EC48(v4[56], 1000);
      sub_4ED24(v14, 0x3E8u);
      v16 = "상위";
      if ( v13 > v12 )
        v16 = "하위";
      printf("(%s %d [ %d.%d GHz,%s,40MHz ] - %s)", "채널", v12, v25, v15, v16, &v28);
    }
    v17 = printf("<input type=hidden name=channel value=%d.%d>", v4[54], v4[55]);
    br(v17);
    if ( !v4[63] )
    {
      v18 = "보안 사용하지 않음";
LABEL_21:
      printf(v18);
      goto LABEL_25;
    }
    v19 = sub_160D0();
    printf("<img src=\"%s\" border=0> ", v19);
    printf("보안 사용");
    print_nbsp(1);
    v20 = v4[63];
    if ( (unsigned int)(v20 - 3) <= 2 )
    {
      if ( v4[64] == 9 )
        v18 = "(WPA2)";
      else
        v18 = "(WPA)";
      goto LABEL_21;
    }
    if ( (unsigned int)(v20 - 1) <= 1 )
    {
      v18 = "(WEP)";
      goto LABEL_21;
    }
    printf("(%s)", "Unknown");
LABEL_25:
    puts("</span>");
    printf("</td>");
    printf("<td valign=top align=right class=big_td>");
    v21 = v7++;
    printf("<span id=scan_text_1_%d class=%s> ", v21, "gray_text");
    v22 = v4[59];
    v4 += 53;
    printf("%s - %d%%", "신호세기", v22);
    printf("</span>");
    v23 = printf("</td>");
    etr(v23);
  }
  printf("</table>");
  printf("<script>");
  printf("document.location.href='#search_ap_%d';", 0);
  printf("</script>");
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10CB8: using guessed type int __fastcall get_wireless_ifname(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);

//----- (00013A0C) --------------------------------------------------------
int __fastcall sub_13A0C(int a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r5@1

  v2 = a1;
  v3 = a2;
  puts("<form method=get action=timepro.cgi name=aplist_fm>");
  qsort((void *)(v2 + 48), *(_DWORD *)v2, 0xD4u, (__compar_fn_t)sub_132A4);
  sub_135E0((_DWORD *)v2, v3);
  return printf("</form>");
}

//----- (00013A58) --------------------------------------------------------
int __fastcall sub_13A58(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@7
  int v3; // r0@11
  int v4; // r0@12
  void *v5; // r4@16
  const char *v6; // r0@17
  char v8; // [sp+Ch] [bp-8Ch]@1
  char v9; // [sp+2Ch] [bp-6Ch]@5
  char dest; // [sp+4Ch] [bp-4Ch]@5
  char v11; // [sp+6Ch] [bp-2Ch]@3
  int v12; // [sp+7Ch] [bp-1Ch]@1

  v1 = a1;
  v12 = 0;
  puts("<body class=scan_body>");
  if ( !get_value(v1, "country", &v8, 32) )
    strcpy(&v8, "KR");
  if ( !get_value(v1, "scan_type", &v11, 16) )
    strcpy(&v11, "normal");
  strcpy(&dest, "");
  get_value(v1, "stage", &dest, 32);
  get_value(v1, "ifname", &v9, 32);
  puts("<form method=get action=timepro.cgi name=scan_fm>");
  puts("<input type=hidden name=tmenu value=iframe>");
  puts("<input type=hidden name=smenu value=apscan>");
  printf("<input type=hidden name=country value=%s>\n", &v8);
  puts("<input type=hidden name=stage value=start>");
  printf("<input type=hidden name=scan_type value=%s>\n", &v11);
  printf("<input type=hidden name=ifname value=%s>\n", &v9);
  get_intvalue(v1, "connect", &v12);
  puts("<input type=hidden name=connect value=0>");
  printf("</form>");
  if ( strcmp(&dest, "start") )
  {
    if ( strcmp(&dest, "end") )
      goto LABEL_22;
    v5 = malloc(0x3530u);
    memset(v5, 0, 0x3530u);
    sf_strncpy((char *)v5 + 8, &v9, 32);
    sf_strncpy((char *)v5 + 40, &v8, 8);
    wireless_api_get_ap_list(v5);
    wireless_api_stop_ap_scan(&v9);
    sub_13A0C((int)v5, &v11);
    printf("<script>");
    if ( !strcmp(&v11, "wizard") )
    {
      printf("EnableObj(parent.document.wizard.prev_bt);");
      v6 = "EnableObj(parent.document.wizard.next_bt);";
    }
    else
    {
      if ( strcmp(&v11, "wds") )
      {
LABEL_21:
        printf("EnableObj(parent.document.wizard.search_bt);");
        printf("</script>");
        free(v5);
        goto LABEL_22;
      }
      v6 = "EnableObj(parent.document.wizard.select_bt);";
    }
    printf(v6);
    goto LABEL_21;
  }
  printf("<script>");
  printf("DisableObj(parent.document.wizard.search_bt);");
  if ( !strcmp(&v11, "wizard") )
  {
    printf("DisableObj(parent.document.wizard.next_bt);");
    v2 = "DisableObj(parent.document.wizard.prev_bt);";
  }
  else
  {
    if ( strcmp(&v11, "wds") )
      goto LABEL_11;
    v2 = "DisableObj(parent.document.wizard.select_bt);";
  }
  printf(v2);
LABEL_11:
  v3 = printf("</script>");
  if ( v12 )
  {
    if ( v12 == 1 )
    {
      br(v3);
      print_nbsp(5);
      printf((const char *)&unk_50E6D);
      printf(
        "<meta http-equiv=refresh content=\"2; URL=timepro.cgi?tmenu=iframe&smenu=apscan&stage=start&connect=0&commit=cur"
        "rent_wireless&country=%s&scan_type=%s&ifname=%s\">",
        &v8,
        &v11,
        &v9);
    }
  }
  else
  {
    br(v3);
    print_nbsp(5);
    v4 = printf("주변의 무선 네트워크를 검색중입니다.");
    br(v4);
    print_nbsp(5);
    printf("잠시만 기다리십시오.");
    sub_135C8((int)&v9);
    printf(
      "<meta http-equiv=refresh content=\"%d; URL=timepro.cgi?tmenu=iframe&smenu=apscan&stage=end&country=%s&scan_type=%s&ifname=%s\">",
      10,
      &v8,
      &v11,
      &v9);
  }
LABEL_22:
  printf("</form>");
  return printf("</body>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 104C0: using guessed type int __fastcall wireless_api_get_ap_list(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11420: using guessed type int __fastcall wireless_api_stop_ap_scan(_DWORD);

//----- (00013DE8) --------------------------------------------------------
int __fastcall sub_13DE8(_DWORD *a1, _DWORD *a2, char *a3, int a4)
{
  int v4; // r7@1
  _DWORD *v5; // r5@1
  _DWORD *v6; // r4@1
  char *v7; // r6@1
  _DWORD *v8; // r10@1
  int v9; // r8@1
  size_t v10; // r11@1
  size_t v11; // ST04_4@3

  v4 = 0;
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a2;
  v9 = 0;
  v10 = a4 - 10;
  while ( v9 < *v6 )
  {
    if ( v8[54] == *v5 )
    {
      v11 = strlen((const char *)&v6[53 * v9 + 12]);
      if ( strlen(v7) + v11 < v10 )
      {
        strcat(v7, (const char *)&v6[53 * v9 + 12]);
        strcat(v7, ",");
      }
      ++v4;
    }
    ++v9;
    v8 += 53;
  }
  if ( *v7 )
    v7[strlen(v7) - 1] = 0;
  return v4;
}

//----- (00013EB0) --------------------------------------------------------
int __fastcall sub_13EB0(int a1, int a2, int a3)
{
  _DWORD *v3; // r8@1
  int v4; // r6@1
  int v5; // r10@1
  int v6; // r5@1
  int *v7; // r4@1
  int v8; // r6@1
  char *v9; // r5@1
  const char *v10; // r2@3
  const char *v11; // r12@4
  void *v12; // r0@10
  int v13; // r0@10
  int v14; // r7@10
  const char *v15; // r2@12
  int v16; // r11@13
  char *v17; // r12@14
  int v18; // r0@16
  const char *v19; // r2@27
  int v20; // r0@28
  int v21; // r1@28
  int v22; // r2@28
  char *v23; // r4@30
  const char *v24; // r0@31
  char *v26; // [sp+8h] [bp-D40h]@0
  int v27; // [sp+18h] [bp-D30h]@1
  int v28; // [sp+1Ch] [bp-D2Ch]@1
  char v29; // [sp+20h] [bp-D28h]@10
  char v30[1280]; // [sp+820h] [bp-528h]@1
  char v31[1280]; // [sp+828h] [bp-520h]@1
  char v32; // [sp+D20h] [bp-28h]@1

  v3 = (_DWORD *)a1;
  v4 = a2;
  v5 = a3;
  v6 = a1 + 8;
  qsort((void *)(a1 + 48), *(_DWORD *)a1, 0xD4u, (__compar_fn_t)sub_13284);
  v27 = wireless_get_channel_list(v6, v3 + 10, v4, v30);
  v28 = wireless_api_get_best_channel(v30, v27, v3);
  v7 = (int *)v31;
  puts("<form method=get action=timepro.cgi name=channellist_fm>");
  v8 = 0;
  v9 = &v32 + 20 * v28;
  printf("<input type=hidden name=channel value=%d.%d>\n", *((_DWORD *)v9 - 320), *((_DWORD *)v9 - 319));
  printf("<table width=%d class=wizard_content_table>");
  while ( v8 < v27 )
  {
    if ( *(v7 - 2) == *((_DWORD *)v9 - 320) )
    {
      v11 = "big_selected_td";
      if ( *(v7 - 1) != *((_DWORD *)v9 - 319) )
        v11 = "big_td";
      v10 = v11;
    }
    else
    {
      v10 = "big_td";
    }
    printf(
      "<tr id=scan_tr_%d class=%s onclick=\"OnClickChannelScan(%d,'%d.%d')\" onSelectStart=\"return false;\" onDrag=\"return false;\"",
      v8,
      v10,
      v8,
      *((_DWORD *)v9 - 320),
      *((_DWORD *)v9 - 319),
      v26);
    if ( v5 )
      putchar(62);
    else
      printf(" ondblclick=\"OnDBLClickChannelScanNoWizard('%d.%d');\">", *(v7 - 2), *(v7 - 1));
    printf("<td class=big_td valign=center>");
    v12 = sub_160D0();
    printf("<img src='%s' border=0>", v12);
    printf("</td>");
    printf("<td width=100%% class=big_td valign=top>");
    strcpy(&v29, "");
    v13 = sub_13DE8(&v30[20 * v8], v3, &v29, 2048);
    v14 = v13;
    if ( *(v7 - 2) != *((_DWORD *)v9 - 320) || *(v7 - 1) != *((_DWORD *)v9 - 319) )
    {
      v15 = "gray_text";
      if ( !v13 )
        v15 = "item_text";
    }
    else
    {
      v15 = "white_text";
    }
    printf("<span id=scan_text_0_%d class=%s> ", v8, v15);
    printf("<a name=\"channel_%d.%d\"> ", *(v7 - 2), *(v7 - 1));
    v16 = *v7;
    sub_4EC48(*v7, 1000);
    sub_4ED24(v16, 0x3E8u);
    if ( *(v7 - 2) == *(v7 - 1) )
      v17 = "";
    else
      v17 = "40 MHz";
    v26 = v17;
    printf("<b>%s %d </b>&nbsp;( %d.%d GHz,%s,%s ) &nbsp;&nbsp;", "채널");
    v18 = printf("</a>");
    if ( *(v7 - 2) == *((_DWORD *)v9 - 320) && *(v7 - 1) == *((_DWORD *)v9 - 319) )
    {
      printf("최적의 채널로 검색됨");
      v18 = print_nbsp(2);
    }
    if ( v14 )
    {
      v18 = printf("(%d개의 AP가 사용중)", v14);
    }
    else if ( *(v7 - 2) != *((_DWORD *)v9 - 320) || *(v7 - 1) != *((_DWORD *)v9 - 319) )
    {
      v18 = printf("(사용가능함)");
    }
    br(v18);
    collapse(&v29, 50);
    if ( v14 )
      printf("&nbsp;사용중인 무선AP: %s", &v29);
    if ( *(v7 - 2) != *((_DWORD *)v9 - 320) || *(v7 - 1) != *((_DWORD *)v9 - 319) )
    {
      v19 = "gray_text";
      if ( !v14 )
        v19 = "item_text";
    }
    else
    {
      v19 = "white_text";
    }
    printf("<span id=scan_text_1_%d class=%s> ", v8++, v19);
    printf("</span>");
    v20 = printf("</td>");
    etr(v20);
    printf("<input type=hidden name=apnum value=%d>", v14);
    v21 = *(v7 - 2);
    v22 = *(v7 - 1);
    v7 += 5;
    printf("<input type=hidden name=channelnum value=%d.%d>", v21, v22);
  }
  printf("</table>");
  printf("<script>");
  v23 = &v32 + 20 * v28;
  printf("document.location.href='#channel_%d.%d';", *((_DWORD *)v23 - 320), *((_DWORD *)v23 - 319));
  printf("</script>");
  printf("</form>");
  printf("<script>");
  printf("EnableObj(parent.document.wizard.search_bt);");
  if ( v5 )
  {
    printf("EnableObj(parent.document.wizard.next_bt);");
    v24 = "EnableObj(parent.document.wizard.prev_bt);";
  }
  else
  {
    printf(
      "parent.document.wizard.best_ch.value = MSG_BEST_CHANNEL_PRE + '%d' + MSG_BEST_CHANNEL_POST;",
      *((_DWORD *)v23 - 320));
    v24 = "EnableObj(parent.document.wizard.select_bt);";
  }
  printf(v24);
  return printf("</script>");
}
// 1070C: using guessed type int __fastcall wireless_api_get_best_channel(_DWORD, _DWORD, _DWORD);
// 10B20: using guessed type int __fastcall wireless_get_channel_list(_DWORD, _DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11690: using guessed type int __fastcall collapse(_DWORD, _DWORD);
// 13284: using guessed type int sub_13284();
// 13EB0: using guessed type char var_528[1280];

//----- (00014334) --------------------------------------------------------
int __fastcall sub_14334(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@7
  int v3; // r0@9
  int v4; // r0@9
  void *v5; // r4@11
  char v7; // [sp+8h] [bp-68h]@5
  char v8; // [sp+28h] [bp-48h]@5
  char v9; // [sp+48h] [bp-28h]@1
  int v10; // [sp+50h] [bp-20h]@5
  int v11; // [sp+54h] [bp-1Ch]@3

  v1 = a1;
  puts("<body class=scan_body>");
  if ( !get_value(v1, "country", &v9, 8) )
    strcpy(&v9, "KR");
  if ( !get_intvalue(v1, "wizard", &v11) )
    v11 = 0;
  get_value(v1, "ifname", &v7, 32);
  get_intvalue(v1, "bw", &v10);
  strcpy(&v8, "");
  get_value(v1, "stage", &v8, 32);
  puts("<form method=get action=timepro.cgi name=scan_fm>");
  puts("<input type=hidden name=tmenu value=iframe>");
  puts("<input type=hidden name=smenu value=channelscan>");
  printf("<input type=hidden name=country value=%s>\n", &v9);
  printf("<input type=hidden name=bw value=%d>\n", v10);
  puts("<input type=hidden name=stage value=start>");
  printf("<input type=hidden name=wizard value=%d>\n", v11);
  printf("<input type=hidden name=ifname value=%s>\n", &v7);
  printf("</form>");
  if ( !strcmp(&v8, "start") )
  {
    printf("<script>");
    printf("DisableObj(parent.document.wizard.search_bt);");
    if ( v11 )
    {
      printf("DisableObj(parent.document.wizard.next_bt);");
      v2 = "DisableObj(parent.document.wizard.prev_bt);";
    }
    else
    {
      printf("parent.document.wizard.best_ch.value = '';");
      v2 = "DisableObj(parent.document.wizard.select_bt);";
    }
    printf(v2);
    v3 = printf("</script>");
    br(v3);
    print_nbsp(5);
    v4 = printf("주변의 무선 네트워크를 검색중입니다.");
    br(v4);
    print_nbsp(5);
    printf("잠시만 기다리십시오.");
    wireless_api_start_ap_scan(&v7);
    printf(
      "<meta http-equiv=refresh content=\"%d; URL=timepro.cgi?tmenu=iframe&smenu=channelscan&stage=end&country=%s&wizard="
      "%d&ifname=%s&bw=%d\">",
      10,
      &v9,
      v11,
      &v7,
      v10);
  }
  else if ( !strcmp(&v8, "end") )
  {
    v5 = malloc(0x3530u);
    memset(v5, 0, 0x3530u);
    sf_strncpy((char *)v5 + 8, &v7, 32);
    sf_strncpy((char *)v5 + 40, &v9, 8);
    wireless_api_get_ap_list(v5);
    wireless_api_stop_ap_scan(&v7);
    sub_13EB0((int)v5, v10, v11);
    free(v5);
  }
  return printf("</body>");
}
// 10214: using guessed type int __fastcall wireless_api_start_ap_scan(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 104C0: using guessed type int __fastcall wireless_api_get_ap_list(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11420: using guessed type int __fastcall wireless_api_stop_ap_scan(_DWORD);

//----- (000145E0) --------------------------------------------------------
int __fastcall sub_145E0(int a1, int a2, const char *a3)
{
  const char *v3; // r6@1
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r0@3

  v3 = a3;
  v4 = a2;
  v5 = a1;
  str(a1);
  puts("<td height=40px class=wizardtop_td valign=top>");
  strcmp(v3, "eth1");
  printf("<b>%s</b> - %s %s <br>", v5);
  if ( v4 )
    printf("%s<br>", v4);
  v6 = printf("</td>");
  return etr(v6);
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);

//----- (0001466C) --------------------------------------------------------
int __fastcall sub_1466C(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  int v4; // r0@1
  int v5; // r0@2
  int v6; // r0@4

  v2 = a2;
  v3 = a1;
  str(a1);
  puts("<td height=40px class=wizardtop_td valign=top>");
  v4 = printf("<b>%s</b><br>", v3);
  if ( v2 )
    v5 = printf("%s<br>", v2);
  else
    v5 = br(v4);
  br(v5);
  v6 = printf("</td>");
  return etr(v6);
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (000146D0) --------------------------------------------------------
int __fastcall sub_146D0(int a1)
{
  int v1; // r0@1
  int v3; // [sp+0h] [bp-28h]@1

  v1 = get_value(a1, "wizardsave", &v3, 32);
  if ( v1 )
    saveconf(v1);
  printf("<script>");
  printf("document.location.href='timepro.cgi?tmenu=wirelesswizard&step=2&ifname=%s';", "eth1");
  return printf("</script>");
}
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001472C) --------------------------------------------------------
int __fastcall sub_1472C(int a1)
{
  int v1; // r0@1
  int v3; // [sp+0h] [bp-28h]@1

  v1 = get_value(a1, "wizardsave", &v3, 32);
  if ( v1 )
    saveconf(v1);
  printf("<script>");
  printf("self.close();");
  printf("parent.opener.focus();");
  return printf("</script>");
}
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001478C) --------------------------------------------------------
int __fastcall sub_1478C(int a1)
{
  int v1; // r0@1
  int v3; // [sp+0h] [bp-28h]@1

  v1 = get_value(a1, "wizardsave", &v3, 32);
  if ( v1 )
    saveconf(v1);
  printf("<script>");
  printf("self.close();");
  printf("parent.opener.focus();");
  return printf("</script>");
}
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000147EC) --------------------------------------------------------
int __fastcall sub_147EC(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  bool v3; // zf@1
  const char *v4; // r3@1
  int v5; // r0@6
  int result; // r0@6
  char s; // [sp+8h] [bp-180h]@3
  char dest; // [sp+108h] [bp-80h]@1
  int v9; // [sp+188h] [bp+0h]@1
  char v10; // [sp+1C8h] [bp+40h]@1
  char s1; // [sp+208h] [bp+80h]@1

  v1 = a1;
  strcpy(&dest, "");
  get_value(v1, "tmenu", &v10, 64);
  get_value(v1, "nextstep", &v9, 64);
  get_value(v1, "ifname", &s1, 32);
  v2 = sub_1466C((int)"설정 저장 및 마법사 종료", 0);
  str(v2);
  puts("<td height=260px class=wizardbody_td>");
  v3 = strcmp(&s1, "eth1") == 0;
  v4 = "both";
  if ( !v3 )
    v4 = "noapply";
  snprintf(&s, 0x100u, "timepro.cgi?tmenu=%s&step=%s&savesave=1&ifname=%s", &v10, &v9, v4);
  if ( get_value(v1, "commit", &dest, 128) && !strcmp(&dest, "manual_wireless_wizard") )
    strcat(&s, (const char *)&unk_515B9);
  print_html_apply_wait(
    "설정 적용 후 모든 설정을 저장합니다.<br>잠시 후 자동으로 마법사가 종료됩니다.",
    3,
    &s);
  v5 = printf("</td>");
  etr(v5);
  result = strcmp(&s1, "eth1");
  if ( !result )
  {
    puts("<script>");
    printf("setTimeout(\"self.close();\",7000);");
    result = puts("</script>");
  }
  return result;
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10AE4: using guessed type int __fastcall print_html_apply_wait(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001497C) --------------------------------------------------------
const char *__fastcall sub_1497C(char *s1)
{
  char *v1; // r7@1
  int v2; // r4@1
  int v3; // r5@3
  char *v4; // r3@3

  v1 = s1;
  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)((char *)&country_names + v2);
    v4 = (char *)&country_names + v2;
    if ( !v3 )
      break;
    v2 += 16;
    if ( !strcmp(v1, *((const char **)v4 + 1)) )
      return (const char *)v3;
  }
  return "Unknown";
}

//----- (000149CC) --------------------------------------------------------
int __fastcall sub_149CC(int result)
{
  const char *v1; // r7@1
  int v2; // r4@1
  const char *v3; // r10@2
  char *v4; // r2@3
  int v5; // r1@6
  int v6; // [sp+0h] [bp-A0h]@2

  v1 = (const char *)result;
  v2 = 0;
  while ( 1 )
  {
    v5 = *(_DWORD *)((char *)&country_names + v2);
    if ( !v5 )
      break;
    sf_strncpy(&v6, v5, 128);
    v3 = *(const char **)((char *)&country_names + v2 + 4);
    v2 += 16;
    if ( !strcmp(v1, v3) )
      v4 = "selected";
    else
      v4 = "";
    result = printf("<option value=%s %s> %s </option>", v3, v4, &v6);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (00014A54) --------------------------------------------------------
void *__fastcall sub_14A54(int a1)
{
  int v1; // r6@1
  const char *v2; // r4@1
  const char *v3; // r7@1
  int v4; // r5@1
  int v5; // ST04_4@2
  int v6; // r1@2
  int v7; // r6@3
  int v8; // r1@3
  bool v9; // zf@3
  bool v10; // nf@3
  unsigned __int8 v11; // vf@3

  v1 = a1;
  v2 = *(const char **)a1;
  v3 = *(const char **)(a1 + 4);
  v4 = *(_DWORD *)(a1 + 8);
  if ( *(const char **)a1 == v3 )
  {
    v5 = sub_4EC48(*(_DWORD *)(a1 + 8), 1000);
    sub_4ED24(v4, 0x3E8u);
    snprintf(
      (char *)&unk_912F4,
      0x80u,
      "<b>%s %d </b> &nbsp;( %d.%d GHz,%d MHz )",
      "채널",
      v2,
      v5,
      v6,
      *(_DWORD *)(v1 + 16));
  }
  else
  {
    v7 = sub_4EC48(*(_DWORD *)(a1 + 8), 1000);
    sub_4ED24(v4, 0x3E8u);
    v11 = __OFSUB__(v2, v3);
    v9 = v2 == v3;
    v10 = v2 - v3 < 0;
    if ( (signed int)v2 > (signed int)v3 )
      v3 = "상위";
    if ( (unsigned __int8)(v10 ^ v11) | v9 )
      v3 = "하위";
    snprintf((char *)&unk_912F4, 0x80u, "<b>%s %d </b> &nbsp;( %d.%d GHz,%s,%d MHz )", "채널", v2, v7, v8, v3, 40);
  }
  return &unk_912F4;
}

//----- (00014B34) --------------------------------------------------------
int __fastcall sub_14B34(const char *a1)
{
  signed int v1; // r4@1
  signed int v2; // r0@2
  int i; // r5@6
  int v4; // r8@8
  int v5; // r9@9
  int v6; // r10@9
  int v7; // r10@14
  int v8; // r1@14
  int v9; // r6@14
  char *v10; // r6@21
  signed int v12; // [sp+0h] [bp-530h]@4
  const char *v13; // [sp+4h] [bp-52Ch]@1
  char v14; // [sp+8h] [bp-528h]@8

  v1 = 20;
  v13 = a1;
  if ( !strcmp(a1, "eth1") )
    v2 = 80;
  else
    v2 = 40;
  v12 = v2;
  puts((const char *)&unk_516E1);
  puts("var control_channel_arr = new Array();");
  puts("var central_channel_arr = new Array();");
  do
  {
    if ( v1 != 60 )
    {
      for ( i = 0; ; i += 16 )
      {
        v10 = (char *)&country_names + i;
        if ( !*(_DWORD *)((char *)&country_names + i) )
          break;
        v4 = wireless_get_channel_list(v13, *((_DWORD *)v10 + 1), v1, &v14);
        if ( v4 )
        {
          v5 = 0;
          printf("control_channel_arr['%s_%d'] = new Array(", *((_DWORD *)v10 + 1), v1);
          v6 = 0;
          while ( v6 < v4 )
          {
            printf("%d", *(_DWORD *)(&v14 + v5));
            if ( v6 != v4 - 1 )
              putchar(44);
            ++v6;
            v5 += 20;
          }
          v7 = 0;
          puts(");");
          v8 = *((_DWORD *)v10 + 1);
          v9 = 0;
          printf("central_channel_arr['%s_%d'] = new Array(", v8, v1);
          while ( v9 < v4 )
          {
            printf("%d", *(_DWORD *)(&v14 + v7 + 4));
            if ( v9 != v4 - 1 )
              putchar(44);
            ++v9;
            v7 += 20;
          }
          puts(");");
        }
      }
    }
    v1 += 20;
  }
  while ( v1 <= v12 );
  print_file("/home/httpd/js/ccode.js");
  return puts("</script>\n");
}
// 10B20: using guessed type int __fastcall wireless_get_channel_list(_DWORD, _DWORD, _DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00014CC8) --------------------------------------------------------
signed int sub_14CC8()
{
  int v0; // r0@2
  signed int result; // r0@2

  if ( sysconf_nat_get(1) )
  {
    result = 0;
  }
  else
  {
    print_start_main_table(0);
    v0 = printf(
           "<tr><td width=100%% height=200px valign=top style=\"padding-top:10px;\"> %s </td></tr>",
           "인터넷 공유기능이 꺼져있는 상태에서 사용불가<br>인터넷 공유기능은 [NAT/라우터 "
           "관리]->[기타기능 설정] 에서 설정할 수 있습니다.");
    print_end_main_table(v0);
    result = 1;
  }
  return result;
}
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 11018: using guessed type int __fastcall sysconf_nat_get(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);

//----- (00014D08) --------------------------------------------------------
int __fastcall sub_14D08(int a1, int a2)
{
  return get_file_string("/home/httpd/build_date", a1, a2);
}
// 10850: using guessed type int __fastcall get_file_string(_DWORD, _DWORD, _DWORD);

//----- (00014D20) --------------------------------------------------------
int __fastcall sub_14D20(int a1)
{
  const char *v1; // r0@2
  int v2; // r5@3
  char v4; // [sp+4h] [bp-104h]@5
  int v5; // [sp+84h] [bp-84h]@7
  int v6; // [sp+ACh] [bp-5Ch]@7
  int v7; // [sp+C0h] [bp-48h]@7
  char v8; // [sp+D8h] [bp-30h]@7

  if ( !*(_DWORD *)(a1 + 464) )
  {
    v1 = "중단됨";
LABEL_8:
    printf(v1);
    return 0;
  }
  v2 = a1 + 852;
  if ( !get_ifstatus(a1 + 852) )
  {
    v1 = (const char *)&unk_518CC;
    goto LABEL_8;
  }
  if ( !wireless_api_get_mbridge_status(v2, &v4) )
  {
    v1 = "연결시도중";
    goto LABEL_8;
  }
  printf("%s", "연결됨");
  printf("( BSSID - %s , ", &v5);
  snprintf(&v8, 0x20u, "%d %%", v7);
  printf("%s %d %s", "채널", v6);
  putchar(41);
  return 0;
}
// 117D4: using guessed type int __fastcall wireless_api_get_mbridge_status(_DWORD, _DWORD);
// 11B70: using guessed type int __fastcall get_ifstatus(_DWORD);

//----- (00014E00) --------------------------------------------------------
signed int __fastcall sub_14E00(unsigned int a1, int a2, int a3)
{
  int v3; // r7@1
  unsigned int v4; // r5@1
  int v5; // r6@1
  char *v6; // r4@1
  unsigned int v7; // r0@2
  unsigned int v8; // r1@3
  unsigned int v9; // r5@3
  unsigned int v10; // r0@3
  char *v11; // r4@3
  unsigned int v12; // r1@3
  unsigned int v13; // r5@3
  unsigned int v14; // r0@3
  char *v15; // r4@3
  int v16; // r1@3
  char v18; // [sp+8h] [bp-118h]@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = &v18;
  if ( a1 > 0x15180 )
  {
    v7 = sub_4EB80(a1, 0x15180u);
    v6 = &v18 + snprintf(&v18, 0x40u, "%d %s ", v7, "일");
  }
  sub_4EC28(v4, 0x15180u);
  v9 = v8;
  v10 = sub_4EB80(v8, 0xE10u);
  v11 = &v6[snprintf(v6, 0x40u, "%d %s ", v10, "시간")];
  sub_4EC28(v9, 0xE10u);
  v13 = v12;
  v14 = sub_4EB80(v12, 0x3Cu);
  v15 = &v11[snprintf(v11, 0x40u, "%d %s ", v14, "분")];
  sub_4EC28(v13, 0x3Cu);
  snprintf(v15, 0x40u, "%d %s ", v16, "초");
  sf_strncpy(v3, &v18, v5);
  return 1;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (00014FF4) --------------------------------------------------------
int __fastcall sub_14FF4(int a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1

  v4 = a2;
  v5 = a3;
  if ( !get_intvalue(a1, "wl_mode", &v4) )
    v4 = 0;
  return v4;
}
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);

//----- (00015018) --------------------------------------------------------
signed int __fastcall sub_15018(int a1)
{
  int v1; // r4@1
  int v2; // r5@1
  int v3; // r0@1
  int v4; // r1@1
  int v5; // r2@1
  bool v6; // zf@1
  int v8; // r4@4
  const char *v9; // r0@7
  int v10; // r0@9
  const char *v11; // r0@10
  char *v12; // r1@10
  int v13; // r5@11
  const char *v14; // r0@14
  int v15; // r0@18
  int v16; // r0@19
  char s; // [sp+Ch] [bp-11Ch]@18
  int v18; // [sp+10Ch] [bp-1Ch]@4

  v1 = a1;
  v2 = get_pvalue(a1, "tmenu");
  v3 = get_pvalue(v1, "smenu");
  v6 = v2 == 0;
  if ( v2 )
    v6 = v3 == 0;
  if ( v6 )
    return 0;
  v8 = sub_14FF4(v1, v4, v5);
  get_active_wl(v8, 0, &v18);
  if ( v8 == 1 )
    v9 = "eth1";
  else
    v9 = "eth2";
  v10 = get_ifexist(v9);
  if ( v10 )
  {
    v13 = v18;
    if ( v18 )
    {
      print_start_main_table(v10);
      v11 = "<tr><td width=100%% height=200px valign=top style=\"padding-top:10px;\"> %s </td></tr>";
      v12 = "이 기능은 AP모드에서만 가능합니다.<br><a href=\"JavaScript:MovePagetoMain('wirelessconf','basi"
            "csetup');\"><b>[ 무선 설정/보안 ]</b></a>에서 무선 모드를 변경할 수 있습니다.";
    }
    else
    {
      if ( v8 == 1 )
        v14 = "eth1";
      else
        v14 = "eth2";
      if ( wireless_api_get_run(v14) )
        return v13;
      v15 = snprintf(
              &s,
              0x100u,
              "이 기능은 <a href=\"JavaScript:MovePagetoMain('%s','%s');\"><b>[무선 설정/보안]</b></a> 페이"
              "의 \"동작 설정\"를  \"실행\"으로 설정한 후 사용 할 수 있습니다.");
      print_start_main_table(v15);
      v11 = "<tr><td width=100%% height=200px valign=top style=\"padding-top:10px;\"> %s </td></tr>";
      v12 = &s;
    }
  }
  else
  {
    print_start_main_table(0);
    v11 = "<tr><td width=100%% height=200px valign=top style=\"padding-top:10px;\"> %s </td></tr>";
    v12 = "무선 모듈이 장착되어 있지 않습니다.";
  }
  v16 = printf(v11, v12);
  print_end_main_table(v16);
  return 1;
}
// 10808: using guessed type int __fastcall wireless_api_get_run(_DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11504: using guessed type int __fastcall get_ifexist(_DWORD);

//----- (00015158) --------------------------------------------------------
int __fastcall sub_15158(int a1, int a2)
{
  int v2; // r6@1
  int v3; // r4@1
  int v4; // r0@1
  const char *v5; // r1@5
  const char *v6; // r0@8
  const char *v7; // r1@8
  int v8; // r0@12
  int v9; // r0@12
  int v10; // r0@12
  int v11; // r0@12
  int v12; // r0@12
  int v13; // r0@12
  int v14; // r0@12
  int result; // r0@12
  int s; // [sp+Ch] [bp-594h]@1
  int v17; // [sp+1DCh] [bp-3C4h]@3
  char v18; // [sp+1E0h] [bp-3C0h]@12
  int v19; // [sp+35Ch] [bp-244h]@7
  char v20; // [sp+360h] [bp-240h]@12
  int v21; // [sp+57Ch] [bp-24h]@12

  v2 = a1;
  v3 = a2;
  memset(&s, 0, 0x570u);
  v4 = read_wireless_conf(&s, v2);
  if ( v3 )
    v4 = print_start_content_table(v4);
  str(v4);
  print_item_desc("동작 상태");
  puts("<td class=\"item_td\" colspan=3 width=390>");
  if ( v17 )
  {
    printf("동작중");
    if ( s )
      v5 = "AP 기능 사용";
    else
      v5 = "AP 기능 사용 중지";
    printf("- %s", v5);
    if ( v19 )
    {
      v6 = "- %s";
      v7 = "무선 WAN";
    }
    else
    {
      v6 = "- %s";
      v7 = "무선 브리지";
    }
    printf(v6, v7);
  }
  else
  {
    printf("중단됨");
  }
  v8 = puts("</td>");
  etr(v8);
  v9 = get_hwaddr_kernel(&v20, &v21);
  str(v9);
  print_item_desc("브리지 맥주소");
  puts("<td class=\"item_td\">");
  v10 = puts((const char *)&v21);
  v11 = etr(v10);
  str(v11);
  print_item_desc("네트워크 이름(SSID)");
  puts("<td class=\"item_td\">");
  v12 = puts(&v18);
  v13 = etr(v12);
  str(v13);
  print_item_desc("무선 브리지 연결 상태");
  puts("<td class=item_td colspan=3>");
  sub_14D20((int)&s);
  v14 = printf("</td>");
  result = etr(v14);
  if ( v3 )
    result = print_end_content_table(result);
  return result;
}
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00015324) --------------------------------------------------------
int __fastcall sub_15324(int a1)
{
  int v1; // r4@1

  v1 = a1;
  printf("<script>");
  printf("alert(\"%s\");\n", v1);
  printf("</script>");
  return 0;
}

//----- (0001535C) --------------------------------------------------------
int __fastcall sub_1535C(int a1, int a2, int a3)
{
  int result; // r0@2
  const unsigned __int16 *v4; // r2@5
  char *v5; // r3@5
  int v6; // t1@6
  char v7; // [sp+0h] [bp-108h]@2

  if ( a2 )
    result = get_value_post(a2, a3, &v7, 256);
  else
    result = get_value(a1, a3, &v7, 256);
  if ( result )
  {
    v4 = *_ctype_b_loc();
    v5 = &v7 - 1;
    while ( 1 )
    {
      v6 = (unsigned __int8)(v5++)[1];
      if ( !(v4[v6] & 8) )
        break;
      if ( !v5[1] )
        return atoi(&v7);
    }
    result = -7;
  }
  return result;
}
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00015410) --------------------------------------------------------
void *__fastcall sub_15410(int a1)
{
  char *v1; // r0@2
  const char *v2; // r1@2

  switch ( a1 )
  {
    case 1:
      v1 = (char *)&unk_91374;
      v2 = "G and B";
      break;
    case 2:
      v1 = (char *)&unk_91374;
      v2 = "B only";
      break;
    case 3:
      v1 = (char *)&unk_91374;
      v2 = "G only";
      break;
    case 4:
      v1 = (char *)&unk_91374;
      v2 = "N only";
      break;
    case 5:
      v1 = (char *)&unk_91374;
      v2 = "G and N";
      break;
    case 6:
      v1 = (char *)&unk_91374;
      v2 = "B,G,N";
      break;
    case 7:
      v1 = (char *)&unk_91374;
      v2 = "G-Performance";
      break;
    case 8:
      v1 = (char *)&unk_91374;
      v2 = "G-LRS";
      break;
    case 9:
      v1 = (char *)&unk_91374;
      v2 = (const char *)&unk_51C70;
      break;
    case 10:
      v1 = (char *)&unk_91374;
      v2 = "11ac/11n 5GHz";
      break;
    case 11:
      v1 = (char *)&unk_91374;
      v2 = "11ac only 5GHz";
      break;
    default:
      v1 = (char *)&unk_91374;
      v2 = "UNKNOWN";
      break;
  }
  strcpy(v1, v2);
  return &unk_91374;
}

//----- (0001551C) --------------------------------------------------------
void *__fastcall sub_1551C(int a1, int a2, int a3, int a4)
{
  int v4; // r0@2
  int v6; // [sp+Ch] [bp-Ch]@1

  v6 = a4;
  if ( *(_DWORD *)(a1 + 1212) )
  {
    v4 = sub_4EC48(*(_DWORD *)(a1 + 1216), 60);
    snprintf((char *)&unk_913B4, 0x80u, "%s - %s: %d %s", "동작중", "채널 검색 주기", v4, "시간", v6);
  }
  else
  {
    snprintf((char *)&unk_913B4, 0x80u, "중단됨");
  }
  return &unk_913B4;
}

//----- (00015664) --------------------------------------------------------
int __fastcall sub_15664(int a1, const char *a2, int a3)
{
  const char *v3; // r4@1
  int v4; // r6@1
  int v5; // r8@1
  const char *v6; // r0@4
  const char *v7; // r1@4
  int i; // r7@8
  int result; // r0@13
  int *v10; // [sp+Ch] [bp-34h]@0
  char v11; // [sp+10h] [bp-30h]@12
  int v12; // [sp+24h] [bp-1Ch]@4

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( !a2 || !*a2 )
    goto LABEL_8;
  if ( strchr(a2, 58) )
  {
    v6 = v3;
    v7 = "%02X:%02X:%02X:%02X:%02X:%02X";
    v10 = &v12;
LABEL_7:
    sscanf(v6, v7);
    goto LABEL_8;
  }
  if ( strchr(v3, 45) )
  {
    v7 = "%02X-%02X-%02X-%02X-%02X-%02X";
    v6 = v3;
    v10 = &v12;
    goto LABEL_7;
  }
LABEL_8:
  for ( i = 0; ; ++i )
  {
    printf(
      "<input type=text name='%s%d' size=2 maxlength=2 style=\"width:18pt; ime-mode: disabled;\" class=\"navi_text\" onfo"
      "cus='this.select();' onkeypress=\"return HWKeyDown('%s',%d);\" onkeyup=\"HWKeyUp('%s',%d);\"",
      v4,
      i + 1,
      v4,
      i + 1,
      v4,
      i + 1,
      v10);
    if ( v3 && *v3 )
      printf("value='%02X' ", *((_DWORD *)&v11 + i));
    printf("title=\"%s%d\"", "MAC 주소", i + 1);
    result = putchar(62);
    if ( i != 5 )
      result = putchar(45);
    if ( i == 5 )
      break;
  }
  if ( v5 )
    result = printf("<script> DisableHW('%s'); </script>", v4);
  return result;
}

//----- (000157CC) --------------------------------------------------------
int __fastcall sub_157CC(int a1, _BYTE *a2, int a3)
{
  int v3; // r5@1
  int v4; // r7@1
  char *v5; // r1@6
  char *v6; // r0@8
  bool v7; // zf@8
  const char *v8; // r1@8
  char *v9; // r0@8
  char *v10; // r0@13
  bool v11; // zf@13
  const char *v12; // r1@13
  char *v13; // r0@13
  char *v14; // r1@18
  char *v15; // r0@19
  unsigned int v16; // r4@24
  unsigned int v17; // r4@24
  char *v18; // r6@25
  signed int v19; // r4@25
  bool v20; // zf@26
  int result; // r0@29
  char v22; // [sp+18h] [bp-68h]@24
  char v23; // [sp+2Ch] [bp-54h]@24
  char s; // [sp+40h] [bp-40h]@8
  char v25; // [sp+45h] [bp-3Bh]@10
  char v26; // [sp+4Ah] [bp-36h]@15
  char v27; // [sp+4Fh] [bp-31h]@19
  char dest; // [sp+54h] [bp-2Ch]@3

  v3 = a1;
  v4 = a3;
  if ( a2 && *a2 )
    sf_strncpy(&dest, a2, 20);
  else
    strcpy(&dest, "");
  if ( dest )
  {
    v5 = strtok(&dest, ".");
    if ( !v5 )
      v5 = "0";
    strcpy(&s, v5);
    v6 = strtok(0, ".");
    v8 = v6;
    v7 = v6 == 0;
    v9 = &s;
    if ( v7 )
      v8 = "0";
    else
      v9 = &v25;
    if ( v7 )
      v9 += 5;
    strcpy(v9, v8);
    v10 = strtok(0, ".");
    v12 = v10;
    v11 = v10 == 0;
    v13 = &s;
    if ( v11 )
      v12 = "0";
    else
      v13 = &v26;
    if ( v11 )
      v13 += 10;
    strcpy(v13, v12);
    v14 = strtok(0, ".");
    if ( v14 )
    {
      v15 = &v27;
    }
    else
    {
      v15 = &v27;
      v14 = "0";
    }
    strcpy(v15, v14);
  }
  else
  {
    v27 = 0;
    v26 = 0;
    v25 = 0;
    s = 0;
  }
  if ( v4 == 3 )
  {
    get_ifconfig("br0", &v23, &v22);
    v16 = inet_addr(&v23);
    v17 = __rev(inet_addr(&v22)) & __rev(v16);
    snprintf(&s, 5u, "%d", v17 >> 24);
    snprintf(&v25, 5u, "%d", (v17 >> 16) & 0xFF);
    snprintf(&v26, 5u, "%d", (unsigned __int16)v17 >> 8);
    v27 = 0;
  }
  v18 = &s;
  v19 = 1;
  while ( 1 )
  {
    v20 = v19 == 4;
    if ( v19 == 4 )
      v20 = v4 == 4;
    if ( v20 )
      break;
    result = printf(
               "<input type=text name=\"%s%d\" maxlength=3 size=3 style=\"width:25pt; ime-mode:disabled;\" value=\"%s\" o"
               "nfocus=\"this.select();\"                    onkeyup=\"IPKeyUp('%s',%d);\" onkeypress=\"return IPKeyDown("
               "'%s', %d)\" title=\"%s%d\">",
               v3,
               v19,
               v18,
               v3,
               v19,
               v3,
               v19,
               "IP 주소",
               v19);
    if ( v19 != 4 )
      result = putchar(46);
    ++v19;
    v18 += 5;
    if ( v19 == 5 )
      return result;
  }
  return printf(
           "<input type=text name=\"%s%d\" maxlength=3 size=3 style=\"width:25pt; ime-mode:disabled; background-color:#ee"
           "eeee;\" value=\"%s\" readonly>",
           v3,
           4,
           &v27);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);

//----- (000159DC) --------------------------------------------------------
char *__fastcall sub_159DC(const char *a1, int a2, signed int *a3, _DWORD *a4)
{
  int v4; // r5@1
  _DWORD *v5; // r8@1
  signed int *v6; // r4@1
  const char *v7; // r6@1
  char *result; // r0@2
  const char *v9; // r6@4
  signed int v10; // r3@5
  int v11; // r0@23
  signed int v12; // r3@24
  signed int v13; // r3@30
  int v14; // [sp+0h] [bp-38h]@3

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( !strcmp(a1, "nouse") )
  {
    result = (char *)1;
    *v6 = 1;
    *v5 = 0;
    return result;
  }
  sf_strncpy(&v14, v7, 32);
  result = strchr((const char *)&v14, 95);
  if ( !result )
    return result;
  *result = 0;
  v9 = result + 1;
  if ( !strcmp((const char *)&v14, "wpa2psk") )
  {
    v10 = 9;
  }
  else if ( !strcmp((const char *)&v14, "wpapsk") )
  {
    v10 = 5;
  }
  else if ( !strcmp((const char *)&v14, (const char *)&unk_51FC2) )
  {
    v10 = 10;
  }
  else if ( !strcmp((const char *)&v14, "wpa") )
  {
    v10 = 4;
  }
  else if ( !strcmp((const char *)&v14, "wpa2") )
  {
    v10 = 8;
  }
  else if ( !strcmp((const char *)&v14, (const char *)&unk_51FD4) )
  {
    v10 = 11;
  }
  else
  {
    if ( strcmp((const char *)&v14, "auto") )
    {
      if ( strcmp((const char *)&v14, "open") )
      {
        if ( !strcmp((const char *)&v14, "key") )
        {
          v10 = 2;
          goto LABEL_23;
        }
        printf("Uknown AUTH : %s\n", &v14);
      }
      v10 = 1;
      goto LABEL_23;
    }
    v10 = 3;
  }
LABEL_23:
  *v6 = v10;
  v11 = strcmp(v9, "aes");
  if ( !v11 )
  {
    v12 = 4;
LABEL_29:
    *v5 = v12;
    return (char *)(v11 + 1);
  }
  v11 = strcmp(v9, "tkip");
  if ( !v11 )
  {
    v12 = 3;
    goto LABEL_29;
  }
  v11 = strcmp(v9, "tkipaes");
  if ( !v11 )
  {
    v12 = 5;
    goto LABEL_29;
  }
  result = (char *)strcmp(v9, "wep");
  if ( result )
  {
    printf("Uknown Encrypt : %s\n", v9);
    v13 = 0;
  }
  else
  {
    if ( v4 == 5 )
      result = (char *)1;
    else
      v13 = 2;
    if ( v4 == 5 )
    {
      *v5 = result;
      return result;
    }
  }
  result = (char *)1;
  *v5 = v13;
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (00015C10) --------------------------------------------------------
signed int __fastcall sub_15C10(int a1, int a2, char *a3)
{
  bool v3; // zf@1
  int v4; // r4@3
  char *v5; // r5@3
  char *v6; // r0@8
  const char *v7; // r1@8
  char *v8; // r0@18
  const char *v9; // r1@18

  v3 = a1 == 1;
  if ( a1 != 1 )
    v3 = a1 == 3;
  v4 = a2;
  v5 = a3;
  if ( !v3 || a2 )
  {
    switch ( a1 )
    {
      case 2:
        v6 = a3;
        v7 = "key";
        break;
      case 3:
        v6 = a3;
        v7 = "auto";
        break;
      case 4:
        v6 = a3;
        v7 = "wpa";
        break;
      case 5:
        v6 = a3;
        v7 = "wpapsk";
        break;
      default:
        v7 = "open";
        v6 = a3;
        break;
      case 8:
        v6 = a3;
        v7 = "wpa2";
        break;
      case 9:
        v6 = a3;
        v7 = "wpa2psk";
        break;
      case 10:
        v6 = a3;
        v7 = (const char *)&unk_51FC2;
        break;
      case 11:
        v6 = a3;
        v7 = (const char *)&unk_51FD4;
        break;
    }
    strcpy(v6, v7);
    strcat(v5, "_");
    switch ( v4 )
    {
      case 1:
      case 2:
        v9 = "wep";
        v8 = v5;
        goto LABEL_22;
      case 3:
        v8 = v5;
        v9 = "tkip";
        goto LABEL_22;
      case 4:
        v8 = v5;
        v9 = "aes";
        goto LABEL_22;
      case 5:
        v8 = v5;
        v9 = "tkipaes";
LABEL_22:
        strcat(v8, v9);
        break;
      default:
        return 1;
    }
  }
  else
  {
    strcpy(a3, "nouse");
  }
  return 1;
}

//----- (00015D88) --------------------------------------------------------
int __fastcall sub_15D88(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r5@1
  void *v6; // r0@1

  v5 = a4;
  printf(
    "<DIV ID=\"%s\" STYLE=\"position:absolute; left:%dpx; top:%dpx; width:%dpx; height:%dpx; Z-index:1; background-color:"
    "#ffffff; opacity:0.5; display:none;\">\n",
    a1,
    a2,
    a3,
    a4,
    a5);
  v6 = sub_16094();
  return printf(
           "<table width=%dpx height=%dpx><tr><td width=100%% height=100%% align=center valign=center><img src=\"/%s/appl"
           "y_ani.gif\"></td></tr></table></DIV>",
           v5,
           a5,
           v6);
}

//----- (00015DE4) --------------------------------------------------------
int __fastcall sub_15DE4(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r6@1
  int v6; // r8@1
  int v7; // r7@1
  int v8; // r5@1
  int v9; // r10@1
  void *v10; // r0@1

  v5 = a2;
  v6 = a3;
  v7 = a1;
  v8 = a4;
  v9 = hwinfo_get_reboot_duration(a1);
  printf(
    "<DIV ID=\"%s\" STYLE=\"position:absolute; left:%dpx; top:%dpx; width:%dpx; height:%dpx; Z-index:1; background-color:"
    "#ffffff; opacity:0.5; display:none;\">\n",
    v7,
    v5,
    v6,
    v8,
    a5);
  v10 = sub_16094();
  printf(
    "<table width=%dpx height=%dpx><tr><td width=230 height=100%% align=right valign=center><img src=\"/%s/apply_ani.gif\""
    "></td><td style=\"padding:3 0 0 2;\" align=left>%s(<span id=\"apply_mask_time_check\">%d</span>%s)</td></tr></table></DIV>",
    v8,
    a5,
    v10,
    "재시작중입니다.",
    v9,
    "초 남음");
  return printf("<script>var time = document.getElementById(\"apply_mask_time_check\").innerHTML;</script>");
}
// 10598: using guessed type int __fastcall hwinfo_get_reboot_duration(_DWORD);

//----- (00015E70) --------------------------------------------------------
int __fastcall sub_15E70(int a1, int a2, int a3)
{
  int v3; // r7@1
  int v4; // r10@1
  int v5; // r6@1
  int v6; // r4@1
  int v7; // r8@1
  int v8; // r0@1
  char v10; // [sp+10h] [bp-30h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a3 + 48);
  v5 = a2;
  v6 = a3;
  v7 = sub_4EC48(*(_DWORD *)(a3 + 48), 100);
  v8 = sub_4EC48(v4, 10);
  snprintf(&v10, 0x10u, "%d.%d", v7, v8);
  printf(
    "<DIV ID=\"%s\" STYLE=\"position:absolute; left:%dpx; top:%dpx; width:%dpx; height:%dpx; Z-index:1; background-color:"
    "%s; opacity:%s; display:none;\">\n",
    v3,
    *(_DWORD *)v6,
    *(_DWORD *)(v6 + 4),
    *(_DWORD *)(v6 + 8),
    *(_DWORD *)(v6 + 12),
    v6 + 16,
    &v10);
  return printf(
           "<table width=%dpx height=%dpx><tr><td width=100%% height=100%% align=center valign=center>%s</td></tr></table></DIV>",
           *(_DWORD *)(v6 + 8),
           *(_DWORD *)(v6 + 12),
           v5);
}

//----- (00015F18) --------------------------------------------------------
int __fastcall sub_15F18(int a1)
{
  printf("<tr><td width=100%% height=200px valign=top style=\"padding-top:10px;\"> %s </td></tr>", a1);
  return 0;
}

//----- (00015F34) --------------------------------------------------------
void *__fastcall sub_15F34(const char *a1)
{
  const char *v1; // r7@1
  signed int v2; // r5@1
  char *v3; // r4@1
  signed int v4; // r0@1
  signed int v5; // r6@2
  int v6; // r2@5
  char *v7; // r0@6
  const char *v8; // r1@6

  v1 = a1;
  v2 = 0;
  v3 = (char *)&unk_91434;
  v4 = strlen(a1);
  if ( v4 >= 32 )
    v5 = 32;
  else
    v5 = v4;
  while ( v2 < v5 )
  {
    v6 = v1[v2];
    if ( v6 == 60 )
    {
      v7 = v3;
      v8 = "&#60;";
LABEL_9:
      strcpy(v7, v8);
      v3 += 5;
      goto LABEL_21;
    }
    if ( v6 == 62 )
    {
      v8 = "&#62;";
      v7 = v3;
      goto LABEL_9;
    }
    if ( v6 == 38 )
    {
      v7 = v3;
      v8 = "&#38;";
      goto LABEL_9;
    }
    if ( v6 == 34 )
    {
      v7 = v3;
      v8 = "&#34;";
      goto LABEL_9;
    }
    if ( v6 == 32 )
    {
      v7 = v3;
      v8 = "&#32;";
      goto LABEL_9;
    }
    if ( v6 == 39 )
    {
      v7 = v3;
      v8 = "&#39;";
      goto LABEL_9;
    }
    if ( v6 == 35 )
    {
      v7 = v3;
      v8 = "&#35;";
      goto LABEL_9;
    }
    v3 += sprintf(v3, "%c");
LABEL_21:
    if ( strlen((const char *)&unk_91434) > 0xFF )
      return &unk_91434;
    ++v2;
  }
  return &unk_91434;
}

//----- (00016030) --------------------------------------------------------
int sub_16030()
{
  return 0;
}

//----- (00016038) --------------------------------------------------------
signed int __fastcall sub_16038(int a1)
{
  int v1; // r5@1
  int v2; // r1@2
  int v3; // r2@2
  int v4; // r3@2
  int v5; // r12@2
  int v6; // r1@2
  int v7; // r2@2
  int v8; // r3@2

  v1 = a1;
  dword_91534 = sysget_ui_version(a1);
  if ( dword_91534 == 2 )
  {
    v2 = unk_8FB64;
    v3 = unk_8FB68;
    v4 = unk_8FB6C;
    *(_DWORD *)v1 = unk_8FB60;
    *(_DWORD *)(v1 + 4) = v2;
    *(_DWORD *)(v1 + 8) = v3;
    *(_DWORD *)(v1 + 12) = v4;
    v5 = v1 + 16;
    v6 = unk_8FB74;
    v7 = unk_8FB78;
    v8 = unk_8FB7C;
    *(_DWORD *)v5 = unk_8FB70;
    *(_DWORD *)(v5 + 4) = v6;
    *(_DWORD *)(v5 + 8) = v7;
    *(_DWORD *)(v5 + 12) = v8;
    *(_DWORD *)(v1 + 32) = unk_8FB80;
  }
  else
  {
    puts("UI Not Specified..");
  }
  return 1;
}
// 11198: using guessed type int __fastcall sysget_ui_version(_DWORD);
// 91534: using guessed type int dword_91534;

//----- (00016094) --------------------------------------------------------
void *sub_16094()
{
  char *v0; // r0@2
  const char *v1; // r1@2

  if ( dword_91534 == 2 )
  {
    v0 = (char *)&unk_91538;
    v1 = "images2";
  }
  else
  {
    v0 = (char *)&unk_91538;
    v1 = "images";
  }
  strcpy(v0, v1);
  return &unk_91538;
}
// 91534: using guessed type int dword_91534;

//----- (000160D0) --------------------------------------------------------
void *sub_160D0()
{
  snprintf((char *)&unk_91558, 0x100u, "%s/%s");
  return &unk_91558;
}
// 91534: using guessed type int dword_91534;

//----- (0001611C) --------------------------------------------------------
signed int __fastcall sub_1611C(const char *a1)
{
  const char *v1; // r4@1
  signed int result; // r0@2

  v1 = a1;
  if ( !strcmp(a1, "Jan") )
  {
    result = 1;
  }
  else if ( !strcmp(v1, "Feb") )
  {
    result = 2;
  }
  else if ( !strcmp(v1, "Mar") )
  {
    result = 3;
  }
  else if ( !strcmp(v1, "Apr") )
  {
    result = 4;
  }
  else if ( !strcmp(v1, "May") )
  {
    result = 5;
  }
  else if ( !strcmp(v1, "Jun") )
  {
    result = 6;
  }
  else if ( !strcmp(v1, "Jul") )
  {
    result = 7;
  }
  else if ( !strcmp(v1, "Aug") )
  {
    result = 8;
  }
  else if ( !strcmp(v1, "Sep") )
  {
    result = 9;
  }
  else if ( !strcmp(v1, "Oct") )
  {
    result = 10;
  }
  else if ( !strcmp(v1, "Nov") )
  {
    result = 11;
  }
  else if ( !strcmp(v1, "Dec") )
  {
    result = 12;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00016278) --------------------------------------------------------
int __fastcall sub_16278(int a1, const char *a2)
{
  const char *v2; // r5@1
  int result; // r0@1
  char v4; // [sp+4h] [bp-24h]@2

  v2 = a2;
  result = get_captcha();
  if ( result )
    result = strcmp(&v4, v2) == 0;
  return result;
}
// 106D0: using guessed type int get_captcha(void);

//----- (0001633C) --------------------------------------------------------
int __fastcall sub_1633C(int a1)
{
  int v1; // r6@1
  int v2; // r6@2
  char v4; // [sp+0h] [bp-D0h]@1
  unsigned __int8 v5; // [sp+80h] [bp-50h]@1

  v1 = a1;
  strcpy(&v4, "");
  strcpy((char *)&v5, "");
  if ( get_value_post(v1, "captcha_file", &v4, 63) )
  {
    if ( v4 )
    {
      v2 = get_value_post(v1, "captcha_code", &v5, 64);
      if ( v2 && (v2 = v5) != 0 && (v2 = sub_16278((int)&v4, (const char *)&v5)) != 0 )
      {
        v2 = 1;
        remove_captcha(&v4);
      }
      else
      {
        remove_captcha(&v4);
      }
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    v2 = 0;
  }
  return v2;
}
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11CA8: using guessed type int __fastcall remove_captcha(_DWORD);

//----- (00016404) --------------------------------------------------------
int __fastcall sub_16404(void *a1)
{
  void *v1; // r6@1
  int v2; // r4@1
  int result; // r0@2
  int v4; // [sp+0h] [bp-4h]@2
  int v5; // [sp+4h] [bp+0h]@3

  v1 = a1;
  v2 = 0;
  while ( 1 )
  {
    result = ddnsapi_read_config(v2, &v4);
    if ( !result )
      break;
    if ( !strcmp("iptime", (const char *)&v5) )
    {
      if ( v1 )
        memcpy(v1, &v4, 0x500u);
      return 1;
    }
    if ( ++v2 == 6 )
      return 0;
  }
  return result;
}
// 10A00: using guessed type int __fastcall ddnsapi_read_config(_DWORD, _DWORD);

//----- (0001648C) --------------------------------------------------------
signed int __fastcall sub_1648C(const char *a1)
{
  const char *v1; // r4@1
  signed int v2; // r0@1
  signed int i; // r2@1
  unsigned int v4; // r3@2
  unsigned int v5; // r12@2
  unsigned int v6; // r1@2
  bool v7; // cf@2
  bool v8; // zf@2
  unsigned int v9; // r1@6
  bool v10; // cf@6
  bool v11; // zf@6

  v1 = a1;
  v2 = strlen(a1);
  for ( i = 0; ; ++i )
  {
    if ( i >= v2 )
      return 1;
    v4 = v1[i];
    v5 = (unsigned __int8)(v4 - 65);
    v6 = (unsigned __int8)(v4 - 97);
    v7 = v5 >= 0x19;
    v8 = v5 == 25;
    if ( v5 > 0x19 )
    {
      v7 = v6 >= 0x19;
      v8 = v6 == 25;
    }
    if ( !v8 && v7 )
    {
      v9 = (unsigned __int8)(v4 - 48);
      v10 = v4 >= 0x2E;
      v11 = v4 == 46;
      if ( v4 != 46 )
      {
        v10 = v9 >= 9;
        v11 = v9 == 9;
      }
      if ( !v11 && v10 && v4 != 45 )
        break;
    }
  }
  return 0;
}

//----- (000164F8) --------------------------------------------------------
int __fastcall sub_164F8(const char *a1)
{
  const char *v1; // r6@1
  int v2; // r4@1
  int result; // r0@3
  int v4; // [sp+0h] [bp-78h]@2

  v1 = a1;
  v2 = 0;
  do
  {
    memset(&v4, 0, 0x68u);
    if ( !pptpserver_get_index_pptpinfo(v2, &v4) )
      break;
    result = strcmp((const char *)&v4, v1);
    if ( !result )
      return result;
    ++v2;
  }
  while ( v2 != 5 );
  return 1;
}
// 10D00: using guessed type int __fastcall pptpserver_get_index_pptpinfo(_DWORD, _DWORD);

//----- (0001655C) --------------------------------------------------------
int __fastcall sub_1655C(time_t a1, char *a2, size_t a3, int a4)
{
  int v4; // r10@1
  char *v5; // r6@1
  size_t v6; // r8@1
  char *v7; // r0@1
  bool v8; // zf@1
  int v9; // r10@1
  signed int v10; // r0@3
  int v11; // r7@2
  signed int v12; // r5@2
  char *v13; // r3@5
  int v14; // r0@16
  time_t timer; // [sp+3Ch] [bp-ECh]@1
  char v17; // [sp+44h] [bp-E4h]@1
  char v18; // [sp+C4h] [bp-64h]@1
  char v19; // [sp+E4h] [bp-44h]@1
  char v20; // [sp+ECh] [bp-3Ch]@1
  int v21; // [sp+F4h] [bp-34h]@1
  int v22; // [sp+F8h] [bp-30h]@1
  int v23; // [sp+FCh] [bp-2Ch]@1
  int v24; // [sp+100h] [bp-28h]@1
  int v25; // [sp+104h] [bp-24h]@1

  timer = a1;
  v4 = a4;
  v5 = a2;
  v6 = a3;
  get_timezone_abbr_from_config(&v18);
  setenv("TZ", &v18, 1);
  v7 = ctime(&timer);
  snprintf(&v17, 0x80u, "%s", v7);
  sscanf(&v17, "%s %s %d %d:%d:%d %d", &v20, &v19, &v24, &v23, &v22, &v21, &v25);
  v8 = v4 == 1;
  v9 = v24;
  if ( v8 )
  {
    v10 = sub_1611C(&v19);
    snprintf(v5, v6, "%4d-%02d-%02d %02d:%02d:%02d\n", v25, v10, v9, v23, v22, v21);
  }
  else
  {
    v11 = v25;
    v12 = sub_1611C(&v19);
    if ( !strcmp(&v20, "Sun") )
    {
      v13 = "일";
    }
    else if ( !strcmp(&v20, "Mon") )
    {
      v13 = "월";
    }
    else if ( !strcmp(&v20, "Tue") )
    {
      v13 = "화";
    }
    else if ( !strcmp(&v20, "Wed") )
    {
      v13 = "수";
    }
    else if ( !strcmp(&v20, "Thu") )
    {
      v13 = "목";
    }
    else if ( !strcmp(&v20, "Fri") )
    {
      v13 = "금";
    }
    else
    {
      v14 = strcmp(&v20, "Sat");
      v13 = "토";
      if ( v14 )
        v13 = "일";
    }
    snprintf(
      v5,
      v6,
      "%d%s %d%s %d%s %s%s  %d%s %d%s %d%s",
      v11,
      "년",
      v12,
      "월",
      v9,
      "일",
      v13,
      "요일",
      v23,
      "시",
      v22,
      "분",
      v21,
      "초");
  }
  return 0;
}
// 10E38: using guessed type int __fastcall get_timezone_abbr_from_config(_DWORD);

//----- (000167D8) --------------------------------------------------------
signed int __fastcall sub_167D8(char *a1, time_t a2)
{
  char *v2; // r4@1
  size_t v3; // r5@1
  signed int result; // r0@2
  time_t timer; // [sp+4h] [bp-14h]@1

  timer = a2;
  v2 = a1;
  v3 = a2;
  if ( get_timed_status(a1) )
  {
    time(&timer);
    sub_1655C(timer, v2, v3, 0);
    result = 1;
  }
  else
  {
    strcpy(v2, "타임서버로 부터 시간 받는 중..");
    result = 0;
  }
  return result;
}
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (0001682C) --------------------------------------------------------
int __fastcall sub_1682C(int a1, int a2, int a3)
{
  int v3; // r6@1
  int v4; // r5@1
  int v5; // r4@1
  int v6; // r0@1
  const char *v7; // r0@2
  int result; // r0@3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = is_mobile_agent(a1);
  if ( v6 == 1 )
  {
    v7 = "<div style=\"height:%s; width:%s; -webkit-overflow-scrolling: touch; overflow-y:scroll; overflow-x:hidden; %s\">";
  }
  else
  {
    result = is_mobile_agent(v6);
    if ( result != 2 )
      return result;
    v7 = "<div style=\"height:%s; width:%s; -webkit-overflow-scrolling: touch; overflow-y:hidden; overflow-x:hidden; %s\">";
  }
  return printf(v7, v3, v4, v5);
}
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);

//----- (00016878) --------------------------------------------------------
int __fastcall sub_16878(int a1)
{
  int result; // r0@1

  result = is_mobile_agent(a1);
  if ( result )
    result = printf("</div>");
  return result;
}
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);

//----- (00017428) --------------------------------------------------------
signed int __fastcall sub_17428(const char *a1, const char *a2)
{
  const char *v2; // r4@1
  const char *v3; // r5@1
  signed int result; // r0@17

  v2 = a2;
  v3 = a1;
  if ( !strncmp(a1, "wirelessconf", 0xCu)
    && (!strcmp(v2, "multibssid")
     || !strcmp(v2, "advancesetup")
     || !strcmp(v2, "sched")
     || !strcmp(v2, "multibridge")
     || !strcmp(v2, "wdssetup")
     || !strcmp(v2, "macauth"))
    || !strncmp(v3, "sysconf", 7u) && !strcmp(v2, "misc")
    || !strncmp(v3, "natrouterconf", 0xDu) && !strcmp(v2, "portforward")
    || !strncmp(v3, "firewallconf", 0xCu) && !strcmp(v2, "firewall")
    || !strncmp(v3, "plugin", 6u)
    || !strncmp(v3, "basicapp", 8u) )
  {
    result = 1;
  }
  else if ( !strncmp(v3, "nasconf", 7u) )
  {
    result = strncmp(v2, "basic", 5u) != 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (000177D4) --------------------------------------------------------
signed int __fastcall sub_177D4(int a1, char *a2, size_t a3)
{
  char *v3; // r7@1
  size_t v4; // r10@1
  int v5; // r4@1
  int i; // r6@1
  char *v7; // r0@2
  char v8; // r3@2
  char *v9; // r0@8
  size_t v10; // r1@8
  char **v11; // r6@8
  const char *v12; // r2@8
  const char *v14; // r5@14
  char v15; // [sp+8h] [bp-1A8h]@2
  char v16; // [sp+88h] [bp-128h]@6
  char s1; // [sp+108h] [bp-A8h]@1

  v3 = a2;
  v4 = a3;
  v5 = 0;
  get_value(a1, "smenu", &s1, 128);
  for ( i = 0; ; ++i )
  {
    v14 = (&off_53BAC)[v5];
    if ( !v14 )
    {
      strcpy(v3, "");
      return 0;
    }
    sf_strncpy(&v15, (&off_53BAC)[4 * v5 + 4], 128);
    v7 = strchr(&v15, 38);
    if ( v7 )
      v8 = 0;
    if ( v7 )
      *v7 = v8;
    snprintf(&v16, 0x80u, "%s_%s", v14, &v15);
    v5 += 28;
    if ( !strcmp(&s1, &v16) )
      break;
  }
  if ( !strcmp(v14, "wirelessconf") )
  {
    v9 = v3;
    v10 = v4;
    v11 = &(&off_53BAC)[28 * i];
    v12 = "2.4GHz %s";
  }
  else if ( !strcmp(v14, "wirelessconf5g") )
  {
    v9 = v3;
    v11 = &(&off_53BAC)[28 * i];
    v12 = "5GHz %s";
    v10 = v4;
  }
  else
  {
    v9 = v3;
    v11 = &(&off_53BAC)[28 * i];
    v12 = "%s";
    v10 = v4;
  }
  snprintf(v9, v10, v12, v11[3]);
  return 1;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 53BAC: using guessed type char *off_53BAC;

//----- (0001793C) --------------------------------------------------------
signed int __fastcall sub_1793C(int a1, const char *a2, int a3)
{
  int v3; // r5@1
  const char *v4; // r4@1
  int v5; // r11@1
  int v6; // r6@1
  const char *v7; // r1@4
  int v9; // r0@6
  char **v10; // r9@6
  int v11; // r0@6
  int v12; // r0@6
  int v13; // r0@6
  const char *v14; // r1@8
  int v15; // r5@9
  const char *v16; // r1@13
  int v17; // r0@14
  int v18; // [sp+14h] [bp-12Ch]@1
  char v19; // [sp+18h] [bp-128h]@6
  char v20; // [sp+58h] [bp-E8h]@6
  char v21; // [sp+98h] [bp-A8h]@6
  char v22; // [sp+D8h] [bp-68h]@6

  v3 = 0;
  v4 = a2;
  v5 = a3;
  v6 = 0;
  v18 = a1;
  while ( 1 )
  {
    v7 = (&off_53BAC)[v3];
    if ( !v7 )
      return 0;
    v3 += 28;
    if ( !strcmp(v4, v7) )
      break;
    ++v6;
  }
  str(0);
  puts("<td>");
  v9 = puts("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0>");
  str(v9);
  sub_181D8(1, 16);
  snprintf(&v21, 0x40u, "%s_picon", v4);
  snprintf(&v22, 0x40u, "%s_setup", v4);
  snprintf(&v19, 0x40u, "navimenu_%s.gif", v4);
  snprintf(&v20, 0x40u, "%s_foldericon", v4);
  sub_1820C((int)"middle_plus.gif", (int)&v21, (int)&v22, 1);
  sub_1820C((int)&v19, (int)&v20, (int)"", 0);
  v10 = &off_53BB8;
  v11 = sub_18280(&v22, (int)(&off_53BAC)[112 * v6 + 8]);
  etr(v11);
  puts("</table>");
  v12 = printf("</td>");
  v13 = etr(v12);
  str(v13);
  printf("<td id=\"%s\" style=\"display:none;\">\n", &v22);
  puts("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0>");
  while ( 1 )
  {
    v16 = *(v10 - 3);
    if ( !v16 )
      break;
    if ( !strcmp(v4, v16) )
    {
      v14 = v10[4];
      v15 = v14 ? (unsigned __int8)(strcmp(v4, v14) != 0) : 1;
      sub_18314(v18, (int)"navimenu_detail_menu.gif", v4, (int)*(v10 - 2), (int)*v10, v15, v5);
      if ( v15 )
        break;
    }
    v10 += 7;
  }
  puts("</table>");
  v17 = printf("</td>");
  etr(v17);
  return 1;
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 53BAC: using guessed type char *off_53BAC;
// 53BB8: using guessed type char *;

//----- (00017B4C) --------------------------------------------------------
char *__fastcall sub_17B4C(char *s1, const char *a2)
{
  int v2; // r4@1
  char *v3; // r9@1
  const char *v4; // r10@1
  int v5; // r5@1
  char *v6; // r11@3
  char *v7; // r1@4
  const char *v9; // r1@8
  int v10; // [sp+0h] [bp-A8h]@4

  v2 = 0;
  v3 = s1;
  v4 = a2;
  v5 = 0;
  while ( 1 )
  {
    v9 = (&off_53BAC)[v2];
    if ( !v9 )
      break;
    if ( !strcmp(v3, v9) )
    {
      v6 = (&off_53BAC)[4 * v2 + 4];
      if ( !strcmp(v4, (&off_53BAC)[4 * v2 + 4]) )
        return (&off_53BAC)[112 * v5 + 16];
      sf_strncpy(&v10, v6, 128);
      v7 = strtok((char *)&v10, "&");
      if ( v7 )
      {
        if ( !strcmp(v4, v7) )
          return (&off_53BAC)[112 * v5 + 16];
      }
    }
    ++v5;
    v2 += 28;
  }
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 53BAC: using guessed type char *off_53BAC;

//----- (00017C0C) --------------------------------------------------------
char *__fastcall sub_17C0C(char *s1, const char *a2)
{
  int v2; // r4@1
  char *v3; // r9@1
  const char *v4; // r10@1
  int v5; // r5@1
  char *v6; // r11@3
  char *v7; // r1@4
  const char *v9; // r1@8
  int v10; // [sp+0h] [bp-A8h]@4

  v2 = 0;
  v3 = s1;
  v4 = a2;
  v5 = 0;
  while ( 1 )
  {
    v9 = (&off_53BAC)[v2];
    if ( !v9 )
      break;
    if ( !strcmp(v3, v9) )
    {
      v6 = (&off_53BAC)[4 * v2 + 4];
      if ( !strcmp(v4, (&off_53BAC)[4 * v2 + 4]) )
        return (&off_53BAC)[112 * v5 + 20];
      sf_strncpy(&v10, v6, 128);
      v7 = strtok((char *)&v10, "&");
      if ( v7 )
      {
        if ( !strcmp(v4, v7) )
          return (&off_53BAC)[112 * v5 + 20];
      }
    }
    ++v5;
    v2 += 28;
  }
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 53BAC: using guessed type char *off_53BAC;

//----- (00017CCC) --------------------------------------------------------
int __fastcall sub_17CCC(int a1)
{
  void *v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v12; // [sp+14h] [bp-1Ch]@1

  v12 = 0;
  get_intvalue(a1, "helpmenu", &v12);
  puts("<body bgcolor=#dedede topmargin=\"0\" leftmargin=\"0\" rightmargin=\"0\" bottommargin=\"0\" style=\"background-color:transparent\">");
  puts("<form name=navi_basic_form>");
  puts("<input type=hidden name=\"navi_basic_hidden\" value=\"none\">");
  v1 = sub_16094();
  printf("<input type=hidden name=\"image_prefix\" value=\"/%s\">\n", v1);
  v2 = printf("<table class=\"navimaintable\" CELLPADDING=0 CELLSPACING=0 width=197 >\n ");
  str(v2);
  puts("<td valign=top>");
  v3 = printf("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0 >\n ");
  str(v3);
  puts("<td>");
  printf("<table class=\"navicontent_table\" width=100%% CELLPADDING=0 CELLSPACING=0 >\n");
  v4 = print_blank_line(3, 5);
  str(v4);
  puts("<td>");
  sub_181D8(1, 16);
  sub_1820C((int)"navimenu_title_basic_setup.gif", (int)"basic_foldericon", (int)"", 0);
  v5 = sub_18280("basic_setup", (int)"기본 설정");
  etr(v5);
  puts("</table>");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  printf("<td id=\"%s\">\n", "basic_setup");
  puts("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0>");
  sub_18314(2, (int)"system_info.gif", "system", (int)"info", (int)"시스템 요약 정보", 0, v12);
  sub_18314(2, (int)"netconf_wansetup.gif", "netconf", (int)"wansetup", (int)"인터넷 연결 설정", 0, v12);
  sub_18314(
    2,
    (int)"wirelessconf_basicsetup.gif",
    "wirelessconf",
    (int)"basicsetup",
    (int)"2.4GHz 무선 설정/보안",
    0,
    v12);
  sub_18314(
    2,
    (int)"wirelessconf_basicsetup.gif",
    "wirelessconf5g",
    (int)"basicsetup&wl_mode=1",
    (int)"5GHz 무선 설정/보안",
    0,
    v12);
  sub_18314(2, (int)"sysconf_swupgrade.gif", "sysconf", (int)"swupgrade", (int)"펌웨어 업그레이드", 1, v12);
  puts("</table>");
  v8 = printf("</td>");
  etr(v8);
  puts("</table>");
  v9 = printf("</td>");
  etr(v9);
  puts("</table>");
  v10 = printf("</td>");
  etr(v10);
  puts("</table>");
  printf("</form>");
  return printf("</body>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (00017F88) --------------------------------------------------------
int __fastcall sub_17F88(int a1, int a2, int a3)
{
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v12; // [sp+4h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-18h]@1

  v13 = a3;
  v12 = 0;
  get_intvalue(a1, "helpmenu", &v12);
  puts("<body bgcolor=#dedede topmargin=\"0\" leftmargin=\"0\" rightmargin=\"0\" bottommargin=\"0\" style=\"background-color:transparent\">");
  puts("<form name=navi_advance_form>");
  puts("<input type=hidden name=\"navi_advance_hidden\" value=\"none\">");
  v3 = printf("<table border=0 CELLPADDING=0 CELLSPACING=0>");
  str(v3);
  puts("<td valign=top>");
  v4 = printf("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0 >\n ");
  str(v4);
  puts("<td valign=top>");
  v5 = printf("<table class=\"navicontent_table\" width=100%% CELLPADDING=0 CELLSPACING=0 >\n");
  str(v5);
  puts("<td>");
  puts("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0>");
  sub_1820C((int)"navimenu_plusnode.gif", (int)"advance_picon", (int)"advance_setup", 1);
  sub_1820C((int)"navimenu_title_advance_setup.gif", (int)"advance_foldericon", (int)"", 0);
  v6 = sub_18280("advance_setup", (int)"고급 설정");
  etr(v6);
  puts("</table>");
  v7 = printf("</td>");
  v8 = etr(v7);
  str(v8);
  printf("<td id=\"%s\" style=\"display:none;\" >\n", "advance_setup");
  puts("<table class=\"navicontent_table\" CELLPADDING=0 CELLSPACING=0>");
  sub_1793C(3, "netconf", v12);
  sub_1793C(3, "wirelessconf", v12);
  sub_1793C(3, "wirelessconf5g", v12);
  sub_1793C(3, "natrouterconf", v12);
  sub_1793C(3, "firewallconf", v12);
  sub_1793C(3, "expertconf", v12);
  sub_1793C(3, "trafficconf", v12);
  sub_1793C(3, "sysconf", v12);
  sub_1793C(3, "nasconf", v12);
  sub_1793C(3, "basicapp", v12);
  puts("</table>");
  v9 = printf("</td>");
  etr(v9);
  puts("</table>");
  v10 = printf("</td>");
  etr(v10);
  puts("</table>");
  puts("</form>");
  return puts("</body>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);

//----- (000181D8) --------------------------------------------------------
int __fastcall sub_181D8(int result, int a2)
{
  int v2; // r6@1
  int v3; // r5@1
  int v4; // r4@1

  v2 = result;
  v3 = a2;
  v4 = 0;
  while ( v4 < v2 )
  {
    ++v4;
    result = printf("<td width=%d ></td>\n", v3);
  }
  return result;
}

//----- (0001820C) --------------------------------------------------------
int __fastcall sub_1820C(int a1, int a2, int a3, int a4)
{
  int v4; // r6@1
  int v5; // r5@1
  void *v6; // r0@2
  int result; // r0@2
  void *v8; // r0@3

  v4 = a2;
  v5 = a3;
  if ( a4 )
  {
    puts("<td>");
    v6 = sub_160D0();
    result = printf("<img class=navi_click_img id=\"%s\" src=\"%s\" onclick=\"toggle('%s','');\"></td>\n", v4, v6, v5);
  }
  else
  {
    puts("<td width=16>");
    v8 = sub_160D0();
    result = printf("<img id=\"%s\" src=\"%s\"></td>\n", v4, v8);
  }
  return result;
}

//----- (00018280) --------------------------------------------------------
int __fastcall sub_18280(const char *a1, int a2)
{
  const char *v2; // r5@1
  int v3; // r6@1
  int v5; // [sp+0h] [bp-50h]@1

  v2 = a1;
  v3 = a2;
  snprintf((char *)&v5, 0x40u, "%s_td", a1);
  printf("<td id=\"%s\">\n", &v5);
  if ( !strcmp(v2, "basic_setup") )
    printf("<span style=\"margin-left:4;\">%s</span>\n", v3);
  else
    printf(
      "<span style=\"cursor:pointer; margin-left:4;\" onclick=\"toggle('%s',%s);\" \t\t\t\tonmouseover=\"this.style.textD"
      "ecoration='underline'\" \t\t\t\tonmouseout=\"this.style.textDecoration='none'\" \t\t\t\tOnFocus=this.blur(); >%s</span>\n",
      v2,
      &v5,
      v3);
  return printf("</td>");
}

//----- (00018314) --------------------------------------------------------
int __fastcall sub_18314(int a1, int a2, const char *a3, int a4, int a5, int a6, int a7)
{
  const char *v7; // r4@1
  int v8; // r5@1
  int v9; // r6@1
  int v10; // r0@1
  void *v11; // r0@6
  void *v12; // r0@7
  void *v13; // r0@8
  const char *v14; // r0@8
  const char *v15; // r0@12
  int v16; // r0@16
  char v18; // [sp+8h] [bp-120h]@1
  char s; // [sp+88h] [bp-A0h]@1

  v7 = a3;
  v8 = a1;
  v9 = a4;
  snprintf(&s, 0x80u, "%s_%s_%d_td", a3, a4, a1);
  v10 = snprintf(&v18, 0x80u, "%s_%s", v7, v9);
  str(v10);
  if ( v8 )
  {
    if ( v8 == 2 || !strcmp(v7, "sysconf") )
    {
      sub_181D8(v8 - 1, 16);
    }
    else
    {
      sub_181D8(v8 - 2, 16);
      puts("<td>");
      v11 = sub_160D0();
      printf("<img src=\"%s\"></td>\n", v11);
    }
    puts("<td>");
    v12 = sub_160D0();
    printf("<img src=\"%s\"></td>\n", v12);
  }
  else
  {
    sub_181D8(1, 16);
  }
  puts("<td>");
  v13 = sub_160D0();
  printf("<img src=\"%s\"></td>\n", v13);
  printf("<td id=\"%s\">\n", &s);
  v14 = (const char *)puts("<span style=\"margin-left:4px;\">");
  if ( a7 )
    v14 = "<a href=\"timepro.cgi?tmenu=%s&smenu=%s&helpmenu=1&mainscreen=1\"";
  if ( !a7 )
    v14 = "<a href=\"timepro.cgi?tmenu=%s&smenu=%s\"";
  printf(v14, v7, v9);
  v15 = (const char *)printf(" target=\"main\"  OnFocus=this.blur(); ");
  if ( a7 )
    v15 = "onclick=\"toggle_detail_help('%s'); parent.menu_title.location.href='timepro.cgi?tmenu=%s&smenu=%s&helpmenu=1'\"; >\n";
  if ( !a7 )
    v15 = "onclick=\"toggle_detail('%s'); parent.menu_title.location.href='timepro.cgi?tmenu=%s&smenu=%s'\"; >\n";
  printf(v15, &s, "menu_titlebar", &v18);
  printf("%s", a5);
  v16 = printf("</span></td>");
  return etr(v16);
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);

//----- (000184D4) --------------------------------------------------------
int __fastcall sub_184D4(const char *a1)
{
  const char *v1; // r5@1
  int v2; // r0@1
  int v3; // r4@7
  int v4; // r0@9
  int v5; // r6@9
  const char *v6; // r0@13
  char *v7; // r0@16
  char *v8; // r0@17
  const char *v9; // r1@17
  char *v10; // r7@29
  int v11; // r6@34
  int v12; // r0@40
  int v13; // r0@40
  const char *v14; // r7@40
  void *v15; // r0@42
  int v16; // r0@42
  char *v17; // r0@46
  bool v18; // zf@47
  const char *v19; // r1@47
  int v20; // r0@50
  int v21; // r0@50
  int v22; // r0@50
  unsigned int v23; // r0@51
  int v24; // r4@52
  int v25; // r0@53
  char dest[512]; // [sp+8h] [bp-270h]@3
  char v28; // [sp+208h] [bp-70h]@49
  char v29; // [sp+21Ch] [bp-5Ch]@15
  unsigned __int8 v30; // [sp+230h] [bp-48h]@15
  char s1; // [sp+244h] [bp-34h]@1
  char v32; // [sp+254h] [bp-24h]@1

  v1 = a1;
  get_wan_hw_ifname(a1, &v32);
  get_wan_type(v1, &s1);
  v2 = strcmp(v1, "wan1");
  if ( !v2 )
    v2 = print_start_content_table(0);
  str(v2);
  print_item_desc("인터넷 연결 상태");
  strcpy(dest, "");
  if ( wireless_get_wwan_enable(0) )
    strcpy(dest, "<span class=warning_string>무선WAN</span> - ");
  if ( !strcmp(&s1, "pppoe") || !strcmp(&s1, "pptp") )
  {
    v3 = get_idle_timeout(&v32);
    if ( v3 || !get_wansetup_status(v1) )
    {
      v3 = get_wansetup_status(v1);
      if ( v3 )
      {
        strcat(dest, "인터넷 연결 시도중..");
        v3 = 0;
        goto LABEL_34;
      }
      v8 = dest;
      v9 = "관리자에의해 중지됨";
      goto LABEL_33;
    }
    v4 = get_pppoe_status(v1);
    v5 = v4;
    if ( !v4 )
    {
      strcat(dest, "인터넷 연결 중");
      v3 = v5;
      goto LABEL_34;
    }
    if ( v4 == 4 )
    {
      if ( !strcmp(v1, "wan2") )
        v6 = "ppp2";
      else
        v6 = "ppp1";
      get_ifconfig(v6, &v30, &v29);
      v3 = v30;
      if ( v30 )
      {
        v7 = dest;
LABEL_26:
        v3 = 1;
        strcat(v7, "인터넷에 정상적으로 연결됨");
        goto LABEL_34;
      }
      v8 = dest;
      v9 = "IP를 받는 중";
      goto LABEL_33;
    }
    if ( v4 == 6 )
    {
      v8 = dest;
      v9 = "잘못된 계정/암호";
LABEL_33:
      strcat(v8, v9);
      goto LABEL_34;
    }
  }
  else
  {
    get_ifconfig(&v32, &v30, &v29);
    v3 = v30;
    if ( v30 )
    {
      v7 = dest;
      goto LABEL_26;
    }
    if ( !get_wansetup_status(v1) )
    {
      strcat(dest, "관리자에의해 중지됨");
      v3 = 0;
      goto LABEL_34;
    }
    v10 = &dest[strlen(dest)];
    strcpy(v10, "인터넷 연결 시도중..");
    if ( istatus_get_intvalue_direct("lanwan_samenetwork") == 1 )
    {
      sprintf(
        v10 + 28,
        "<br><br><b>내부 네트워크와 동일한 대역의 IP주소가 검출되었습니다.<br><span class=movetoma"
        "in><a href=\"%s\"><U>[ 내부 네트워크 설정 ]</U></a></span> 에서 내부 네트워크의 IP주소를 변"
        "경 하십시오</b><br><br>",
        "JavaScript:MovePagetoMain('netconf','lansetup');");
      goto LABEL_34;
    }
    if ( istatus_get_intvalue_direct("privateip") == 1 )
    {
      v9 = " - 사설 IP주소 검출됨";
      v8 = dest;
      goto LABEL_33;
    }
  }
LABEL_34:
  v11 = get_wan_link(v1);
  if ( get_usb_tethering_status(v11) )
  {
    v11 = 1;
  }
  else if ( !v11 )
  {
    strcpy(dest, "");
    if ( wireless_get_wwan_enable(0) )
      strcpy(dest, "<span class=warning_string>무선WAN</span> - ");
    strcat(dest, "WAN포트 연결안됨");
  }
  puts("<td class=item_td colspan=3 >");
  printf("%s", dest);
  v12 = puts("</td>");
  v13 = etr(v12);
  str(v13);
  v14 = "gray_text";
  print_item_desc("인터넷 연결 방식");
  puts("<td class=item_td>");
  if ( v11 )
    v14 = "item_text";
  v15 = sub_1B2A8(&s1);
  v16 = printf("<span class=%s>%s ", v14, v15);
  if ( get_usb_tethering_status(v16) )
    printf("(USB테더링사용중)");
  printf("</span>");
  puts("</td>");
  print_item_desc("<b>외부 IP 주소</b>");
  puts("<td class=\"item_td\">");
  if ( !strcmp(&s1, "pppoe") || !strcmp(&s1, "pptp") )
  {
    v18 = strcmp(v1, "wan2") == 0;
    v19 = "ppp1";
    if ( v18 )
      v19 = "ppp2";
    sf_strncpy(&v28, v19, 20);
    v17 = &v28;
  }
  else
  {
    v17 = &v32;
  }
  get_ifconfig(v17, &v30, &v29);
  printf("<span class=%s><b>%s</b></span>");
  v20 = puts("</td>");
  v21 = etr(v20);
  str(v21);
  print_item_desc("인터넷 연결 시간");
  v22 = puts("<td colspan=3 class=item_td>");
  if ( v3 )
  {
    v24 = get_system_running_time(v22);
    v23 = v24 - get_internet_connected_time(v1);
  }
  else
  {
    v23 = 0;
  }
  sub_14E00(v23, (int)dest, 512);
  printf("<span class=%s>%s</span>");
  v25 = puts("</td>");
  return etr(v25);
}
// 101CC: using guessed type int __fastcall get_wansetup_status(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10334: using guessed type int __fastcall get_system_running_time(_DWORD);
// 10340: using guessed type int __fastcall get_wan_type(_DWORD, _DWORD);
// 10940: using guessed type int __fastcall get_idle_timeout(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10AB4: using guessed type int __fastcall get_wan_link(_DWORD);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11648: using guessed type int __fastcall wireless_get_wwan_enable(_DWORD);
// 11978: using guessed type int __cdecl get_usb_tethering_status(_DWORD);
// 119E4: using guessed type int __fastcall get_internet_connected_time(_DWORD);
// 11BAC: using guessed type int __fastcall get_pppoe_status(_DWORD);
// 184D4: using guessed type char dest[512];

//----- (000189D4) --------------------------------------------------------
int __fastcall sub_189D4(int a1)
{
  int v1; // r5@1
  int v2; // r0@1
  int v3; // r0@1
  const char *v4; // r0@2
  int v5; // r0@6
  int v6; // r0@6
  int v7; // r0@6
  char v9; // [sp+8h] [bp-3F0h]@6
  char s; // [sp+18h] [bp-3E0h]@6
  char v11; // [sp+2Ch] [bp-3CCh]@6
  char v12; // [sp+3C0h] [bp-38h]@1
  char v13; // [sp+3D4h] [bp-24h]@1

  v1 = dhcpd_get_op(a1);
  str(v1);
  print_item_desc("내부 IP주소");
  puts("<td class=item_td colspan=3>");
  get_ifconfig("br0", &v13, &v12);
  puts(&v13);
  v2 = puts("</td>");
  v3 = etr(v2);
  str(v3);
  print_item_desc("DHCP 서버 상태");
  printf("<td class=\"item_td\" colspan=3>");
  if ( v1 )
  {
    if ( get_dhcp_auto_detect_status("br0") )
      v4 = " 중단됨(내부네트워크에서 DHCP서버 검색)";
    else
      v4 = "DHCP 서버 동작중";
  }
  else
  {
    v4 = "DHCP 서버 중지됨";
  }
  printf(v4);
  v5 = puts("</td>");
  v6 = etr(v5);
  str(v6);
  print_item_desc("동적 IP 할당 범위");
  puts("<td class=\"item_td\" colspan=3 >");
  dhcpd_read_config(&v9);
  puts(&s);
  printf(" - ");
  print_nbsp(1);
  puts(&v11);
  v7 = puts("</td>");
  return etr(v7);
}
// 10754: using guessed type int __fastcall get_dhcp_auto_detect_status(_DWORD);
// 10988: using guessed type int __fastcall dhcpd_get_op(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);

//----- (00018B20) --------------------------------------------------------
int __fastcall sub_18B20(int a1)
{
  int v1; // r5@1
  int v2; // r4@1
  int v3; // r0@1
  const char *v4; // r0@2
  int v5; // r0@7
  const char *v6; // r0@8
  const char *v7; // r1@8
  const char *v8; // r0@18
  const char *v9; // r1@18
  int v10; // r0@22
  int v11; // r0@22
  void *v12; // r0@22
  int v13; // r0@22
  int v14; // r0@22
  const char *v15; // r0@24
  const char *v16; // r1@24
  int v17; // r0@28
  int v19; // [sp+8h] [bp-580h]@1
  int v20; // [sp+Ch] [bp-57Ch]@22
  int v21; // [sp+ACh] [bp-4DCh]@17
  int v22; // [sp+1D8h] [bp-3B0h]@22

  v1 = a1;
  v2 = wireless_api_get_operation_mode();
  v3 = read_wireless_conf(&v19, v1);
  str(v3);
  print_item_desc("무선 동작 모드");
  puts("<td class=\"item_td\" colspan=3>");
  if ( v19 )
  {
    if ( !get_ifstatus(v1) )
    {
      v4 = (const char *)&unk_518CC;
      goto LABEL_21;
    }
    if ( !get_wifi_switch_status(0) )
    {
      v4 = "무선 스위치에 의해 꺼짐";
      goto LABEL_21;
    }
    v5 = printf("동작중");
    if ( v2 == 2 )
    {
      v6 = (const char *)&unk_64517;
      v7 = "무선WAN모드";
    }
    else if ( v2 )
    {
      if ( v2 != 1 )
      {
LABEL_17:
        if ( v21 )
        {
          v8 = " - %s ";
          v9 = "암호화 사용";
        }
        else
        {
          v8 = " - %s ";
          v9 = "암호화 사용하지 않음";
        }
        printf(v8, v9);
        goto LABEL_22;
      }
      v6 = " - %s ";
      v7 = "랜카드 모드";
    }
    else if ( wireless_api_get_mimo(v5) )
    {
      v6 = " - %s ";
      v7 = (const char *)&unk_55260;
    }
    else
    {
      v6 = " - %s ";
      v7 = "AP 모드";
    }
    printf(v6, v7);
    goto LABEL_17;
  }
  v4 = "중단됨";
LABEL_21:
  printf(v4);
LABEL_22:
  v10 = puts("</td>");
  v11 = etr(v10);
  str(v11);
  print_item_desc("네트워크 이름(SSID)");
  puts("<td class=\"item_td\" colspan=3>");
  v12 = sub_15F34((const char *)&v20);
  printf("%s", v12);
  v13 = puts("</td>");
  v14 = etr(v13);
  str(v14);
  print_item_desc("멀티 브리지 정보");
  puts("<td class=\"item_td\" colspan=3>");
  if ( v22 )
  {
    printf("동작중");
    if ( v19 )
    {
      v15 = "- %s\n";
      v16 = "AP 기능 사용";
    }
    else
    {
      v15 = "- %s\n";
      v16 = "AP 기능 사용 중지";
    }
    printf(v15, v16);
  }
  else
  {
    printf("중단됨");
  }
  v17 = puts("</td>");
  return etr(v17);
}
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11000: using guessed type int __fastcall wireless_api_get_mimo(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11474: using guessed type int __fastcall get_wifi_switch_status(_DWORD);
// 11A5C: using guessed type int wireless_api_get_operation_mode(void);
// 11B70: using guessed type int __fastcall get_ifstatus(_DWORD);

//----- (00018D40) --------------------------------------------------------
int __fastcall sub_18D40(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r1@1
  int v5; // r2@1
  int v6; // r5@1
  int v7; // r0@4

  v3 = get_remote_mgmt_port(a1, a2, a3);
  v6 = get_remote_mgmt_flag(v3, v4, v5);
  str(v6);
  print_item_desc("원격 관리 정보");
  puts("<td class=item_td colspan=3>");
  if ( v6 )
    printf("%d번 원격 관리 포트 사용중", v3);
  else
    puts("원격 관리 포트가 설정되어 있지 않음");
  printf("<br>");
  printf(
    "<span class=movetomain><a href=\"%s\"><U>[ 공유기 접속 관리 ]</U></a></span> 에서 설정을 변경할 수 있습니다.\n",
    "JavaScript:MovePagetoMain('firewallconf','accesslist');");
  v7 = printf("</td>");
  return etr(v7);
}
// 106A0: using guessed type int __cdecl get_remote_mgmt_port(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 1145C: using guessed type int __cdecl get_remote_mgmt_flag(_DWORD, _DWORD, _DWORD);

//----- (00018DE0) --------------------------------------------------------
int __fastcall sub_18DE0(int a1)
{
  int v1; // r0@1
  const char *v2; // r4@1
  int v3; // r0@1

  str(a1);
  v1 = print_item_desc("현재 펌웨어 버전");
  v2 = (const char *)get_firmware_version2(v1);
  puts("<td class=item_td colspan=3>");
  puts(v2);
  v3 = printf("</td>");
  return etr(v3);
}
// 10670: using guessed type int __fastcall get_firmware_version2(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);

//----- (00018E38) --------------------------------------------------------
int sub_18E38()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r1@1
  int v3; // r2@1
  int v4; // r0@1
  int v5; // r0@1
  unsigned int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  char v10; // [sp+8h] [bp-108h]@1

  puts("<tr><td>");
  puts("<table class=menu_content_list_noline_table cellspacing=0px cellpadding=0px>");
  print_sub_title("인터넷 정보", 1);
  sub_184D4("wan1");
  print_sub_title("내부 네트워크 정보", 0);
  sub_189D4(0);
  print_sub_title("무선 정보(2.4GHz)", 0);
  sub_18B20((int)"eth2");
  print_sub_title("무선 정보(5GHz)", 0);
  sub_18B20((int)"eth1");
  v0 = print_sub_title("기타 정보", 0);
  v1 = sub_18DE0(v0);
  v4 = sub_18D40(v1, v2, v3);
  str(v4);
  print_item_desc("시스템 동작 시간");
  v5 = puts("<td class=item_td colspan=3>");
  v6 = get_system_running_time(v5);
  sub_14E00(v6, (int)&v10, 256);
  printf("%s", &v10);
  v7 = printf("</td>");
  v8 = etr(v7);
  return print_end_content_table(v8);
}
// 10334: using guessed type int __fastcall get_system_running_time(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00018F48) --------------------------------------------------------
int __fastcall sub_18F48(int a1)
{
  int v1; // r0@1

  print_start_main_table(a1);
  v1 = sub_18E38();
  return print_end_main_table(v1);
}
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);

//----- (00018F64) --------------------------------------------------------
int __fastcall sub_18F64(int a1, int a2, int a3, const char *a4)
{
  int v4; // r4@1
  const char *v5; // r5@1
  int v6; // r7@1
  int v7; // r6@1
  int *v8; // r5@1
  int v9; // r1@1
  signed int v10; // r4@1
  int v11; // t1@2
  signed int v12; // r3@2
  int *v14; // [sp+4h] [bp-3Ch]@1
  int *v15; // [sp+8h] [bp-38h]@1
  int *v16; // [sp+Ch] [bp-34h]@1
  int v17; // [sp+1Ch] [bp-24h]@1
  int v18; // [sp+20h] [bp-20h]@1
  int v19; // [sp+24h] [bp-1Ch]@1

  v4 = a1;
  v5 = a4;
  v6 = a2;
  v7 = a3;
  puts("<script>");
  v14 = &v17;
  v15 = &v18;
  v16 = &v19;
  sscanf(v5, "%02X-%02X-%02X-%02X-%02X-%02X");
  v8 = (int *)&v16;
  v9 = v4;
  v10 = 1;
  printf("function SelectMacFromPopup_%d()\n", v9);
  puts("{");
  do
  {
    v11 = v8[1];
    ++v8;
    v12 = v10++;
    printf("\tparent.opener.self.document.%s.%s%d.value = '%02X'; ", v6, v7, v12, v11, v14, v15, v16);
  }
  while ( v10 != 7 );
  puts("self.close();");
  puts("}");
  return puts("</script>");
}

//----- (0001903C) --------------------------------------------------------
void __fastcall sub_1903C(int a1)
{
  int v1; // r4@1
  void *v2; // r0@1
  void *v3; // r10@1
  void *v4; // r8@1
  int v5; // r4@1
  int v6; // r6@1
  int v7; // r0@1
  int v8; // r0@3
  int v9; // r0@4
  int v10; // r0@5
  int v11; // r0@9
  int v12; // [sp+Ch] [bp-124h]@1
  char v13; // [sp+10h] [bp-120h]@5
  char v14; // [sp+110h] [bp-20h]@1
  char v15; // [sp+130h] [bp+0h]@1

  v1 = a1;
  get_value(a1, "formname", &v14, 32);
  get_value(v1, "macprefix", &v15, 16);
  v2 = malloc(0xBC00u);
  v3 = v2;
  v4 = v2;
  memset(v2, 0, 0xBC00u);
  v5 = 0;
  v12 = get_hostinfo_from_arp("br0", 256, v3);
  v6 = 0;
  v7 = print_start_content_table(v12);
  while ( v6 < v12 )
  {
    v7 = strcmp((const char *)v4 + 148, "00:00:00:00:00:00");
    if ( v7 )
    {
      v8 = convert_mac((char *)v4 + 148);
      if ( !v5 )
      {
        str(v8);
        print_item_desc("선택할 MAC 주소");
        v9 = print_item_desc("사용되고 있는 IP 주소");
        v8 = etr(v9);
      }
      str(v8);
      ++v5;
      puts("<td class=\"item_td\">");
      sub_18F64(v6, (int)&v14, (int)&v15, (const char *)v4 + 148);
      snprintf(&v13, 0x100u, "<a href=\"#\" onclick=\"SelectMacFromPopup_%d();\">%s</a>", v6, (char *)v4 + 148);
      puts(&v13);
      puts("</td>");
      puts("<td class=\"item_leftline_td\">");
      puts((const char *)v4 + 128);
      v10 = puts("</td>");
      v7 = etr(v10);
    }
    ++v6;
    v4 = (char *)v4 + 188;
  }
  if ( !v5 )
  {
    str(v7);
    puts("<td class=\"item_td\" colspan=2>");
    v11 = puts("검색된 MAC 주소가 없습니다. ");
    v7 = etr(v11);
  }
  print_end_content_table(v7);
  printf("</table>");
  puts("</br>");
  free(v3);
}
// 1040C: using guessed type int __fastcall get_hostinfo_from_arp(_DWORD, _DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00019220) --------------------------------------------------------
int __fastcall sub_19220(int a1)
{
  int v1; // r6@1
  int v3; // r5@3
  int v4; // r7@3
  int v5; // r1@3
  int v6; // r2@3
  int v7; // r10@3
  int v8; // r0@4
  int v9; // r0@6
  char *v10; // r0@7
  const char *v11; // r2@7
  char *v12; // r3@7
  int v13; // r0@9
  const char *v14; // r0@16
  const char *v15; // r1@16
  char *v16; // r0@21
  const char *v17; // r2@21
  int v18; // r0@35
  int v19; // r0@35
  int v20; // r0@36
  int v21; // r0@37
  int v22; // r0@37
  int v23; // r0@37
  int v24; // r0@37
  int v25; // r0@44
  int v26; // r0@44
  char *v27; // [sp+0h] [bp-2B0h]@7
  char s; // [sp+8h] [bp-2A8h]@7
  char v29; // [sp+208h] [bp-A8h]@38
  char v30; // [sp+228h] [bp-88h]@4
  char s1; // [sp+248h] [bp-68h]@1
  char v32; // [sp+268h] [bp-48h]@5
  char v33; // [sp+27Ch] [bp-34h]@4

  v1 = a1;
  if ( get_value(a1, "wizard", &s1, 32) )
    return sub_46C08(v1);
  v3 = hwinfo_get_reboot_duration(0);
  v4 = check_remote_connection();
  v7 = get_remote_mgmt_port(v4, v5, v6);
  if ( v4 )
  {
    get_wan_ip("wan1", &v33);
    v8 = snprintf(&v30, 0x20u, "%s:%d", &v33, v7);
  }
  else
  {
    get_ifconfig("br0", &v33, &v32);
    v8 = sf_strncpy(&v30, &v33, 32);
  }
  print_start_main_table(v8);
  v9 = printf((const char *)&unk_555C0);
  str(v9);
  printf("<td align=left>");
  get_value(v1, "commit", &s1, 32);
  if ( strcmp(&s1, "default") )
  {
    if ( !strcmp(&s1, "lanip_chg") )
    {
      v3 += 30;
      v13 = printf("%s", "내부IP가 변경되어, ");
      if ( !v4 )
      {
        get_ip_value(v1, "ip", &v33);
        v13 = sf_strncpy(&v30, &v33, 32);
      }
      s = 0;
      if ( get_csrf_op(v13) )
        goto LABEL_35;
      v11 = "http://%s/cgi-bin/timepro.cgi?tmenu=RefreshOpener&ip=%s";
      v27 = &v33;
      v10 = &s;
      v12 = &v30;
      goto LABEL_13;
    }
    if ( strcmp(&s1, "reboot") )
    {
      if ( !strcmp(&s1, "upnp") )
      {
        snprintf(&s, 0x200u, "timepro.cgi?tmenu=sysconf&smenu=misc");
        v14 = "%s";
        v15 = "UPNP 설정이 변경되어, ";
LABEL_19:
        printf(v14, v15);
        goto LABEL_35;
      }
      if ( !strcmp(&s1, "usb_mode") )
      {
        snprintf(&s, 0x200u, "timepro.cgi?tmenu=sysconf&smenu=misc");
        v14 = "%s";
        v15 = "USB모드가 변경되어";
        goto LABEL_19;
      }
      if ( !strcmp(&s1, "nat") )
      {
        printf("%s", "인터넷 공유 기능 동작이 변경되어, ");
        v16 = &s;
        v17 = (const char *)&unk_5572C;
LABEL_34:
        snprintf(v16, 0x200u, v17);
        goto LABEL_35;
      }
      if ( !strcmp(&s1, "wirelessreboot") )
      {
        printf("%s", "무선 설정이 변경되어,");
        v16 = &s;
        v17 = (const char *)&unk_55785;
        goto LABEL_34;
      }
      if ( !strcmp(&s1, "twinip") )
      {
        printf("%s", "Twin IP 설정을 위해, ");
        v16 = &s;
        v17 = "timepro.cgi?tmenu=natrouterconf&smenu=twinipdmz";
        goto LABEL_34;
      }
      if ( !strcmp(&s1, "pptpvpn") )
      {
        printf("%s", "VPN설정을 변경하여 ");
        v16 = &s;
        v17 = (const char *)&unk_5581B;
        goto LABEL_34;
      }
      if ( !strcmp(&s1, "qos") )
      {
        printf("%s", "QOS설정을 변경하여 ");
        v16 = &s;
        v17 = "timepro.cgi?tmenu=trafficconf&smenu=qos";
        goto LABEL_34;
      }
      if ( !strcmp(&s1, "igmp") )
      {
        printf("%s", "IPTV 설정을 변경하여 ");
        v16 = &s;
        v17 = "timepro.cgi?tmenu=expertconf&smenu=iptv";
        goto LABEL_34;
      }
      if ( strcmp(&s1, "srvnet") )
        goto LABEL_35;
    }
    v17 = "timepro.cgi?tmenu=sysconf&smenu=misc";
    v16 = &s;
    goto LABEL_34;
  }
  printf("%s", "설정이 초기화된 후, ");
  hwinfo_get_default_ip(&v33);
  sf_strncpy(&v30, &v33, 32);
  v27 = &v33;
  v10 = &s;
  v11 = "http://%s/cgi-bin/timepro.cgi?tmenu=RefreshOpener&ip=%s";
  v12 = &v30;
LABEL_13:
  snprintf(v10, 0x200u, v11, v12, v27);
LABEL_35:
  v18 = printf("공유기가 다시 시작되고 있습니다.");
  v19 = br(v18);
  if ( get_csrf_op(v19) )
  {
    v20 = printf("%s", "재시작이 완료된 후, 관리도구 페이지를 재접속 하십시오.");
    br(v20);
  }
  printf("%s", "잠시만 기다리십시오.");
  v21 = printf("</td>");
  etr(v21);
  v22 = print_blank_line(1, 5);
  str(v22);
  printf("<td>");
  print_html_progress_bar(v3);
  v23 = printf("</td>");
  etr(v23);
  v24 = printf("</table>");
  print_end_main_table(v24);
  if ( !strcmp(&s1, "default") || get_http_auth_method(&v29) && !strcmp(&v29, "session") )
  {
    if ( strcmp(&s1, "lanip_chg") )
    {
      snprintf(&s, 0x200u, "%s", &v30);
      puts("<script>");
      printf("setTimeout(\"RefreshOpener('%s');\",1000*%d);\n", &s, v3);
      puts("</script>");
    }
  }
  else if ( s )
  {
    printf("<meta http-equiv=refresh content=\"%d; URL=%s\">\n", v3, &s);
  }
  v25 = syslog_msg(1, "관리자가 시스템을 재시작함");
  v26 = syslog_save(v25);
  return send_system_reboot_signal(v26);
}
// 10088: using guessed type int __fastcall syslog_save(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 10598: using guessed type int __fastcall hwinfo_get_reboot_duration(_DWORD);
// 10688: using guessed type int __fastcall send_system_reboot_signal(_DWORD);
// 106A0: using guessed type int __cdecl get_remote_mgmt_port(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10D3C: using guessed type int __fastcall hwinfo_get_default_ip(_DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10FB8: using guessed type int __fastcall get_csrf_op(_DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 110A8: using guessed type int __fastcall print_html_progress_bar(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11618: using guessed type int check_remote_connection(void);
// 46C08: using guessed type int __fastcall sub_46C08(_DWORD);

//----- (0001979C) --------------------------------------------------------
int __fastcall sub_1979C(int a1)
{
  int v1; // r6@1
  int v2; // r0@1
  const char *v3; // r5@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  const char *v7; // r0@5
  const char *v8; // r1@5
  int v9; // r0@7
  int v10; // r0@10
  int v11; // r0@10
  int v12; // r0@10
  int v13; // r0@10
  int v14; // r0@10
  int v15; // r0@10
  int v16; // r0@10
  int v17; // r0@10
  int v19; // [sp+0h] [bp-230h]@5
  char v20; // [sp+200h] [bp-30h]@1

  v1 = a1;
  v2 = hwinfo_get_reboot_duration(a1);
  v3 = (const char *)v2;
  v4 = print_start_main_table(v2);
  v5 = print_start_content_table(v4);
  str(v5);
  v6 = printf("<td>");
  br(v6);
  strcpy(&v20, "");
  get_value_post(v1, "commit", &v20, 32);
  if ( !strcmp(&v20, "restore") )
  {
    if ( istatus_get_value_direct("cfgrestore", &v20) == -1 )
      printf("설정 복구파일이 손상되어,");
    else
      printf("%s", "설정이 정상적으로 복구된 후,");
    printf("공유기가 다시 시작되고 있습니다.");
    istatus_remove_status_tag("cfgrestore");
    snprintf((char *)&v19, 0x200u, "timepro.cgi?tmenu=sysconf&smenu=configmgmt");
    v7 = "<meta http-equiv=refresh content=\"%d; URL=JavaScript: RestoreClose()\">\n";
    v8 = v3;
    goto LABEL_9;
  }
  if ( strcmp(&v20, "pptpvpn") )
  {
    printf("공유기가 다시 시작되고 있습니다.");
    v7 = "%s";
    v8 = "설정 복구된 내부 IP 주소로 다시 접속하셔야 합니다.";
LABEL_9:
    v9 = printf(v7, v8);
    goto LABEL_10;
  }
  printf("%s", "VPN설정을 변경하여 ");
  printf("공유기가 다시 시작되고 있습니다.");
  snprintf((char *)&v19, 0x200u, (const char *)&unk_5581B);
  v9 = printf("<meta http-equiv=refresh content=\"%d; URL=%s\">\n", v3, &v19);
LABEL_10:
  v10 = br(v9);
  br(v10);
  v11 = printf("</td>");
  v12 = etr(v11);
  str(v12);
  printf("<td>");
  print_html_progress_bar(v3);
  v13 = printf("</td>");
  v14 = etr(v13);
  v15 = print_end_content_table(v14);
  print_end_main_table(v15);
  v16 = syslog_msg(1, "관리자가 시스템을 재시작함");
  v17 = syslog_save(v16);
  return send_system_reboot_signal(v17);
}
// 10088: using guessed type int __fastcall syslog_save(_DWORD);
// 10598: using guessed type int __fastcall hwinfo_get_reboot_duration(_DWORD);
// 10628: using guessed type int __fastcall istatus_get_value_direct(_DWORD, _DWORD);
// 10688: using guessed type int __fastcall send_system_reboot_signal(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 110A8: using guessed type int __fastcall print_html_progress_bar(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11C18: using guessed type int __fastcall istatus_remove_status_tag(_DWORD);

//----- (00019964) --------------------------------------------------------
int __fastcall sub_19964(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  int v3; // r0@14
  int v4; // r0@17
  int v5; // r0@20
  char v6; // [sp+0h] [bp-158h]@4
  char dest; // [sp+80h] [bp-D8h]@4
  char v8; // [sp+100h] [bp-58h]@10
  char v9; // [sp+120h] [bp-38h]@1

  v1 = a1;
  result = get_value_post(a1, "act", &v9, 31);
  if ( !result )
    return result;
  if ( strcmp(&v9, "save") )
  {
    if ( strcmp(&v9, (const char *)&unk_55B27) )
    {
LABEL_21:
      puts("<script>");
      puts("function GotoLoginPage(method)\n\t\t{\n\t\t\tif(method == 'session')\n\t\t\t\ttop.location.href='/sess-bin/login_session.cgi?logout=1';\n\t\t\telse if(method == 'basic')\n\t\t\t\ttop.location.href='/login/login.cgi';\n\t\t}");
      strcpy(&v8, "");
      get_http_auth_method(&v8);
      if ( v8 )
        printf("setTimeout(\"GotoLoginPage('%s')\", 4000);\n", &v8);
      puts("</script>");
      return 1;
    }
    strcpy(&v8, "");
    if ( get_value_post(v1, "http_auth", &v8, 15) )
    {
      set_http_auth_method(&v8);
      if ( !strcmp(&v8, "session") )
      {
        strcpy(&v6, "");
        strcpy(&dest, "");
        if ( get_value_post(v1, "http_session_timeout", &dest, 15) && dest )
        {
          v3 = atoi(&dest);
          httpcon_set_session_timeout(60 * v3);
        }
        v4 = get_value_post(v1, "use_captcha", &v6, 15) && !strcmp(&v6, "1");
        set_use_captcha_code(v4);
      }
    }
LABEL_20:
    v5 = syslog_msg(1, "관리자가 로그인 암호 변경");
    signal_save(v5);
    signal_start("httpd");
    goto LABEL_21;
  }
  result = sub_1633C(v1);
  if ( !result )
    return result;
  strcpy(&dest, "");
  strcpy(&v6, "");
  get_value_post(v1, "new_passwd", &dest, 127);
  get_value_post(v1, "new_login", &v6, 127);
  if ( check_unpermitted_chars(&v6) )
    return 0;
  if ( v6 || (result = (unsigned __int8)dest, dest) )
  {
    save_password(&v6, &dest);
    goto LABEL_20;
  }
  return result;
}
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 1058C: using guessed type int __fastcall set_http_auth_method(_DWORD);
// 10640: using guessed type int __fastcall save_password(_DWORD, _DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10AC0: using guessed type int __fastcall httpcon_set_session_timeout(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 115AC: using guessed type int __fastcall set_use_captcha_code(_DWORD);

//----- (00019BD8) --------------------------------------------------------
const char *__fastcall sub_19BD8(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  char *v3; // r0@6
  char *v4; // r0@10
  char *v5; // r0@14
  int v6; // r0@16
  char *v7; // r0@21
  char *v8; // r0@24
  int v9; // r0@26
  int v10; // r0@28
  int v11; // [sp+0h] [bp-90h]@4

  v1 = a1;
  result = (const char *)get_pvalue(a1, "act");
  if ( result )
  {
    if ( strcmp(result, "apply_email") )
      return 0;
    if ( !get_value(v1, "email", &v11, 128) || check_unpermitted_chars(&v11) )
      v3 = "";
    else
      v3 = (char *)&v11;
    set_admin_email(v3);
    if ( !get_value(v1, "smtp", &v11, 128) || check_unpermitted_chars(&v11) )
      v4 = "";
    else
      v4 = (char *)&v11;
    set_smtp_server(v4);
    if ( !get_value(v1, &unk_55C62, &v11, 128) || check_unpermitted_chars(&v11) )
      v5 = "";
    else
      v5 = (char *)&v11;
    set_send_email(v5);
    v6 = get_value(v1, "smtp_auth", &v11, 128);
    if ( v6 )
    {
      if ( !strcmp((const char *)&v11, "on") )
      {
        set_smtp_auth(1);
        if ( !get_value(v1, "account", &v11, 128) || check_unpermitted_chars(&v11) )
          v7 = "";
        else
          v7 = (char *)&v11;
        set_smtp_account(v7);
        if ( get_value(v1, "smtp_pass", &v11, 128) )
          v8 = (char *)&v11;
        else
          v8 = "";
        v9 = set_smtp_password(v8);
        goto LABEL_28;
      }
      v6 = 0;
    }
    v9 = set_smtp_auth(v6);
LABEL_28:
    v10 = signal_update(v9);
    signal_save(v10);
    result = (const char *)1;
  }
  return result;
}
// 1013C: using guessed type int __fastcall set_smtp_password(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10820: using guessed type int __fastcall set_admin_email(_DWORD);
// 108D4: using guessed type int __fastcall set_smtp_account(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10E5C: using guessed type int __fastcall set_smtp_server(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11720: using guessed type int __fastcall set_smtp_auth(_DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11C54: using guessed type int __fastcall set_send_email(_DWORD);

//----- (00019D98) --------------------------------------------------------
int sub_19D98()
{
  int v0; // r0@1
  int v1; // r0@1
  char *v2; // r2@2
  const char *v3; // r2@5
  int v4; // r0@7
  int v5; // r0@7
  int v6; // r0@7
  int v7; // r0@7
  int v8; // r0@7
  int v9; // r0@7
  int v10; // r0@7
  int v11; // r0@7
  char v13; // [sp+8h] [bp-1D8h]@1
  char v14; // [sp+88h] [bp-158h]@1
  char v15; // [sp+108h] [bp-D8h]@1
  char v16; // [sp+148h] [bp-98h]@1
  char v17; // [sp+188h] [bp-58h]@7
  char v18; // [sp+1A8h] [bp-38h]@1

  get_id_password(&v16, &v14);
  get_default_id_password(&v15, &v13);
  hwinfo_get_language_postfix(&v18);
  print_sub_title("관리자 계정 및 설정", 1);
  puts("<form method=post action=timepro.cgi name=login_fm>");
  puts("<input type=hidden name=tmenu value=sysconf>");
  puts("<input type=hidden name=smenu value=login>");
  puts("<input type=hidden name=act value=>");
  v0 = puts("<input type=hidden name=captcha_file value=>");
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("현재 관리자 계정 및 암호");
  printf("<td class=item_td>");
  if ( v16 )
    v2 = &v16;
  else
    v2 = "설정되지 않음";
  printf((const char *)&unk_64515, "계정", v2);
  print_nbsp(5);
  if ( v14 )
    v3 = "설정됨";
  else
    v3 = "설정되지 않음";
  printf((const char *)&unk_64515, "암호", v3);
  v4 = printf("</td>");
  etr(v4);
  v5 = printf("<tr><td colspan=2 height=10></td></tr>");
  str(v5);
  print_item_desc("새로운 관리자 계정");
  v6 = puts("<td class=item_td><input type=text name=new_login maxlength=32 style=\"width:150\" value=></td>");
  v7 = etr(v6);
  str(v7);
  print_item_desc("새로운 관리자 암호");
  printf("<td class=item_td>");
  printf("<input type=password name=new_passwd style=\"width:150\" maxlength=32 value=>");
  printf("<input type=text name=new_passwd_text style=\"height:20px;display:none;ime-mode:disabled;width:150px;\" maxlength=32 value=>");
  printf(
    "<INPUT TYPE=checkbox NAME=password_view value=1 onclick=\"PasswordView(new_passwd,new_passwd_text,password_view);\" > %s",
    "암호보기");
  v8 = printf("</td>");
  etr(v8);
  get_http_auth_method(&v17);
  printf(
    "<input type=hidden name=default_captcha_desc value='%s'>\n",
    "보안문자(영문 소문자 5글자)를 입력하세요.");
  printf(
    "<TR><TD class=itemdesc_td>%s</TD><TD class=item_td><TABLE CELLPADDING=0 CELLSPACING=0 HEIGHT=72 >\n",
    "보안문자");
  printf(
    "<TR><TD COLSPAN=2><INPUT type=text name=captcha_code STYLE=\"width:255px; height:21px; color:#888888;\" value=\"%s\""
    " onfocus=\"FocusCaptcha(document.login_fm);\" onblur=\"BlurCaptcha(document.login_fm);\"></TD></TR>\n",
    "보안문자(영문 소문자 5글자)를 입력하세요.");
  printf("<TR><TD colspan=2 HEIGHT=5></TD></TR>");
  printf(
    "<TR style=\"font: normal normal normal 12px arial; color:#000000; border:#C6C9CC 1px solid; width:181px; height:21px"
    ";\"><TD WIDTH=25><IMG SRC=\"/images2/login_bt_refresh.%s.gif\" BORDER=0 ONCLICK=\"iframe_captcha.location.reload();\""
    " STYLE=\"cursor:pointer;\"></TD>\n",
    &v18);
  strcmp(&v17, "session");
  printf("<TD><IFRAME NAME=iframe_captcha ID=iframe_captcha SRC=\"/%s/captcha.cgi\" WIDTH=201 HEIGHT=70 FRAMEBORDER=no SCROLLING=no></IFRAME></TD></TR>\n");
  v9 = printf("</TABLE></TD></TR>");
  str(v9);
  puts("<td class=item_td align=right colspan=2>");
  v10 = puts("<input class=navi_bt type=button name=save VALUE=\" 적용 \" onclick=\"ApplyLogin()\"></td>");
  v11 = etr(v10);
  print_end_content_table(v11);
  return printf("</form>");
}
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 104F0: using guessed type int __fastcall hwinfo_get_language_postfix(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11A14: using guessed type int __fastcall get_id_password(_DWORD, _DWORD);
// 11C0C: using guessed type int __fastcall get_default_id_password(_DWORD, _DWORD);

//----- (0001A028) --------------------------------------------------------
int sub_1A028()
{
  signed int v0; // r4@2
  int v1; // r0@4
  int v2; // r0@4
  char *v3; // r1@5
  int v4; // r0@7
  char *v5; // r1@8
  int v6; // r0@10
  int v7; // r0@10
  int v8; // r0@10
  int v9; // r0@10
  int v10; // r0@10
  int v11; // r0@10
  char *v12; // r1@11
  int v13; // r0@13
  int v14; // r0@13
  int v15; // r0@13
  int v16; // r0@13
  char v18; // [sp+8h] [bp-F0h]@1
  char dest; // [sp+88h] [bp-70h]@1
  char v20; // [sp+C8h] [bp-30h]@4

  strcpy(&dest, "");
  strcpy(&v18, "");
  get_id_password(&dest, &v18);
  if ( dest )
    v0 = v18 == 0;
  else
    v0 = 1;
  print_sub_title("로그인 인증 방법 설정", 0);
  puts("<form method=post action=timepro.cgi name=session_fm>");
  puts("<input type=hidden name=tmenu value=sysconf>");
  puts("<input type=hidden name=smenu value=login>");
  puts("<input type=hidden name=act value=>");
  v1 = printf("<input type=hidden name=noid value=%d>\n", v0);
  print_start_content_table(v1);
  get_http_auth_method(&v20);
  v2 = printf("<input type=hidden name=prev_auth_method value=%s>\n", &v20);
  str(v2);
  print_item_desc("인증 방법");
  puts("<td class=item_td>");
  if ( !strcmp(&v20, "basic") )
    v3 = "checked";
  else
    v3 = "";
  v4 = printf("<input type=radio name=http_auth value=basic %s onclick=\"InitLogin();\"> %s\n", v3, "기본방식");
  br(v4);
  if ( !strcmp(&v20, "basic") )
    v5 = "";
  else
    v5 = "checked";
  printf("<input type=radio name=http_auth value=session %s onclick=\"InitLogin();\"> %s\n", v5, "세션방식");
  v6 = print_nbsp(5);
  br(v6);
  v7 = print_nbsp(10);
  v8 = httpcon_get_session_timeout(v7);
  v9 = sub_4EC48(v8, 60);
  v10 = printf(
          "<input type=text name=http_session_timeout value=%d size=3 maxlength=3> %s\n",
          v9,
          "분간 미사용시 자동 로그 아웃");
  br(v10);
  v11 = print_nbsp(10);
  if ( get_use_captcha_code(v11) )
    v12 = "checked";
  else
    v12 = "";
  printf("<input type=checkbox name=use_captcha %s value=1> %s\n", v12, "로그인시 문자열 입력(Captcha Code)");
  v13 = printf("</td>");
  v14 = etr(v13);
  str(v14);
  puts("<td class=item_td align=right colspan=2>");
  v15 = puts("<input class=navi_bt type=button name=save VALUE=\" 적용 \" onclick=\"ApplySession()\"></td>");
  v16 = etr(v15);
  print_end_content_table(v16);
  printf("</form>");
  puts("<script language=JavaScript>");
  puts("<!--");
  puts("InitLogin();");
  puts("-->");
  return printf("</script>");
}
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 10604: using guessed type int __fastcall get_use_captcha_code(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1169C: using guessed type int __fastcall httpcon_get_session_timeout(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11A14: using guessed type int __fastcall get_id_password(_DWORD, _DWORD);

//----- (0001A270) --------------------------------------------------------
int sub_1A270()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  char *v9; // r1@2
  int v10; // r0@4
  char *v11; // r1@5
  int v12; // r0@7
  int v13; // r0@7
  int v14; // r0@7
  int v15; // r0@7
  int v16; // r0@7
  int v17; // r0@7
  int v18; // r0@7
  int v19; // r0@7
  char v21; // [sp+8h] [bp-290h]@1
  char v22; // [sp+88h] [bp-210h]@7
  char v23; // [sp+108h] [bp-190h]@7
  char v24; // [sp+188h] [bp-110h]@1
  char v25; // [sp+208h] [bp-90h]@1

  print_sub_title("관리자 E-Mail 설정", 0);
  puts("<form method=get action=timepro.cgi name=email_fm>");
  puts("<input type=hidden name=tmenu value=sysconf>");
  puts("<input type=hidden name=smenu value=login>");
  v0 = puts("<input type=hidden name=act value=>");
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("관리자 E-Mail");
  get_admin_email(&v25);
  v2 = printf("<td class=item_td><input type=text name=email style=\"width:150\" maxlength=120 value=%s></td>\n", &v25);
  v3 = etr(v2);
  str(v3);
  print_item_desc("메일서버(SMTP)");
  get_smtp_server(&v24);
  v4 = printf("<td class=item_td><input type=text name=smtp style=\"width:150\" maxlength=120 value=%s></td>\n", &v24);
  v5 = etr(v4);
  str(v5);
  print_item_desc("보내는 E-Mail");
  get_send_email(&v21);
  v6 = printf(
         "<td class=item_td><input type=text name=send_email style=\"width:150\" maxlength=120 value=%s></td>\n",
         &v21);
  v7 = etr(v6);
  str(v7);
  print_item_desc("메일 서버 인증");
  v8 = puts("<td class=item_td colspan=2>");
  if ( get_smtp_auth(v8) )
    v9 = "checked";
  else
    v9 = "";
  printf("<input type=radio name=smtp_auth %s value=on onclick=\"ChangeAuth();\"> %s\n", v9, "사용함");
  v10 = print_nbsp(5);
  if ( get_smtp_auth(v10) )
    v11 = "";
  else
    v11 = "checked";
  printf("<input type=radio name=smtp_auth %s value=off onclick=\"ChangeAuth();\"> %s\n", v11, "사용하지 않음");
  v12 = printf("</td>");
  v13 = etr(v12);
  str(v13);
  print_item_desc(&unk_568FA);
  get_smtp_account(&v23);
  v14 = printf(
          "<td class=item_td><input type=text name=account style=\"width:150\" maxlength=120 value=\"%s\"></td>\n",
          &v23);
  v15 = etr(v14);
  str(v15);
  print_item_desc("암호 ");
  get_smtp_password(&v22);
  v16 = printf(
          "<td class=item_td><input type=password name=smtp_pass style=\"width:150\" maxlength=120 value=\"%s\"></td>\n",
          &v22);
  v17 = etr(v16);
  str(v17);
  puts("<td class=item_td align=right colspan=2>");
  v18 = puts((const char *)&unk_569E1);
  v19 = etr(v18);
  print_end_content_table(v19);
  puts("<script language=JavaScript>");
  puts("<!--");
  puts("ChangeAuth();");
  puts("-->");
  return printf("</script>");
}
// 10838: using guessed type int __fastcall get_smtp_auth(_DWORD);
// 1094C: using guessed type int __fastcall get_smtp_password(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 110B4: using guessed type int __fastcall get_smtp_account(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11810: using guessed type int __fastcall get_smtp_server(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11A38: using guessed type int __fastcall get_admin_email(_DWORD);
// 11B88: using guessed type int __fastcall get_send_email(_DWORD);

//----- (0001A564) --------------------------------------------------------
int __fastcall sub_1A564(int a1)
{
  const char *v1; // r0@1
  const char *v2; // r4@1
  const char *v3; // r5@6
  int v4; // r4@7
  int result; // r0@7
  signed int v6; // r0@8
  int v7; // r7@12
  int v8; // r0@12
  int v9; // r0@12
  int v10; // r6@12
  int v11; // r0@13
  int v12; // r5@15
  void *v13; // r0@18
  int v14; // r0@18
  int v15; // r6@18
  char *v16; // r4@18
  int v17; // r6@22
  void *v18; // r0@22
  int v19; // r0@22
  char *v20; // r4@22
  void *v21; // r0@26
  char *v22; // r4@26
  int v23; // r6@26
  int v24; // r0@26
  int v25; // r1@26
  int v26; // r6@26
  int v27; // r0@26
  char *v28; // r4@26
  int v29; // r6@30
  void *v30; // r0@30
  int v31; // r0@30
  char *v32; // r4@30
  void *v33; // r0@34
  int v34; // r0@34
  char *v35; // r4@34
  char *v36; // r4@34
  int v37; // r0@34
  signed int v38; // r0@34
  const char *v39; // r2@37
  char *v40; // r0@37
  const char *v41; // r3@37
  int v42; // r6@45
  int v43; // r8@46
  int v44; // r5@50
  int v45; // r0@50
  void *v46; // r0@52
  int v47; // r0@52
  int v48; // r0@55
  char *v49; // r4@55
  int v50; // r0@55
  int v51; // r5@57
  char dest[512]; // [sp+8h] [bp-4B8h]@18
  char s; // [sp+208h] [bp-2B8h]@13
  char v54; // [sp+3C8h] [bp-F8h]@34
  int v55; // [sp+448h] [bp-78h]@34
  int v56; // [sp+468h] [bp-58h]@34
  int v57; // [sp+488h] [bp-38h]@44

  v1 = (const char *)get_pvalue(a1, "act");
  v2 = v1;
  if ( !v1 )
    goto LABEL_12;
  if ( !strcmp(v1, "update") )
  {
    set_firmup_status(1);
    v1 = (const char *)signal_start("firmupui");
LABEL_12:
    v7 = hwinfo_get_firmup_duration(v1);
    printf("<html>");
    print_file("/home/httpd/js/common.js");
    print_file("/home/httpd/js/string.js");
    printf("<form method=get name=firmup_fm>");
    printf("<input type=hidden name=tmenu value=iframe_firmware_status>");
    printf("<input type=hidden name=act>");
    printf("</form>");
    v8 = puts("<script>");
    v9 = get_firmup_status(v8);
    v10 = v9;
    if ( v9 )
    {
      snprintf(&s, 0x20u, "firmup_counter_%d", v9);
      v11 = istatus_get_intvalue_direct(&s);
      if ( v11 == -1 )
        v11 = 0;
      v12 = v11 + 1;
      if ( v11 + 1 > 64 )
        v12 = 0;
      snprintf(&s, 0x20u, "firmup_counter_%d", v10);
      istatus_set_intvalue_direct(&s, v12);
      switch ( v10 )
      {
        case 1:
          v13 = sub_16094();
          v14 = snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v13);
          v15 = 0;
          v16 = &dest[v14] + snprintf(&dest[v14], 0x200u, " %s", "펌웨어 업그레이드 준비 중 ...");
          while ( v15 < v12 )
          {
            ++v15;
            v16 += snprintf(v16, 0x200u, ".");
          }
          puts("DisableRadio( parent.document.view_fm.firmup);");
          puts("HideObj( parent.document.getElementById('onlineupdate_bt'));");
          puts("ShowObj( parent.document.getElementById('cancel_bt'));");
          goto LABEL_53;
        case 2:
          v17 = 0;
          puts("DisableRadio( parent.document.view_fm.firmup);");
          v18 = sub_16094();
          v19 = snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v18);
          v20 = &dest[v19] + snprintf(&dest[v19], 0x200u, " %s", "펌웨어 버전 확인 중 ...");
          while ( v17 < v12 )
          {
            ++v17;
            v20 += snprintf(v20, 0x200u, ".");
          }
          goto LABEL_53;
        case 3:
          puts("DisableRadio( parent.document.view_fm.firmup);");
          puts("ShowObj( parent.document.getElementById('cancel_bt'));");
          v21 = sub_16094();
          v22 = &dest[snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v21)];
          v23 = hwinfo_get_max_firmware_size();
          v24 = get_filesize("/tmp/firmware");
          v25 = v23;
          v26 = 0;
          v27 = sub_4EC48(100 * v24, v25);
          v28 = &v22[snprintf(v22, 0x200u, " %s (%d %%) ", "펌웨어 다운로드 중", v27)];
          while ( v26 < v12 )
          {
            ++v26;
            v28 += snprintf(v28, 0x200u, ".");
          }
          goto LABEL_53;
        case 4:
          v29 = 0;
          puts("DisableRadio( parent.document.view_fm.firmup);");
          puts("HideObj( parent.document.getElementById('cancel_bt'));");
          v30 = sub_16094();
          v31 = snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v30);
          v32 = &dest[v31] + snprintf(&dest[v31], 0x200u, " %s", "다운로드 완료 후, 펌웨어 검사 중 ...");
          while ( v29 < v12 )
          {
            ++v29;
            v32 += snprintf(v32, 0x200u, ".");
          }
          goto LABEL_53;
        case 5:
          puts("DisableRadio( parent.document.view_fm.firmup);");
          puts("HideObj( parent.document.getElementById('cancel_bt'));");
          get_ifconfig("br0", &v56, &v55);
          snprintf(&v54, 0x80u, "http://%s", &v56);
          v33 = sub_16094();
          v34 = snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v33);
          v35 = &dest[v34] + snprintf(&dest[v34], 0x200u, " %s", "펌웨어 업데이트 중 ");
          v36 = &v35[snprintf(v35, 0x200u, "<span id=firmup_dot></span><br>")];
          v37 = snprintf(v36, 0x200u, "&nbsp;&nbsp;&nbsp;&nbsp;");
          snprintf(&v36[v37], 0x200u, "(%s <span id=firmup_duration>%d</span>%s)", &unk_56D46, v7, "초");
          printf("PrintRemainTime('firmup_duration',%d,'%s','');\n", v7, &v54);
          puts("PrintDot('firmup_dot',64,64);");
          v38 = 100;
          goto LABEL_40;
        case 6:
          strcpy(dest, "");
          goto LABEL_59;
        default:
          goto LABEL_59;
        case 10:
        case 14:
          puts("EnableRadio( parent.document.view_fm.firmup);");
          puts("ShowObj( parent.document.getElementById('onlineupdate_bt'));");
          puts("HideObj( parent.document.getElementById('cancel_bt'));");
          if ( v10 == 14 )
          {
            v39 = " %s";
            v40 = dest;
            v41 = "펌웨어 업데이트가  취소되었습니다.";
          }
          else
          {
            v39 = " %s";
            v40 = dest;
            v41 = "펌웨어 다운로드 실패";
          }
          break;
        case 11:
          v40 = dest;
          v39 = " %s";
          v41 = "다운로드 펌웨어가 유효하지 않아 업그레이드가 취소되었습니다.";
          break;
        case 12:
          v40 = dest;
          v39 = " %s";
          v41 = "업그레이드 가능한 펌웨어가 없습니다.";
          break;
        case 13:
          v40 = dest;
          v39 = " %s";
          v41 = "펌웨어 쓰기 실패.";
          break;
      }
      snprintf(v40, 0x200u, v39, v41);
      v38 = 0;
LABEL_40:
      set_firmup_status(v38);
LABEL_59:
      v42 = 0;
    }
    else if ( get_wan_ip("wan1", &v57) || (v42 = get_default_gateway("br0", &v57)) != 0 )
    {
      v44 = get_firmupcheck_status();
      get_si("pi", &s);
      v45 = snprintf(&v54, 0x80u, &s);
      switch ( v44 )
      {
        case 0:
          signal_start("firmupcheck");
          goto LABEL_52;
        case 1:
LABEL_52:
          v46 = sub_16094();
          v47 = snprintf(dest, 0x200u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\"> ", v46);
          snprintf(&dest[v47], 0x200u, "%s 의  최신 펌웨어를 검색하고 있습니다...", &v54);
LABEL_53:
          v42 = 1;
          break;
        default:
          goto LABEL_59;
        case 3:
          set_firmupcheck_status(0);
          v42 = get_firmupcheck_version(&v55);
          if ( v42 )
          {
            v48 = snprintf(
                    dest,
                    0x200u,
                    "온라인 검색을 통하여 최신 펌웨어 %s 가 검색되었습니다.",
                    &v55);
            v49 = &dest[v48];
            v50 = snprintf(&dest[v48], 0x200u, "<br>");
            snprintf(
              &v49[v50],
              0x200u,
              "[온라인 자동 업그레이드 실행] 버튼을 클릭하면 공유기를 최신 펌웨어로 업그"
              "이드 합니다.");
            puts("ShowObj( parent.document.getElementById('onlineupdate_bt'));");
            puts("HideObj( parent.document.getElementById('cancel_bt'));");
            goto LABEL_59;
          }
          snprintf(
            dest,
            0x200u,
            "공유기의 최신 펌웨어를 검색할 수 없습니다. <br>공유기의 인터넷 연결을 확인 후"
            " 다시 시도하여 주십시오.");
          break;
        case 4:
          v51 = get_firmware_version2(v45);
          set_firmupcheck_status(0);
          snprintf(dest, 0x200u, "현재 최신 펌웨어 %s 를 사용하고 있습니다.", v51);
          goto LABEL_59;
        case 5:
          set_firmupcheck_status(0);
          snprintf(
            dest,
            0x200u,
            "공유기의 최신 펌웨어를 검색할 수 없습니다. <br>공유기의 인터넷 연결을 확인 후"
            " 다시 시도하여 주십시오.");
          goto LABEL_59;
      }
    }
    else
    {
      v43 = snprintf(
              dest,
              0x200u,
              "[온라인 자동 업그레이드]를 수행하려면 공유기를 인터넷에 연결해야 합니다.<br>");
      if ( !get_wan_link("wan1") )
      {
        if ( get_default_gateway("br0", &v57) )
        {
          v42 = 0;
        }
        else
        {
          v42 = 0;
          snprintf(
            &dest[v43],
            0x200u,
            "<br>현재 순수AP모드로 사용중입니다.(WAN포트 연결되지 않음)<br>[네트워크 관리] - ["
            "내부 네트워크 설정]에서 내부 게이트웨이 및 내부 DNS주소 항목을 설정하여 주십시오.");
        }
      }
    }
    printf("if(parent.document.getElementById('firmware_status'))");
    printf("parent.document.getElementById('firmware_status').innerHTML = '%s';\n", dest);
    puts("</script>");
    if ( v42 == 1 )
      printf("<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=iframe_firmware_status\">");
    return printf("</html>");
  }
  if ( !strcmp(v2, "cancel") )
  {
    v1 = (const char *)system("/usr/bin/killall wget");
    goto LABEL_12;
  }
  v1 = (const char *)strcmp(v2, "status");
  v3 = v1;
  if ( v1 )
    goto LABEL_12;
  v4 = ((int (*)(void))get_firmup_status)();
  result = printf("Status:%d", v4);
  if ( v4 == 5 )
  {
    v6 = 100;
  }
  else
  {
    if ( v4 <= 9 )
      return result;
    v6 = (signed int)v3;
  }
  return set_firmup_status(v6);
}
// 10124: using guessed type int __fastcall get_si(_DWORD, _DWORD);
// 10184: using guessed type int __fastcall istatus_set_intvalue_direct(_DWORD, _DWORD);
// 10670: using guessed type int __fastcall get_firmware_version2(_DWORD);
// 1079C: using guessed type int __fastcall get_default_gateway(_DWORD, _DWORD);
// 10874: using guessed type int __fastcall get_firmup_status(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 1091C: using guessed type int hwinfo_get_max_firmware_size(void);
// 10970: using guessed type int __fastcall set_firmupcheck_status(_DWORD);
// 10AB4: using guessed type int __fastcall get_wan_link(_DWORD);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10C94: using guessed type int __fastcall get_filesize(_DWORD);
// 10DCC: using guessed type int __fastcall hwinfo_get_firmup_duration(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10ED4: using guessed type int get_firmupcheck_status(void);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 11564: using guessed type int __fastcall set_firmup_status(_DWORD);
// 11B34: using guessed type int __fastcall get_firmupcheck_version(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 1A564: using guessed type char dest[512];

//----- (0001B168) --------------------------------------------------------
int __fastcall sub_1B168(int a1)
{
  int v1; // r6@1
  int result; // r0@1
  bool v3; // zf@2
  const char *v4; // r1@2
  int v5; // r0@9
  char s; // [sp+Ch] [bp-184h]@5
  char dest; // [sp+10Ch] [bp-84h]@4
  char v8; // [sp+14Ch] [bp-44h]@1
  char v9; // [sp+16Ch] [bp-24h]@2

  v1 = a1;
  result = get_value(a1, "act", &v8, 32);
  if ( result )
  {
    get_value(v1, "wan", &v9, 20);
    v3 = strcmp(&v9, "wan2") == 0;
    v4 = "eth0";
    if ( v3 )
      v4 = "eth2";
    strcpy(&dest, v4);
    if ( !strcmp(&v8, "connect") )
    {
      set_wansetup_status(&v9, 1);
      snprintf(&s, 0x100u, "%s(%s)", "관리자가 인터넷을 연결함", &v9);
      syslog_msg(1, &s);
    }
    else
    {
      if ( strcmp(&v8, (const char *)&unk_57CFC) )
      {
LABEL_9:
        v5 = istatus_remove_status_tag("lanwan_samenetwork");
        return signal_update(v5);
      }
      snprintf(&s, 0x100u, "%s(%s)", "관리자가 인터넷을 해제함", &v9);
      syslog_msg(1, &s);
      set_wansetup_status(&v9, 0);
    }
    stop_wan(&v9);
    goto LABEL_9;
  }
  return result;
}
// 10F34: using guessed type int __fastcall stop_wan(_DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 116A8: using guessed type int __fastcall set_wansetup_status(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11C18: using guessed type int __fastcall istatus_remove_status_tag(_DWORD);

//----- (0001B2A8) --------------------------------------------------------
void *__fastcall sub_1B2A8(const char *a1)
{
  const char *v1; // r4@1
  char *v2; // r0@2
  const char *v3; // r1@2

  v1 = a1;
  if ( !strcmp(a1, "static") )
  {
    v2 = (char *)&unk_91658;
    v3 = "고정 IP 연결";
LABEL_7:
    strcpy(v2, v3);
    return &unk_91658;
  }
  if ( !strcmp(v1, "dynamic") )
  {
    v2 = (char *)&unk_91658;
    v3 = "동적 IP 연결";
    goto LABEL_7;
  }
  if ( !strcmp(v1, "pppoe") )
  {
    v2 = (char *)&unk_91658;
    v3 = "PPPoE 연결";
    goto LABEL_7;
  }
  return &unk_91658;
}

//----- (0001B328) --------------------------------------------------------
int sub_1B328()
{
  int v0; // r0@1
  char *v1; // r0@1
  int v2; // r4@5
  int v3; // r0@10
  int v4; // r5@10
  char *v5; // r5@13
  char *v6; // r0@14
  const char *v7; // r1@14
  char *v8; // r6@22
  int v9; // r7@29
  int v10; // r0@35
  int v11; // r0@35
  void *v12; // r0@35
  int v13; // r0@35
  int v14; // r0@37
  const char *v15; // r1@39
  char *v16; // r0@41
  int v17; // r0@41
  int v18; // r0@41
  int v19; // r0@41
  int v20; // r0@41
  int v21; // r0@41
  int v22; // r0@41
  int v23; // r0@41
  int v24; // r0@41
  int v25; // r0@41
  int v26; // r0@41
  int v27; // r0@43
  int v28; // r0@43
  int v29; // r0@44
  const char *v30; // r0@49
  int v31; // r0@53
  int v32; // r0@56
  int result; // r0@57
  char dest[512]; // [sp+8h] [bp-300h]@1
  char v35; // [sp+208h] [bp-100h]@41
  char v36; // [sp+228h] [bp-E0h]@41
  char v37; // [sp+248h] [bp-C0h]@41
  char v38; // [sp+268h] [bp-A0h]@41
  char v39; // [sp+27Ch] [bp-8Ch]@41
  char v40; // [sp+290h] [bp-78h]@3
  char v41; // [sp+2A4h] [bp-64h]@3
  unsigned __int8 v42; // [sp+2B8h] [bp-50h]@3
  char s1; // [sp+2CCh] [bp-3Ch]@1
  char v44; // [sp+2DCh] [bp-2Ch]@1

  get_wan_type("wan1", &s1);
  v0 = get_wan_hw_ifname("wan1", &v44);
  print_start_content_table(v0);
  strcpy(dest, "");
  v1 = (char *)wireless_get_wwan_enable(0);
  if ( v1 )
    v1 = strcpy(dest, "<span class=warning_string>무선WAN</span> - ");
  str(v1);
  print_item_desc("연결 상태");
  get_wan_ipinfo("wan1", &v42, &v41, &v40);
  if ( !strcmp(&s1, "pppoe") )
    sf_strncpy(&v40, &v42, 20);
  v2 = get_wansetup_status("wan1");
  if ( !v2 )
  {
    v7 = "관리자에의해 중지됨";
    v6 = dest;
    goto LABEL_28;
  }
  if ( !strcmp(&s1, "pppoe") || !strcmp(&s1, "pptp") )
  {
    v2 = get_idle_timeout(&v44);
    if ( v2 || !get_wansetup_status("wan1") )
    {
      strcat(dest, "인터넷 연결 시도중..");
      v2 = 0;
      goto LABEL_29;
    }
    v3 = get_pppoe_status("wan1");
    v4 = v3;
    if ( !v3 )
    {
      strcat(dest, "인터넷 연결 중");
      v2 = v4;
      goto LABEL_29;
    }
    if ( v3 == 4 )
    {
      v2 = v42;
      v5 = dest;
      if ( !v42 )
      {
        v6 = dest;
        v7 = "IP를 받는 중";
LABEL_28:
        strcat(v6, v7);
        goto LABEL_29;
      }
LABEL_21:
      strcat(v5, "인터넷에 정상적으로 연결됨");
      v2 = 1;
      goto LABEL_29;
    }
    if ( v3 == 6 )
    {
      v6 = dest;
      v7 = "잘못된 계정/암호";
      goto LABEL_28;
    }
  }
  else
  {
    v2 = v42;
    v5 = dest;
    if ( v42 )
      goto LABEL_21;
    v8 = &dest[strlen(dest)];
    strcpy(v8, "인터넷 연결 시도중..");
    if ( istatus_get_intvalue_direct("lanwan_samenetwork") == 1 )
    {
      sprintf(
        v8 + 28,
        "<br><br><b>내부 네트워크와 동일한 대역의 IP주소가 검출되었습니다.<br><span class=movetoma"
        "in><a href=\"%s\"><U>[ 내부 네트워크 설정 ]</U></a></span> 에서 내부 네트워크의 IP주소를 변"
        "경 하십시오</b><br><br>",
        "JavaScript:MovePagetoMain('netconf','lansetup');");
      goto LABEL_29;
    }
    if ( istatus_get_intvalue_direct("privateip") == 1 )
    {
      v6 = dest;
      v7 = " - 사설 IP주소 검출됨";
      goto LABEL_28;
    }
  }
LABEL_29:
  v9 = get_wan_link("wan1");
  if ( get_usb_tethering_status(v9) )
  {
    v9 = 1;
  }
  else if ( !v9 )
  {
    strcpy(dest, "");
    if ( wireless_get_wwan_enable(0) )
      strcpy(dest, "<span class=warning_string>무선WAN</span> - ");
    strcat(dest, "WAN포트 연결안됨");
  }
  puts("<td class=\"item_td\" width=450>");
  printf("%s", dest);
  v10 = puts("</td>");
  v11 = etr(v10);
  str(v11);
  print_item_desc("연결 방식");
  puts("<td class=item_td>");
  v12 = sub_1B2A8(&s1);
  v13 = printf("%s", v12);
  if ( get_usb_tethering_status(v13) )
    printf((const char *)&unk_57D79);
  v14 = puts("</td>");
  etr(v14);
  if ( get_idle_timeout(&v44) || !get_wansetup_status("wan1") )
  {
    v28 = strcmp(&s1, "static");
    if ( v28 )
    {
      printf("<form method=get action=\"timepro.cgi\" name=\"netconf_waninfo_%s\">\n", "wan1");
      puts("<input type=hidden name=\"tmenu\" value=\"netconf\">");
      puts("<input type=hidden name=\"smenu\" value=\"waninfo\">");
      puts("<input type=hidden name=\"act\" value=\"connect\">");
      printf("<input type=hidden name=\"con_type\" value=\"%s\">\n", &s1);
      v31 = printf("<input type=hidden name=\"wan\" value=\"%s\">\n", "wan1");
      str(v31);
      printf("<td colspan=2 class=\"item_td\" align=right>");
      if ( !strcmp(&s1, "dynamic") )
        v30 = "<input type=button name=\"reconnect\" class=navi_bt value=\"연     결\" onclick=\"this.form.submit();\">";
      else
        v30 = "<input type=button name=\"reconnect\" class=navi_bt value=\"접     속\" onclick=\"this.form.submit();\">";
LABEL_56:
      printf(v30);
      v32 = puts("</td>");
      etr(v32);
      v28 = puts("</form>");
      goto LABEL_57;
    }
  }
  else
  {
    v15 = "gray_text";
    if ( v9 )
      v15 = "item_text";
    v16 = strcpy(&v35, v15);
    str(v16);
    strcpy(&v36, (const char *)&unk_57D9D);
    puts("<td class=itemdesc_td >");
    printf("<span class=bold_item_text>%s</span>\n", &v36);
    puts("</td>");
    puts("<td class=item_td>");
    printf("<span class=%s><b>%s</b></span>\n", &v35, &v42);
    v17 = puts("</td>");
    v18 = etr(v17);
    str(v18);
    print_item_desc("서브넷 마스크");
    puts("<td class=item_td>");
    printf("<span class=%s>%s</span>\n", &v35, &v41);
    v19 = puts("</td>");
    v20 = etr(v19);
    str(v20);
    print_item_desc("기본 게이트웨이");
    puts("<td class=\"item_td\">");
    printf("<span class=%s>%s</span>\n", &v35, &v40);
    v21 = puts("</td>");
    etr(v21);
    v22 = get_dns_shadow(&v44, &s1, &v39, &v38);
    str(v22);
    print_item_desc("기본 DNS 서버");
    puts("<td class=item_td>");
    printf("<span class=%s>%s</span>\n", &v35, &v39);
    v23 = puts("</td>");
    v24 = etr(v23);
    str(v24);
    print_item_desc("보조 DNS 서버");
    puts("<td class=item_td>");
    printf("<span class=%s>%s</span>\n", &v35, &v38);
    v25 = puts("</td>");
    v26 = etr(v25);
    str(v26);
    print_item_desc("MAC 주소");
    puts("<td class=item_td>");
    if ( !get_hwaddr_cloned("eth0", &v37) )
      get_hwaddr_kernel(&v44, &v37);
    convert_mac(&v37);
    puts(&v37);
    v27 = puts("</td>");
    etr(v27);
    v28 = strcmp(&s1, "static");
    if ( v28 )
    {
      printf("<form method=get action=timepro.cgi name=\"netconf_waninfo_%s\">\n", "wan1");
      puts("<input type=hidden name=tmenu value=netconf>");
      puts("<input type=hidden name=smenu value=waninfo>");
      puts("<input type=hidden name=act value=disconnect>");
      printf("<input type=hidden name=con_type value=\"%s\">\n", &s1);
      v29 = printf("<input type=hidden name=wan value=\"%s\">\n", "wan1");
      str(v29);
      printf("<td colspan=2 class=item_td align=right>");
      if ( !v2 && !get_idle_timeout(&v44) && get_wansetup_status("wan1") )
      {
        printf("화면은 5초 주기로 자동갱신됩니다.");
        print_nbsp(5);
      }
      if ( !strcmp(&s1, "dynamic") )
        v30 = "<input type=button name=\"reconnect\" class=navi_bt value=\"연결 해제\" onclick=\"this.form.submit();\">";
      else
        v30 = "<input type=button name=\"reconnect\" class=navi_bt value=\"접속 해제\" onclick=\"this.form.submit();\">";
      goto LABEL_56;
    }
  }
LABEL_57:
  result = print_end_content_table(v28);
  if ( !v2 )
  {
    result = get_idle_timeout(&v44);
    if ( !result )
    {
      result = get_wansetup_status("wan1");
      if ( result )
        result = printf("<meta http-equiv=refresh content=\"5; URL=timepro.cgi?tmenu=netconf&smenu=waninfo\">");
    }
  }
  return result;
}
// 101CC: using guessed type int __fastcall get_wansetup_status(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10340: using guessed type int __fastcall get_wan_type(_DWORD, _DWORD);
// 10358: using guessed type int __fastcall get_hwaddr_cloned(_DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10940: using guessed type int __fastcall get_idle_timeout(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10AB4: using guessed type int __fastcall get_wan_link(_DWORD);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10BEC: using guessed type int __fastcall get_wan_ipinfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11570: using guessed type int __fastcall get_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 11648: using guessed type int __fastcall wireless_get_wwan_enable(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11978: using guessed type int __cdecl get_usb_tethering_status(_DWORD);
// 11BAC: using guessed type int __fastcall get_pppoe_status(_DWORD);
// 1B328: using guessed type char dest[512];

//----- (0001BC58) --------------------------------------------------------
int __fastcall sub_1BC58(const char *a1, int a2, int a3)
{
  char *v3; // r6@1
  const char *v4; // r5@1
  int v5; // r4@1
  int v6; // r7@1
  int v7; // r0@4
  int v8; // r4@4
  int v9; // r0@6
  char v11; // [sp+8h] [bp-1B8h]@1
  char v12; // [sp+88h] [bp-138h]@6
  char v13; // [sp+108h] [bp-B8h]@6
  char v14; // [sp+188h] [bp-38h]@3

  v3 = &v11;
  v4 = a1;
  v5 = a2;
  v6 = a3;
  get_wan_hw_ifname(a2, &v11);
  if ( !strcmp(v4, "pppoe") || !strcmp(v4, "pptp") )
  {
    v3 = &v14;
    get_pppoe_ifname(v5, &v14);
  }
  v7 = get_mtu_value(v3, 1);
  v8 = v7;
  if ( !v7 )
    v8 = v6;
  str(v7);
  snprintf(&v13, 0x80u, "mtu.%s.%s.check", v4, &v11);
  snprintf(&v12, 0x80u, "mtu.%s.%s", v4, &v11);
  iconfig_get_intvalue_direct(&v13);
  printf("<td class=\"item_td\">");
  printf("<input type=checkbox class=navi_chk name='%s' %s onclick=\"OnCheckEnableMTU(this, '%s')\">\n", &v13);
  puts("MTU");
  printf("</td>");
  printf("<td class=item_td><input class=\"navi_text\" type=text name=%s size=4 maxlength=4 value=%d></td>\n", &v12, v8);
  v9 = puts("</td>");
  return etr(v9);
}
// 10394: using guessed type int __fastcall iconfig_get_intvalue_direct(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10D18: using guessed type int __fastcall get_pppoe_ifname(_DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 113B4: using guessed type int __fastcall get_mtu_value(_DWORD, _DWORD);

//----- (0001BDA8) --------------------------------------------------------
int __fastcall sub_1BDA8(int a1, int a2, const char *a3)
{
  int v3; // r4@1
  const char *v4; // r6@1
  int v5; // r5@1
  const char *v6; // r1@1
  int v7; // r2@2
  int v8; // r0@4
  int v10; // [sp+8h] [bp+0h]@4
  char v11; // [sp+108h] [bp+100h]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  str(a1);
  puts("<td class=item_td width=200>");
  *v4;
  printf(
    "<input type=checkbox class=navi_chk name=hw_conf_%s %s onclick=\"SetHWOnCheckEnableHWButton(this,'hw_%s','%s','macbutton_%s');\">\n",
    v3);
  puts("MAC 주소 변경</td>");
  puts("<td class=item_td>");
  snprintf(&v11, 0x20u, "hw_%s", v3, v5, v3);
  v6 = (const char *)*v4;
  if ( *v4 )
  {
    v6 = v4;
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }
  sub_15664((int)&v11, v6, v7);
  print_nbsp(2);
  snprintf((char *)&v10, 0x100u, (const char *)&unk_586BD, v3);
  snprintf(&v11, 0x20u, "macbutton_%s", v3);
  *v4;
  print_popup_button(
    &v10,
    "searchmac",
    "width=400px,height=250px,scrollbars=yes,menubar=no,toolbar=no,resizable=yes",
    &v11);
  v8 = printf("</td>");
  return etr(v8);
}
// 10844: using guessed type int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0001BEE0) --------------------------------------------------------
int __fastcall sub_1BEE0(int a1, const char *a2, int a3)
{
  int v3; // r5@1
  const char *v4; // r4@1
  int v5; // r6@1
  char v7; // [sp+4h] [bp-17Ch]@2
  char s; // [sp+84h] [bp-FCh]@2
  char v9; // [sp+104h] [bp-7Ch]@2
  char v10; // [sp+124h] [bp-5Ch]@7
  char s2; // [sp+138h] [bp-48h]@2
  char dest; // [sp+14Ch] [bp-34h]@4

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !strcmp(a2, "eth0") )
  {
    snprintf(&s, 0x80u, "hw_conf_%s", v5);
    snprintf(&v7, 0x80u, "hw_%s", v5);
    get_hwaddr_kernel(v4, &s2);
    if ( get_value(v3, &s, &v9, 32) && !strcmp(&v9, "on") )
    {
      strcpy(&dest, "");
      get_hw_value(v3, &v7, &dest);
      if ( !check_invalid_hwaddr(&dest) && strcmp(&dest, &s2) )
      {
        set_hwaddr_kernel(v4, &dest, 1);
        set_hwaddr_cloned(v4, &dest);
      }
    }
    else
    {
      get_hwaddr_org(v4, &v10);
      set_hwaddr_cloned(v4, 0);
      if ( strcmp(&v10, &s2) )
        set_hwaddr_kernel(v4, &v10, 1);
    }
  }
  return 0;
}
// 10058: using guessed type int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10448: using guessed type int __fastcall get_hwaddr_org(_DWORD, _DWORD);
// 1064C: using guessed type int __fastcall set_hwaddr_cloned(_DWORD, _DWORD);
// 10AFC: using guessed type int __fastcall check_invalid_hwaddr(_DWORD);
// 11078: using guessed type int __fastcall set_hwaddr_kernel(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001C040) --------------------------------------------------------
int __fastcall sub_1C040(int a1, int a2, const char *a3)
{
  const char *v3; // r4@1
  int v4; // r9@1
  int v5; // r7@1
  int v6; // r5@1
  int v7; // r0@10
  char v9; // [sp+Ch] [bp-1C4h]@4
  char v10; // [sp+8Ch] [bp-144h]@4
  char v11; // [sp+10Ch] [bp-C4h]@3
  char v12; // [sp+14Ch] [bp-84h]@4
  char v13; // [sp+18Ch] [bp-44h]@4
  int v14; // [sp+1ACh] [bp-24h]@9

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = hwinfo_get_mtu(a3);
  if ( !strcmp(v3, "pppoe") || !strcmp(v3, "pptp") )
    get_pppoe_ifname(v5, &v11);
  get_wan_hw_ifname(v5, &v12);
  snprintf(&v10, 0x80u, "mtu.%s.%s", v3, &v12);
  snprintf(&v9, 0x80u, "mtu.%s.%s.check", v3, &v12);
  if ( get_value(v4, &v9, &v13, 32) && !strcmp(&v13, "on") )
  {
    if ( get_intvalue(v4, &v10, &v14) )
    {
      iconfig_set_intvalue_direct(&v9, 1);
      v7 = get_mtu_value(&v12, 1);
      v6 = v14;
      if ( v7 != v14 )
      {
        iconfig_set_intvalue_direct(&v10, v14);
        if ( strcmp(v3, "pppoe") && strcmp(v3, "pptp") )
          set_mtu_value(&v12, v14);
        v6 = v14;
      }
    }
  }
  else
  {
    iconfig_set_intvalue_direct(&v9, 0);
    if ( strcmp(v3, "pppoe") && strcmp(v3, "pptp") )
      set_mtu_value(&v12, v6);
  }
  return v6;
}
// 10964: using guessed type int __fastcall hwinfo_get_mtu(_DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10D18: using guessed type int __fastcall get_pppoe_ifname(_DWORD, _DWORD);
// 10E50: using guessed type int __fastcall set_mtu_value(_DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 113B4: using guessed type int __fastcall get_mtu_value(_DWORD, _DWORD);
// 11768: using guessed type int __fastcall iconfig_set_intvalue_direct(_DWORD, _DWORD);

//----- (0001C1F4) --------------------------------------------------------
int __fastcall sub_1C1F4(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  const char *v3; // r0@3
  int v4; // r0@12
  int *v5; // r0@16
  signed int v6; // r1@20
  int *v7; // r0@20
  int v8; // r0@35
  int v9; // r0@37
  int v10; // r0@37
  int v11; // r0@40
  int v12; // r0@40
  int v13; // r0@40
  char v14; // [sp+8h] [bp-480h]@1
  char s; // [sp+208h] [bp-280h]@26
  char v16; // [sp+288h] [bp-200h]@28
  int v17; // [sp+330h] [bp-158h]@28
  char v18; // [sp+334h] [bp-154h]@30
  char v19; // [sp+338h] [bp-150h]@30
  int v20; // [sp+340h] [bp-148h]@28
  char s1; // [sp+344h] [bp-144h]@4
  char v22; // [sp+384h] [bp-104h]@32
  char v23; // [sp+3A4h] [bp-E4h]@32
  char v24; // [sp+3C4h] [bp-C4h]@32
  char v25; // [sp+3E4h] [bp-A4h]@37
  char dest; // [sp+3F8h] [bp-90h]@37
  int v27; // [sp+40Ch] [bp-7Ch]@6
  char v28; // [sp+420h] [bp-68h]@6
  int v29; // [sp+434h] [bp-54h]@6
  int v30; // [sp+448h] [bp-40h]@2
  int v31; // [sp+45Ch] [bp-2Ch]@4

  v1 = a1;
  result = get_value(a1, "act", &v14, 512);
  if ( result )
  {
    if ( !get_value(v1, "wan", &v30, 20) )
    {
      v3 = "No WAN name is specified. Debug it..";
      return puts(v3);
    }
    get_wan_hw_ifname(&v30, &v31);
    set_wansetup_status(&v30, 1);
    result = get_value(v1, "wan_type", &s1, 64);
    if ( !result )
      return result;
    signal_toggle(result);
    stop_wan(&v30);
    set_wan_type(&v30, &s1);
    if ( !strcmp(&s1, "static") )
    {
      strcpy((char *)&v29, "");
      get_ip_value(v1, "ip", &v29);
      strcpy(&v28, "");
      get_ip_value(v1, "sm", &v28);
      strcpy((char *)&v27, "");
      get_ip_value(v1, "gw", &v27);
      set_wan_ipconfig(&v31, &v29, &v28, &v27);
      sub_1BEE0(v1, (const char *)&v31, (int)&s1);
      set_ifconfig(&v31, &v29, &v28);
      if ( !sysconf_nat_get(1) )
        make_virtual_host_page(&v29);
      if ( check_default_gateway(&v27, &v29, &v28) )
      {
        set_default_gateway(&v31, 0);
      }
      else
      {
        set_default_gateway("br0", 0);
        if ( set_default_gateway(&v31, &v27) )
          set_default_gateway2(&v31, &v29, &v28, &v27);
      }
      v4 = sub_1C040(v1, (int)&v30, &s1);
      signal_wan(v4);
    }
    else if ( !strcmp(&s1, "dynamic") )
    {
      set_ifconfig(&v31, "0.0.0.0", "255.255.255.0");
      set_wan_ipconfig(&v31, "0.0.0.0", "255.255.255.0", 0);
      if ( get_value(v1, "allow_private", &v14, 512) && !strcmp(&v14, "on") )
        v5 = &v31;
      else
        v5 = &v31;
      set_dhclient_block_private_ip(v5);
      if ( get_value(v1, "dhcp_auto_restart", &v14, 512) && !strcmp(&v14, "on") )
      {
        v6 = 1;
        v7 = &v31;
      }
      else
      {
        v6 = 0;
        v7 = &v31;
      }
      set_dhcp_auto_restart(v7, v6);
      sub_1BEE0(v1, (const char *)&v31, (int)&s1);
      sub_1C040(v1, (int)&v30, &s1);
    }
    else if ( !strcmp(&s1, "pppoe") )
    {
      if ( get_pppoe_status(&v30) == 7 )
        set_pppoe_status(&v30, 0);
      set_ifconfig(&v31, "0.0.0.0", "255.255.255.0");
      set_wan_ipconfig(&v31, "0.0.0.0", "255.255.255.0", 0);
      read_pppoe_option(&v30, &s);
      get_value(v1, "userid", &s, 128);
      if ( check_unpermitted_chars(&s) )
        strcpy(&s, "");
      get_value(v1, "passwd", &v16, 128);
      sub_1BEE0(v1, (const char *)&v31, (int)&s1);
      v20 = sub_1C040(v1, (int)&v30, &s1);
      if ( get_intvalue(v1, "lcp_flag", &v17) )
      {
        get_intvalue(v1, "lcp_echo_interval", &v18);
        get_intvalue(v1, "lcp_echo_failure", &v19);
      }
      else
      {
        v17 = 0;
      }
      save_pppoe_option(&v30, &s);
    }
    snprintf(&s, 0x80u, "dns_%s_chk", &s1);
    snprintf(&v23, 0x20u, "fdns_%s", &s1);
    snprintf(&v22, 0x20u, "sdns_%s", &s1);
    if ( get_value(v1, &s, &v24, 32) && !strcmp(&v24, "on") || !strcmp(&s1, "static") )
    {
      v8 = strcmp(&s1, "static");
      if ( v8 && !check_valid_account(v8) )
        goto LABEL_40;
      strcpy(&dest, "");
      strcpy(&v25, "");
      get_ip_value(v1, &v23, &dest);
      get_ip_value(v1, &v22, &v25);
      set_autodns(0);
      dhcpd_set_dns(&dest, &v25);
      set_manual_dns_flag(&v31, &s1, 1);
      v9 = set_dns_shadow(&v31, &s1, &dest, &v25);
      v10 = get_remote_addr(v9);
      syslog_msg(1, "%s에서 접속한 관리자가 DNS설정을 %s,%s로 변경하였습니다.", v10, &dest, &v25);
    }
    else
    {
      set_autodns(1);
      set_manual_dns_flag(&v31, &s1, 0);
    }
    set_system_dns(&v30);
LABEL_40:
    v11 = istatus_remove_status_tag("lanwan_samenetwork");
    v12 = signal_toggle(v11);
    v13 = signal_update(v12);
    signal_save(v13);
    puts("<script language=JavaScript>");
    puts("if(confirm(NETCONF_WANSETUP_CONFIRM_WANINFO))");
    puts("\tlocation.href=\"JavaScript:MovePagetoMain('netconf','waninfo')\";");
    v3 = "</script>";
    return puts(v3);
  }
  return result;
}
// 10148: using guessed type int __fastcall get_remote_addr(_DWORD);
// 10154: using guessed type int __fastcall set_dhclient_block_private_ip(_DWORD);
// 1016C: using guessed type int __fastcall dhcpd_set_dns(_DWORD, _DWORD);
// 101A8: using guessed type int __fastcall set_autodns(_DWORD);
// 10238: using guessed type int __fastcall make_virtual_host_page(_DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 104B4: using guessed type int __fastcall set_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10B74: using guessed type int __fastcall set_default_gateway2(_DWORD, _DWORD, _DWORD, _DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10D60: using guessed type int __fastcall signal_wan(_DWORD);
// 10DA8: using guessed type int __fastcall set_wan_type(_DWORD, _DWORD);
// 10EC8: using guessed type int __fastcall set_pppoe_status(_DWORD, _DWORD);
// 10F34: using guessed type int __fastcall stop_wan(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11018: using guessed type int __fastcall sysconf_nat_get(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 111B0: using guessed type int __fastcall set_system_dns(_DWORD);
// 112D0: using guessed type int __fastcall read_pppoe_option(_DWORD, _DWORD);
// 11678: using guessed type int __fastcall set_wan_ipconfig(_DWORD, _DWORD, _DWORD, _DWORD);
// 116A8: using guessed type int __fastcall set_wansetup_status(_DWORD, _DWORD);
// 119CC: using guessed type int __fastcall signal_toggle(_DWORD);
// 11A08: using guessed type int __fastcall set_ifconfig(_DWORD, _DWORD, _DWORD);
// 11A74: using guessed type int __fastcall set_default_gateway(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11B04: using guessed type int __fastcall set_dhcp_auto_restart(_DWORD, _DWORD);
// 11B28: using guessed type int __fastcall check_default_gateway(_DWORD, _DWORD, _DWORD);
// 11B40: using guessed type int __fastcall save_pppoe_option(_DWORD, _DWORD);
// 11BAC: using guessed type int __fastcall get_pppoe_status(_DWORD);
// 11BDC: using guessed type int __fastcall set_manual_dns_flag(_DWORD, _DWORD, _DWORD);
// 11C18: using guessed type int __fastcall istatus_remove_status_tag(_DWORD);

//----- (0001C85C) --------------------------------------------------------
int __fastcall sub_1C85C(int a1, int a2)
{
  int v2; // r6@1
  int v3; // r0@1
  int v4; // r1@1
  int v5; // r0@1
  int v6; // r0@1
  char *v7; // r1@2
  char *v8; // r1@5
  char *v9; // r1@8
  int v10; // r0@10
  int v11; // r0@10
  char *v12; // r0@10
  int v13; // r0@10
  char *v14; // r1@11
  int v15; // r0@13
  int v16; // r0@13
  char *v17; // r1@14
  int v18; // r0@16
  int v19; // r0@16
  char *v20; // r1@17
  int v21; // r0@19
  int v22; // r0@19
  int v23; // r0@19
  int v24; // r0@19
  int v25; // r0@19
  int v26; // r0@19
  int v27; // r0@19
  int v28; // r0@19
  int v29; // r0@19
  int v30; // r0@19
  int v31; // r0@19
  char *v32; // r1@20
  int v33; // r0@22
  int v34; // r0@22
  char *v35; // r1@23
  int v36; // r0@25
  int v37; // r0@25
  int v38; // r0@25
  int v39; // r0@25
  int v40; // r0@25
  int v41; // r0@25
  int v42; // r0@25
  int v43; // r0@25
  int v44; // r0@25
  int v45; // r0@25
  int v46; // r0@25
  int v47; // r0@27
  int v48; // r0@27
  int v49; // r0@27
  int v50; // r0@27
  int v51; // r0@27
  int v52; // r0@27
  int v53; // r0@27
  int v54; // r0@27
  char v56; // [sp+8h] [bp-330h]@19
  char v57; // [sp+88h] [bp-2B0h]@19
  int v58; // [sp+130h] [bp-208h]@19
  int v59; // [sp+134h] [bp-204h]@22
  int v60; // [sp+138h] [bp-200h]@22
  int v61; // [sp+140h] [bp-1F8h]@19
  char v62; // [sp+144h] [bp-1F4h]@1
  char v63; // [sp+1C4h] [bp-174h]@1
  char dest; // [sp+204h] [bp-134h]@1
  char v65; // [sp+244h] [bp-F4h]@1
  char v66; // [sp+264h] [bp-D4h]@10
  char v67; // [sp+278h] [bp-C0h]@10
  char v68; // [sp+28Ch] [bp-ACh]@10
  char v69; // [sp+2A0h] [bp-98h]@19
  char v70; // [sp+2B4h] [bp-84h]@19
  char v71; // [sp+2C8h] [bp-70h]@25
  char v72; // [sp+2DCh] [bp-5Ch]@25
  char v73; // [sp+2F0h] [bp-48h]@25
  char v74; // [sp+304h] [bp-34h]@1

  v2 = a2;
  strcpy(&dest, "");
  strcpy(&v63, "");
  get_wan_hw_ifname(v2, &v74);
  get_wan_type(v2, &v65);
  strcpy(&v62, "인터넷 연결 설정");
  puts("<form method=get action=\"timepro.cgi\" name=\"netconf_wansetup\">");
  puts("<input type=hidden name=\"tmenu\" value=\"netconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"wansetup\">");
  puts("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"wan\" value=\"%s\">\n", v2);
  v3 = printf("<input type=hidden name=\"ifname\" value=\"%s\">\n", &v74);
  v4 = check_valid_account(v3) == 0;
  v5 = printf("<input type=hidden name=\"nopassword\" value=\"%d\">");
  v6 = print_start_content_table(v5);
  str(v6);
  puts("<td class=\"itemdesc_td\"> ");
  if ( !strcmp(&v65, "dynamic") )
    v7 = "checked";
  else
    v7 = "";
  printf(
    "<input type=radio name=\"wan_type\" class=\"navi_radio\" value=\"dynamic\" %s onclick=\"ShowWansetup('%s','dynamic')\">",
    v7,
    &v74);
  puts("<span class=\"bold_item_text\">동적 IP 방식</span> (FTTH, 광랜방식, 케이블모뎀, VDSL, LAN방식, IP ADSL)<br>");
  if ( !strcmp(&v65, "pppoe") )
    v8 = "checked";
  else
    v8 = "";
  printf(
    "<input type=radio name=\"wan_type\" class=\"navi_radio\" value=\"pppoe\" %s onclick=\"ShowWansetup('%s','pppoe')\">",
    v8,
    &v74);
  printf("<span class=\"bold_item_text\">PPPoE 방식</span> (ADSL 방식)<br>");
  if ( !strcmp(&v65, "static") )
    v9 = "checked";
  else
    v9 = "";
  printf(
    "<input type=radio name=\"wan_type\" class=\"navi_radio\" value=\"static\" %s onclick=\"ShowWansetup('%s','static')\">",
    v9,
    &v74);
  printf("<span class=\"bold_item_text\">고정 IP 사용자</span> (My IP 또는 Multi IP 방식)<br>");
  v10 = printf("</td>");
  v11 = etr(v10);
  print_end_content_table(v11);
  strcpy(&v66, "");
  strcpy(&v67, "");
  get_hwaddr_kernel(&v74, &v66);
  get_hwaddr_cloned(&v74, &v67);
  v12 = getenv("REMOTE_ADDR");
  get_internal_pc_hardware_address(v12, &v68);
  strcmp(&v65, "dynamic");
  printf("<tr id=\"dynamic\" class=navi_display_%s_tr>");
  puts("<td class=item_noline_td>");
  puts("<table class=menu_content_list_noline_table cellspacing=0px cellpadding=0px>");
  v13 = sub_1BDA8((int)"dynamic", (int)&v68, &v67);
  str(v13);
  if ( get_dhclient_block_private_ip(&v74) )
    v14 = "";
  else
    v14 = "checked";
  printf("<td class=\"item_td\" colspan=2><input type=checkbox class=\"navi_chk\" name=\"allow_private\" %s>\n", v14);
  puts("<span class=\"item_text\">");
  printf("사설 IP 할당 허용하기");
  puts("</span>");
  v15 = puts("</td>");
  v16 = etr(v15);
  str(v16);
  if ( get_dhcp_auto_restart(&v74) )
    v17 = "checked";
  else
    v17 = "";
  printf(
    "<td class=\"item_td\" colspan=2><input type=checkbox class=\"navi_chk\" name=\"dhcp_auto_restart\" %s>\n",
    v17);
  puts("<span class=\"item_text\">");
  printf("WAN포트의 물리적 링크 끊김 감지 시 DHCP기능 재시작 하기");
  puts("</span>");
  v18 = puts("</td>");
  etr(v18);
  v19 = sub_1BC58("dynamic", v2, 1500);
  str(v19);
  puts("<td class=\"item_td\" colspan=2>");
  if ( get_manual_dns_flag(&v74, "dynamic") )
    v20 = "checked";
  else
    v20 = "";
  printf("<input type=checkbox name=\"dns_dynamic_chk\" class=navi_chk %s onclick=\"check_dns_dynamic();\">\n", v20);
  puts("수동으로 공유기의 DNS 서버 설정");
  v21 = puts("</td>");
  etr(v21);
  v22 = get_dns_shadow(&v74, "dynamic", &v70, &v69);
  str(v22);
  printf("<td class=\"item_td\">%s\n", "기본 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)&unk_58EAA, &v70, 1);
  v23 = puts("</td>");
  v24 = etr(v23);
  str(v24);
  printf("<td class=\"item_td\">%s\n", "보조 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)"sdns_dynamic", &v69, 1);
  v25 = puts("</td>");
  etr(v25);
  printf("</table>");
  v26 = puts("</td>");
  etr(v26);
  read_pppoe_option(v2, &v56);
  strcmp(&v65, "pppoe");
  printf("<tr id=\"pppoe\" class=navi_display_%s_tr>\n");
  puts("<td class=item_noline_td>");
  v27 = puts("<table class=menu_content_list_table cellspacing=0px cellpadding=0px>");
  str(v27);
  printf("<td class=item_td width=145>사용자 계정 (ID)</td>");
  v28 = printf(
          "<td class=item_td><input class=navi_text type=text name=\"userid\" size=22 maxlength=63 value=\"%s\"></td>\n",
          &v56);
  v29 = etr(v28);
  str(v29);
  puts("<td class=item_td>사용자 암호 (PASSWORD)</td>");
  v30 = printf(
          "<td class=item_td><input class=\"navi_text\" type=password name=\"passwd\" size=22 maxlength=63 value=\"%s\"></td>\n",
          &v57);
  etr(v30);
  sub_1BDA8((int)"pppoe", (int)&v68, &v67);
  v31 = sub_1BC58("pppoe", v2, v61);
  str(v31);
  printf("<td class=\"item_td\">");
  if ( v58 )
    v32 = "checked";
  else
    v32 = "";
  printf("<input type=checkbox class=navi_chk name='lcp_flag' %s onclick=\"OnCheckEnableLCP()\" value=1>\n", v32);
  printf("연결 유지 설정(LCP)");
  printf("</td>");
  printf("<td class=item_td>");
  printf("주기");
  print_nbsp(1);
  printf("<input class=\"navi_text\" type=text name=\"lcp_echo_interval\" size=3 maxlength=3 value=\"%d\" >", v59);
  print_nbsp(1);
  printf("초");
  print_nbsp(5);
  printf("횟수");
  print_nbsp(1);
  printf("<input class=\"navi_text\" type=text name=\"lcp_echo_failure\" size=3 maxlength=3 value=\"%d\" >", v60);
  v33 = printf("</td>");
  v34 = etr(v33);
  str(v34);
  puts("<td class=\"item_td\" colspan=2>");
  if ( get_manual_dns_flag(&v74, "pppoe") )
    v35 = "checked";
  else
    v35 = "";
  printf("<input type=checkbox name=\"dns_pppoe_chk\" class=navi_chk %s onclick=\"check_dns_pppoe();\">\n", v35);
  puts("수동으로 공유기의 DNS 서버 설정");
  v36 = puts("</td>");
  etr(v36);
  v37 = get_dns_shadow(&v74, "pppoe", &v70, &v69);
  str(v37);
  printf("<td class=\"item_td\">%s\n", "기본 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)&unk_591FE, &v70, 1);
  v38 = puts("</td>");
  v39 = etr(v38);
  str(v39);
  printf("<td class=\"item_td\">%s\n", "보조 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)"sdns_pppoe", &v69, 1);
  v40 = puts("</td>");
  etr(v40);
  puts("</table>");
  v41 = puts("</td>");
  etr(v41);
  strcmp(&v65, "static");
  printf("<tr id=\"static\" class=navi_display_%s_tr>\n");
  puts("<td class=item_noline_td>");
  v42 = puts("<table class=\"menu_content_list_table\" cellspacing=0px cellpadding=0 >");
  str(v42);
  printf("<td class=\"item_td\"><span class=\"item_text\">%s</span>\n", &unk_57D9D);
  printf("</td>");
  puts("<td class=\"item_td\">");
  get_ifconfig(&v74, &v73, &v72);
  sub_157CC((int)"ip", &v73, 1);
  v43 = puts("</td>");
  v44 = etr(v43);
  str(v44);
  printf("<td class=\"item_td\"><span class=\"item_text\">%s</span>\n", "서브넷 마스크");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)"sm", &v72, 1);
  v45 = puts("</td>");
  v46 = etr(v45);
  str(v46);
  printf("<td class=\"item_td\"><span class=\"item_text\">%s</span>\n", "기본 게이트웨이");
  printf("</td>");
  puts("<td class=\"item_td\">");
  get_default_gateway(&v74, &v71);
  if ( !strncmp(&v71, "ppp", 3u) )
    sf_strncpy(&v71, &v73, 20);
  sub_157CC((int)"gw", &v71, 1);
  v47 = puts("</td>");
  etr(v47);
  v48 = get_dns_shadow(&v74, "static", &v70, &v69);
  str(v48);
  printf("<td class=\"item_td\"><span class=\"item_text\">%s</span>\n", "기본 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)&unk_592C1, &v70, 1);
  v49 = puts("</td>");
  v50 = etr(v49);
  str(v50);
  printf("<td class=\"item_td\"><span class=\"item_text\">%s</span>\n", "보조 DNS 서버");
  printf("</td>");
  puts("<td class=\"item_td\">");
  sub_157CC((int)"sdns_static", &v69, 1);
  v51 = puts("</td>");
  etr(v51);
  sub_1BC58("static", v2, 1500);
  sub_1BDA8((int)"static", (int)&v68, &v67);
  puts("</table>");
  printf("</div>");
  v52 = puts("</td>");
  v53 = etr(v52);
  str(v53);
  v54 = printf(
          "<td colspan=2 class=\"item_td\" align=right><input type=\"button\" class=\"bt\" name=\"connect_bt\" value=\""
          "용\" onclick=\"apply_wansetup('%s','%s')\"></td>\n",
          v2,
          &v74);
  etr(v54);
  return puts("</form>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10340: using guessed type int __fastcall get_wan_type(_DWORD, _DWORD);
// 10358: using guessed type int __fastcall get_hwaddr_cloned(_DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 1079C: using guessed type int __fastcall get_default_gateway(_DWORD, _DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);
// 10CE8: using guessed type int __fastcall get_manual_dns_flag(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11090: using guessed type int __fastcall get_dhclient_block_private_ip(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 112D0: using guessed type int __fastcall read_pppoe_option(_DWORD, _DWORD);
// 113F0: using guessed type int __fastcall get_dhcp_auto_restart(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11570: using guessed type int __fastcall get_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001D13C) --------------------------------------------------------
int __fastcall sub_1D13C(int a1)
{
  int v1; // r6@1
  int v3; // [sp+0h] [bp-50h]@1
  char v4; // [sp+20h] [bp-30h]@1

  v1 = a1;
  get_wan_type(a1, &v4);
  get_wan_hw_ifname(v1, &v3);
  puts("<script language=JavaScript>");
  printf("ShowWansetup('%s','%s');", &v3, &v4);
  puts("check_dns()");
  puts("OnCheckEnableLCP();");
  return puts("</script>");
}
// 10340: using guessed type int __fastcall get_wan_type(_DWORD, _DWORD);
// 10BD4: using guessed type int __fastcall get_wan_hw_ifname(_DWORD, _DWORD);

//----- (0001D330) --------------------------------------------------------
int sub_1D330()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  char v14; // [sp+8h] [bp-3D8h]@1
  char s; // [sp+18h] [bp-3C8h]@1
  char v16; // [sp+2Ch] [bp-3B4h]@1
  int v17; // [sp+3C0h] [bp-20h]@1
  int v18; // [sp+3E0h] [bp+0h]@1
  char v19; // [sp+3F4h] [bp+14h]@1

  v0 = print_sub_title("내부 네트워크 정보", 1);
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("내부 IP주소");
  puts("<td class=\"item_td\">");
  get_ifconfig("br0", &v19, &v18);
  puts(&v19);
  v2 = puts("</td>");
  v3 = etr(v2);
  str(v3);
  print_item_desc("서브넷 마스크");
  puts("<td class=\"item_td\">");
  puts((const char *)&v18);
  v4 = puts("</td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc("MAC 주소");
  puts("<td class=\"item_td\">");
  get_hwaddr_kernel("br0", &v17);
  convert_mac(&v17);
  printf("%s", &v17);
  v6 = puts("</td>");
  v7 = etr(v6);
  str(v7);
  print_item_desc("동적 IP 할당 범위");
  puts("<td class=\"item_td\">");
  dhcpd_read_config(&v14);
  puts(&s);
  printf(" ~ ");
  print_nbsp(1);
  puts(&v16);
  v8 = puts("</td>");
  v9 = etr(v8);
  str(v9);
  print_item_desc("동적 IP 할당 수");
  puts("<td class=\"item_td\">");
  v10 = dhcpd_get_all_dynamic_lease(0);
  printf("%d\n", v10);
  v11 = puts("</td>");
  v12 = etr(v11);
  return print_end_content_table(v12);
}
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 1052C: using guessed type int __cdecl dhcpd_get_all_dynamic_lease(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001D51C) --------------------------------------------------------
int __fastcall sub_1D51C(char *s2, int a2, int a3)
{
  char *v3; // r4@1
  int v4; // r7@1
  int v5; // r6@1
  int i; // r5@1
  int v7; // r0@2

  v3 = s2;
  v4 = a3;
  v5 = a2;
  for ( i = 0; ; ++i )
  {
    if ( i >= v4 )
      return 0;
    v7 = strcasecmp((const char *)(v5 + 148), v3);
    v5 += 188;
    if ( !v7 )
      break;
  }
  return 1;
}

//----- (0001D568) --------------------------------------------------------
signed int __fastcall sub_1D568(int a1, _DWORD *a2)
{
  int v2; // r7@1
  _DWORD *v3; // r5@1
  int i; // r4@1

  v2 = a1;
  v3 = a2;
  for ( i = 0; ; ++i )
  {
    if ( i >= *v3 )
      return 0;
    if ( !maccmp(v2, &v3[50 * i + 10]) )
      break;
  }
  return 1;
}
// 1184C: using guessed type int __fastcall maccmp(_DWORD, _DWORD);

//----- (0001D5BC) --------------------------------------------------------
int sub_1D5BC()
{
  int v0; // r6@1
  void *v1; // r7@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r5@2
  char *v7; // r0@4
  const char *v8; // r1@4
  int v9; // r0@8
  signed int v10; // r11@8
  int v11; // r0@14
  void *v13; // [sp+0h] [bp-6638h]@1
  int v14; // [sp+4h] [bp-6634h]@1
  int v15; // [sp+8h] [bp-6630h]@1
  int v16; // [sp+14h] [bp-6624h]@1
  int v17; // [sp+1Ch] [bp-661Ch]@1
  int v18; // [sp+323Ch] [bp-33FCh]@1
  int v19; // [sp+3244h] [bp-33F4h]@1
  int v20; // [sp+6464h] [bp-1D4h]@12
  int v21; // [sp+6564h] [bp-D4h]@8
  char v22; // [sp+6590h] [bp-A8h]@11
  int v23; // [sp+65D0h] [bp-68h]@4

  v0 = 0;
  v18 = 0;
  strcpy((char *)&v19, "eth2");
  wireless_api_get_station_list(&v18);
  v16 = 0;
  strcpy((char *)&v17, "eth1");
  wireless_api_get_station_list(&v16);
  v13 = malloc(0xBC00u);
  v1 = malloc(0xBC00u);
  v2 = print_sub_title("사용 중인 IP 주소 정보", 0);
  v3 = print_start_content_table(v2);
  str(v3);
  puts("<td class=itemdesc_td width=28></td>");
  puts("<td class=itemdesc_td>IP 주소</span></td>");
  puts("<td class=itemdesc_td>MAC 주소</span></td>");
  v4 = puts("<td class=itemdesc_td>비고</span></td>");
  etr(v4);
  v14 = get_hostinfo_from_arp("br0", 256, v1);
  v5 = get_hostinfo_from_bridge(1, 256, v13);
  v15 = v5;
  while ( v0 < v14 )
  {
    v6 = (int)v1 + 148;
    if ( sub_1D568((int)v1 + 148, &v18) || sub_1D568((int)v1 + 148, &v16) )
    {
      v7 = (char *)&v23;
      v8 = "무선";
    }
    else if ( sub_1D51C((char *)v1 + 148, (int)v13, v15) )
    {
      v8 = "유선";
      v7 = (char *)&v23;
    }
    else
    {
      v8 = "-";
      v7 = (char *)&v23;
    }
    strcpy(v7, v8);
    memset(&v21, 0, 0x6Cu);
    ++v0;
    v9 = dhcpd_get_dynamic_lease((char *)v1 + 128, &v21);
    v10 = v9;
    if ( v9 )
      v10 = 1;
    str(v9);
    printf("<td class=\"item_td\" align=center><span class=itemdesc_text>%d</span></td>\n", v0);
    printf("<td class=\"item_td\"><span class=itemdesc_text>");
    if ( v10 && v22 )
    {
      memset(&v20, 0, 0x100u);
      convert_euckr_to_utf8(&v22, &v20);
      printf("%s(%s)", (char *)v1 + 128, &v20);
    }
    else
    {
      printf("%s", (char *)v1 + 128);
    }
    v1 = (char *)v1 + 188;
    puts("</span></td>");
    convert_mac(v6);
    printf("<td class=\"item_td\"><span class=itemdesc_text>%s</span></td>\n", v6);
    v11 = printf("<td class=\"item_td\"><span class=itemdesc_text>%s : %s</span></td>\n", &v23);
    v5 = etr(v11);
  }
  return print_end_content_table(v5);
}
// 103D0: using guessed type int __fastcall get_hostinfo_from_bridge(_DWORD, _DWORD, _DWORD);
// 1040C: using guessed type int __fastcall get_hostinfo_from_arp(_DWORD, _DWORD, _DWORD);
// 105E0: using guessed type int __fastcall wireless_api_get_station_list(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EEC: using guessed type int __fastcall dhcpd_get_dynamic_lease(_DWORD, _DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1103C: using guessed type int __fastcall convert_euckr_to_utf8(_DWORD, _DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001D884) --------------------------------------------------------
unsigned int __fastcall sub_1D884(const char *a1, const char *a2)
{
  unsigned int v2; // r4@1

  v2 = __rev(inet_addr(a1));
  return v2 - __rev(inet_addr(a2));
}

//----- (0001D8A8) --------------------------------------------------------
int sub_1D8A8()
{
  int v0; // r0@1
  char *v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  unsigned int v10; // r0@2
  char *v11; // r0@2
  char *v12; // r0@2
  int v13; // r0@2
  int v14; // r0@3
  int v15; // r0@3
  int v17; // [sp+0h] [bp-F0h]@2
  char v18; // [sp+20h] [bp-D0h]@2
  char v19; // [sp+40h] [bp-B0h]@1
  char v20; // [sp+60h] [bp-90h]@1
  char v21; // [sp+80h] [bp-70h]@1
  char v22; // [sp+94h] [bp-5Ch]@1
  char v23; // [sp+A8h] [bp-48h]@1
  char v24; // [sp+BCh] [bp-34h]@1
  struct in_addr v25; // [sp+D0h] [bp-20h]@1
  struct in_addr inp; // [sp+D4h] [bp-1Ch]@1

  v0 = print_sub_title("내부 IP 설정", 1);
  print_start_content_table(v0);
  puts("<form method=get action=\"timepro.cgi\" name=\"netconf_lansetup1\">");
  puts("<input type=hidden name=\"tmenu\" value=\"netconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"lansetup\">");
  puts("<input type=hidden name=\"act\" value=\"\">");
  puts("<input type=hidden name=commit value=\"\">");
  get_wan_ifname("wan1", &v24);
  get_ifconfig(&v24, &v20, &v19);
  inet_aton(&v20, &inp);
  inet_aton(&v19, &v25);
  inp.s_addr &= v25.s_addr;
  v1 = inet_ntoa(inp);
  printf("<input type=hidden name=\"wan1subnet\" value=\"%s\">\n", v1);
  printf("<tr><td colspan=2 class=itemdesc_td>%s</td>", "내부 IP주소");
  get_ifconfig("br0", &v20, &v19);
  puts("<td class=\"item_td\" width=450 >");
  sub_157CC((int)"ip", &v20, 1);
  v2 = puts("</td>");
  etr(v2);
  printf("<tr><td colspan=2 class=itemdesc_td>%s</td>", "서브넷 마스크");
  puts("<td class=item_td>");
  sub_157CC((int)"sm", &v19, 2);
  v3 = puts("</td>");
  etr(v3);
  strcpy(&v23, "");
  strcpy(&v22, "");
  strcpy(&v21, "");
  iconfig_get_value_direct("lan_gateway", &v23);
  v4 = get_dns_shadow("br0", "local", &v22, &v21);
  str(v4);
  v5 = printf("<td width=15px class=itemdesc_td>");
  get_use_local_gateway(v5);
  printf("<input type=checkbox name=use_local_gateway value=1 %s onclick=\"ChangeLanIPSetupForm(document.netconf_lansetup1, 0)\" >");
  printf("</td><td width=200px class=itemdesc_td>");
  v6 = printf("%s", "내부 게이트웨이");
  br(v6);
  printf("%s", "내부 DNS 주소");
  printf((const char *)&unk_5998A);
  v7 = sub_157CC((int)"gw", &v23, 0);
  br(v7);
  sub_157CC((int)"fdns", &v22, 0);
  print_nbsp(5);
  sub_157CC((int)"sdns", &v21, 0);
  v8 = puts("</td>");
  etr(v8);
  v9 = istatus_get_intvalue_direct("lanwan_samenetwork");
  if ( v9 == 1 )
  {
    get_localbroadaddr("br0", &v18);
    v10 = inet_addr(&v18);
    v11 = inet_ntoa((struct in_addr)__rev(__rev(v10) + 2));
    v12 = strcpy((char *)&v17, v11);
    str(v12);
    puts("<td class=item_td colspan=3>");
    printf("<br><b>인터넷에 연결되기 위해서는 내부 IP주소를 변경 해야 합니다.</b><br>");
    printf("인터넷 설정이 익숙치 않다면,<br>1) 아래의 체크박스를 누른 후,<br>");
    print_nbsp(5);
    printf(
      "<input type=checkbox onclick=\"if(this.checked == true) SetIP('ip','%s'); else SetIP('ip','%s');\">",
      &v17,
      &v20);
    printf("자동으로 내부IP주소 변경하기<br>");
    printf("2) [ 적용 후 시스템 다시 시작] 버튼을 클릭합니다.<br><br>");
    v13 = puts("</td>");
    v9 = etr(v13);
  }
  str(v9);
  puts("<td class=item_td align=right colspan=3>");
  printf("<input class=\"navi_bt\" type=button name=\"apply_bt\" VALUE=\"적용 후 시스템 다시 시작 \" onclick=\"CheckLanIPChange(document.netconf_lansetup1)\" >");
  v14 = puts("</td>");
  etr(v14);
  puts("</form>");
  v15 = printf("<script> ChangeLanIPSetupForm(document.netconf_lansetup1, 1); </script>");
  return print_end_content_table(v15);
}
// 102F8: using guessed type int __fastcall get_wan_ifname(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10CF4: using guessed type int __fastcall iconfig_get_value_direct(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11264: using guessed type int __fastcall get_localbroadaddr(_DWORD, _DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11570: using guessed type int __fastcall get_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 1163C: using guessed type int __fastcall get_use_local_gateway(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001DC20) --------------------------------------------------------
int sub_1DC20()
{
  int v0; // r0@1
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r0@1
  char *v4; // r1@2
  char *v5; // r1@5
  int v6; // r0@8
  int v7; // r0@10
  int v8; // r0@10
  int v9; // r0@10
  int v10; // r0@10
  int v11; // r0@10
  int v12; // r0@10
  int v13; // r0@10
  char *v14; // r1@11
  int v15; // r0@13
  int v16; // r0@13
  int v17; // r0@13
  char *v18; // r1@14
  int v19; // r0@16
  int v20; // r0@16
  int v21; // r0@16
  int v22; // r0@16
  char v24; // [sp+8h] [bp-3C8h]@1
  char v25; // [sp+18h] [bp-3B8h]@10
  char v26; // [sp+2Ch] [bp-3A4h]@10
  int v27; // [sp+94h] [bp-33Ch]@10
  char v28; // [sp+9Ch] [bp-334h]@10

  v0 = dhcpd_read_config(&v24);
  v1 = dhcpd_get_op(v0);
  v2 = print_sub_title("DHCP 서버 상태/설정", 0);
  print_start_content_table(v2);
  puts("<form method=get action=timepro.cgi name=netconf_lansetup2>");
  puts("<input type=hidden name=tmenu value=netconf>");
  puts("<input type=hidden name=smenu value=lansetup>");
  v3 = puts("<input type=hidden name=act value=>");
  str(v3);
  print_item_desc("DHCP 서버 설정");
  printf("<td width=250 class=item_td>");
  if ( v1 )
    v4 = "checked";
  else
    v4 = "";
  printf(
    "<input type=radio class=\"navi_radio\" name=dhcp_enable value=on %s onclick=\"ChangeDHCPServerOp();\"> \n",
    v4);
  printf("실행");
  print_nbsp(10);
  if ( v1 )
    v5 = "";
  else
    v5 = "checked";
  printf(
    "<input type=radio class=\"navi_radio\" name=dhcp_enable %s value=off onclick=\"ChangeDHCPServerOp();\"> \n",
    v5);
  printf("중지");
  if ( v1 )
  {
    v6 = get_dhcp_auto_detect_status("br0");
    if ( v6 )
    {
      br(v6);
      printf((const char *)&unk_59DCA);
    }
  }
  puts("</td>");
  print_item_desc("DNS Suffix");
  printf("<td class=\"item_td\">");
  printf("<input type=text name=domain size=20 maxlength=30 value=\"%s\">", &v28);
  v7 = puts("</td>");
  v8 = etr(v7);
  str(v8);
  print_item_desc("동적 IP 주소 범위");
  printf("<td class=item_td colspan=3 width=400>");
  sub_157CC((int)"spool_conf", &v25, 2);
  printf(" ~ &nbsp;");
  sub_157CC((int)"epool_conf", &v26, 2);
  v9 = puts("</td>");
  v10 = etr(v9);
  str(v10);
  print_item_desc("IP 대여 시간");
  printf("<td class=item_td colspan=3 width=400>");
  printf("<input type=text name=leasetime size=10 maxlength=10 value=%d> %s", v27, "초");
  v11 = puts("</td>");
  v12 = etr(v11);
  str(v12);
  v13 = puts("<td class=\"item_td\" colspan=4>");
  if ( get_dhcp_auto_detect(v13) )
    v14 = "checked";
  else
    v14 = "";
  printf(
    "<input type=checkbox class=\"navi_chk\" name=\"dhcp_auto_detect\" %s> &nbsp;%s",
    v14,
    "내부네트워크에서 DHCP서버 발견시 공유기의 DHCP 서버기능을 중단");
  v15 = puts("</td>");
  v16 = etr(v15);
  str(v16);
  v17 = puts("<td class=\"item_td\" colspan=4>");
  if ( get_dhcp_access_policy(v17) )
    v18 = "checked";
  else
    v18 = "";
  printf(
    "<input type=checkbox class=\"navi_chk\" name=\"dhcp_access_policy\" %s> &nbsp;%s",
    v18,
    "IP를 할당받은 PC만 인터넷 접속을 허용");
  v19 = puts("</td>");
  v20 = etr(v19);
  str(v20);
  puts("<td class=item_td align=right colspan=4>");
  puts("<input type=\"button\" class=\"navi_bt\" name=\"int_save\" value=\"적용\" onclick=\"applyLansetupDhcp()\">");
  v21 = puts("</td>");
  etr(v21);
  puts("<script language=JavaScript>");
  puts("<!--");
  puts("ChangeDHCPServerOp()");
  puts("-->");
  puts("</script>");
  v22 = printf("</form>");
  return print_end_content_table(v22);
}
// 10754: using guessed type int __fastcall get_dhcp_auto_detect_status(_DWORD);
// 10988: using guessed type int __fastcall dhcpd_get_op(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10B44: using guessed type int __fastcall get_dhcp_access_policy(_DWORD);
// 10CA0: using guessed type int __fastcall get_dhcp_auto_detect(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001DF3C) --------------------------------------------------------
signed int __fastcall sub_1DF3C(int a1)
{
  int v1; // r6@1
  int v2; // r4@2
  int v4; // r0@5
  int v5; // r0@8
  char v6; // [sp+8h] [bp-40h]@1
  char v7; // [sp+1Ch] [bp-2Ch]@5

  v1 = a1;
  if ( get_value_post(a1, "act", &v6, 20) )
  {
    v2 = 0;
  }
  else
  {
    v2 = strcmp(&v6, "remove");
    if ( v2 )
      return 0;
  }
  while ( 1 )
  {
    v4 = get_value_array_post(v1, "dellease", v2, &v7);
    if ( !v4 )
      break;
    dhcpd_remove_static_lease(&v7, 0);
    ++v2;
  }
  if ( v2 )
  {
    v5 = dhcpd_stop(0);
    v4 = dhcpd_start(v5);
  }
  signal_save(v4);
  return 1;
}
// 100AC: using guessed type int __fastcall dhcpd_start(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10880: using guessed type int __fastcall dhcpd_remove_static_lease(_DWORD, _DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 114C8: using guessed type int __cdecl dhcpd_stop(_DWORD);
// 11624: using guessed type int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001DFE8) --------------------------------------------------------
int __fastcall sub_1DFE8(int a1, int a2)
{
  signed int v2; // r0@1
  signed int v3; // r5@3
  char *v4; // r6@3
  const char *v5; // r4@3
  signed int v6; // r11@3
  bool v7; // zf@4
  const char *v8; // r1@5
  const char *v9; // r1@8
  const char *v10; // r1@14
  const char *v11; // r0@18
  void *v12; // r1@18
  int v13; // r2@18
  const char *v14; // r3@18
  char *v15; // r0@19
  char *v16; // r0@20
  signed int v17; // r9@24
  int result; // r0@25
  signed int v19; // [sp+4h] [bp-44h]@3
  char v20; // [sp+Ch] [bp-3Ch]@10

  v2 = a2;
  if ( a2 )
    v2 = sub_1DF3C(a2);
  v19 = v2;
  v3 = 0;
  puts("<BODY BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
  printf("<form name=static_lease_fm method=post>");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=static_lease>");
  printf("<input type=hidden name=act value=>");
  puts("<table class=content_table cellspacing=0px cellpadding=0px width=280 border=0>");
  v4 = (char *)malloc(0x6C00u);
  v5 = v4;
  memset(v4, 0, 0x6C00u);
  v6 = dhcpd_get_all_static_lease(v4, 256);
  qsort(v4, v6, 0x6Cu, (__compar_fn_t)sub_1D884);
  while ( 1 )
  {
    v17 = v3;
    if ( v3 >= v6 )
      break;
    printf("<tr onmouseover=\"ChangeToOverColor(this);\" onmouseout=\"ChangeToOutColor(this)\">");
    v7 = v3++ == 0;
    if ( v7 )
      v8 = "slim_notop_item_td";
    else
      v8 = "slim_item_td";
    printf("<td width=20 class=%s align=right>%d</td>\n", v8, v3);
    if ( v17 )
      v9 = "slim_item_td";
    else
      v9 = "slim_notop_item_td";
    printf("<td width=35 class=%s align=left>\n", v9);
    printf("<input type=checkbox class=navi_chk name=dellease value='%s' ", v5);
    if ( get_wan_ip("wan1", &v20) && !strcmp(&v20, v5) )
      printf(" disabled ");
    puts("></td>");
    if ( v17 )
      v10 = "slim_item_td";
    else
      v10 = "slim_notop_item_td";
    printf("<td class=%s colspan=1>", v10);
    print_nbsp(2);
    convert_mac(v5 + 20);
    if ( get_wan_ip("wan1", &v20) && !strcmp(&v20, v5) )
    {
      v11 = "<span class=navy_string>%s/%s<br>&nbsp;&nbsp;%s</span>";
      v12 = (void *)v5;
      v13 = (int)(v5 + 20);
      v14 = "Twin IP로 설정된 PC";
LABEL_21:
      printf(v11, v12, v13, v14);
      goto LABEL_23;
    }
    v15 = getenv("REMOTE_ADDR");
    if ( !strcmp(v15, v5) )
    {
      v16 = getenv("REMOTE_ADDR");
      v14 = "현재 접속된 PC";
      v12 = v16;
      v11 = "<span class=navy_string>%s/%s<br>&nbsp;&nbsp;%s</span>";
      v13 = (int)(v5 + 20);
      goto LABEL_21;
    }
    printf("%s / %s", v5, v5 + 20);
LABEL_23:
    v5 += 108;
    puts("</td>");
    printf("</tr>");
  }
  free(v4);
  puts("</table>");
  puts("</form>");
  result = puts("</BODY>");
  if ( v19 )
    result = printf("<script> RemovePostSubmit(); </script>");
  return result;
}
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 110F0: using guessed type int __fastcall dhcpd_get_all_static_lease(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);

//----- (0001E274) --------------------------------------------------------
signed int __fastcall sub_1E274(int a1)
{
  int v1; // r4@1
  int v3; // r7@6
  const char *v4; // r0@7
  char *v5; // r1@7
  int i; // r7@11
  int v7; // r0@12
  int v8; // r10@13
  int v9; // r0@18
  int v10; // r0@18
  char v11; // [sp+8h] [bp-90h]@13
  char v12; // [sp+28h] [bp-70h]@1
  char v13; // [sp+48h] [bp-50h]@6
  char v14; // [sp+5Ch] [bp-3Ch]@6

  v1 = a1;
  if ( !get_value_post(a1, "act", &v12, 32) && strcmp(&v12, "add") )
    return 0;
  if ( get_value_post(v1, "manual_check", &v12, 32) && !strcmp(&v12, "on") )
  {
    get_ip_value_post(v1, "manual_ip", &v13);
    get_hw_value_post(v1, "manual_hw", &v14);
    v3 = dhcpd_add_static_lease(&v13, &v14);
    convert_mac(&v14);
    if ( v3 == 1 )
    {
      v4 = "<script> alert(STATIC_LEASE_ALREADY_EXIST_IPADDRESS + ':%s'); </script>";
      v5 = &v13;
    }
    else
    {
      if ( v3 != 2 )
        goto LABEL_11;
      v4 = "<script> alert(STATIC_LEASE_ALREADY_EXIST_HWADDRESS + ':%s'); </script>";
      v5 = &v14;
    }
    printf(v4, v5);
  }
LABEL_11:
  for ( i = 0; ; ++i )
  {
    v7 = get_value_array_post(v1, "addlease", i, &v12);
    if ( !v7 )
      break;
    v8 = atoi(&v12);
    sprintf(&v11, "m%d", v8);
    v7 = get_value_post(v1, &v11, &v14, 20);
    if ( !v7 )
      break;
    v7 = check_unpermitted_chars(&v14);
    if ( v7 )
      break;
    sprintf(&v11, "i%d", v8);
    v7 = get_value_post(v1, &v11, &v13, 20);
    if ( !v7 )
      break;
    v7 = check_unpermitted_chars(&v13);
    if ( v7 )
      break;
    dhcpd_add_static_lease(&v13, &v14);
  }
  v9 = dhcpd_stop(v7);
  v10 = dhcpd_start(v9);
  signal_save(v10);
  return 1;
}
// 100AC: using guessed type int __fastcall dhcpd_start(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 113D8: using guessed type int __fastcall get_hw_value_post(_DWORD, _DWORD, _DWORD);
// 113FC: using guessed type int __fastcall dhcpd_add_static_lease(_DWORD, _DWORD);
// 114C8: using guessed type int __cdecl dhcpd_stop(_DWORD);
// 11624: using guessed type int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11888: using guessed type int __fastcall get_ip_value_post(_DWORD, _DWORD, _DWORD);

//----- (0001E460) --------------------------------------------------------
void __fastcall sub_1E460(int a1, int a2)
{
  signed int v2; // r0@1
  signed int v3; // r11@3
  void *v4; // r4@3
  int v5; // r9@3
  int v6; // r0@3
  int v7; // r0@3
  int v8; // r0@3
  char *v9; // r0@3
  int v10; // r5@3
  void *v11; // r8@4
  int i; // r7@4
  char *v13; // r0@11
  char *v14; // r0@11
  char *v15; // r0@11
  char *v16; // r0@12
  void *v17; // r7@12
  int v18; // r10@12
  const char *v19; // r3@17
  int v20; // r1@19
  char s1; // [sp+4h] [bp-64h]@3
  char v22; // [sp+18h] [bp-50h]@3
  char v23; // [sp+2Ch] [bp-3Ch]@3

  v2 = a2;
  if ( a2 )
    v2 = sub_1E274(a2);
  v3 = v2;
  v4 = malloc(0xBC00u);
  memset(v4, 0, 0xBC00u);
  v5 = get_hostinfo_from_arp("br0", 256, v4);
  get_ifconfig("br0", &v23, &v22);
  puts("<BODY BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
  printf("<form name=lan_pcinfo_fm method=post>");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=lan_pcinfo>");
  printf("<input type=hidden name=act value=>");
  v6 = puts("<table class=content_table cellspacing=0px cellpadding=0px align=center width=280 border=0>");
  str(v6);
  puts("<td class=slim_notop_item_td valign=top align=left width=24>");
  printf("<input type=checkbox class=navimenu_chk name=\"manual_check\" onclick=\"CheckManualLeaseRegister();\">");
  puts("</td>");
  puts("<td class=slim_notop_item_td colspan=1>");
  print_nbsp(2);
  sub_157CC((int)"manual_ip", 0, 3);
  v7 = printf(" /");
  br(v7);
  print_nbsp(2);
  sub_15664((int)"manual_hw", 0, 0);
  v8 = puts("</td>");
  etr(v8);
  v9 = getenv("REMOTE_ADDR");
  get_internal_pc_hardware_address(v9, &s1);
  v10 = (unsigned __int8)s1;
  if ( s1 )
  {
    v11 = v4;
    for ( i = 0; ; ++i )
    {
      if ( i >= v5 )
      {
        v10 = 0;
        goto LABEL_12;
      }
      v10 = strcmp((const char *)v11 + 148, &s1);
      v11 = (char *)v11 + 188;
      if ( !v10 )
        break;
    }
    if ( !((int (*)(void))dhcpd_search_static_lease)() )
    {
      v10 = 1;
      v13 = getenv("REMOTE_ADDR");
      printf(
        "<tr onmouseover=\"ChangeToOverColor(this);\" onmouseout=\"ChangeToOutColor(this)\" onclick=\"FillManualAddr( '%s','%s')\">",
        v13,
        &s1);
      printf("<td class=slim_item_td align=left width=24>");
      printf("<input type=checkbox class=\"navi_chk\" name=addlease value=0>");
      puts("</td>");
      puts("<td class=slim_item_td colspan=1>");
      print_nbsp(2);
      convert_mac(&s1);
      v14 = getenv("REMOTE_ADDR");
      printf("<span class=navy_string>%s/%s<br>&nbsp;&nbsp;%s</span>", v14, &s1, "현재 접속된 PC");
      puts("</td>");
      printf("</tr>");
      printf("<input type=hidden name=m%d value=%s>\n", 0, &s1);
      v15 = getenv("REMOTE_ADDR");
      printf("<input type=hidden name=i%d value=%s>\n", 0, v15);
    }
  }
LABEL_12:
  v16 = getenv("REMOTE_ADDR");
  v17 = v4;
  get_internal_pc_hardware_address(v16, &s1);
  v18 = 0;
  while ( v18 < v5 )
  {
    if ( !dhcpd_search_static_lease((char *)v17 + 128, 0)
      && !dhcpd_search_static_lease(0, (char *)v17 + 148)
      && strcmp(&s1, (const char *)v17 + 148)
      && check_same_network((char *)v17 + 128, &v23, &v22) )
    {
      printf(
        "<tr style=\"cursor:pointer\" onmouseover=\"ChangeToOverColor(this);\" onmouseout=\"ChangeToOutColor(this)\" oncl"
        "ick=\"FillManualAddr( '%s','%s')\">",
        (char *)v17 + 128,
        (char *)v17 + 148);
      puts("<td class=slim_item_td align=left width=24>");
      printf("<input type=checkbox class=navi_chk name=addlease value=%d>", v10);
      puts("</td>");
      puts("<td class=slim_item_td colspan=1>");
      print_nbsp(2);
      convert_mac((char *)v17 + 148);
      v19 = "*";
      if ( *((_BYTE *)v17 + 128) )
        v19 = (char *)v17 + 128;
      printf("%s / %s", v19, (char *)v17 + 148);
      puts("</td>");
      printf("</tr>");
      printf("<input type=hidden name=m%d value=%s>\n", v10, (char *)v17 + 148);
      v20 = v10++;
      printf("<input type=hidden name=i%d value=%s>\n", v20, (char *)v17 + 128);
    }
    ++v18;
    v17 = (char *)v17 + 188;
  }
  puts("</table>");
  puts("</form>");
  puts("</BODY>");
  printf("<script> InitStaticIPLease() </script>");
  if ( v3 )
    printf("<script> AddPostSubmit(); </script>");
  free(v4);
}
// 1040C: using guessed type int __fastcall get_hostinfo_from_arp(_DWORD, _DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11984: using guessed type int __fastcall check_same_network(_DWORD, _DWORD, _DWORD);
// 1199C: using guessed type int __fastcall dhcpd_search_static_lease(_DWORD, _DWORD);

//----- (0001E844) --------------------------------------------------------
int sub_1E844()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  char *v3; // r1@2
  int v4; // r0@4
  int v5; // r0@4
  char *v6; // r1@5
  int v7; // r0@7
  int v8; // r0@7
  int v9; // r0@7
  int v10; // r0@7
  int v11; // r0@7
  int v12; // r0@7
  int v13; // r0@7
  int v14; // r0@7
  char *v15; // r0@7
  int v16; // r0@7
  int v17; // r0@8
  int v18; // r0@10
  int v19; // r0@11
  int v20; // r0@13
  int v21; // r0@13
  int v22; // r0@13
  int v23; // r0@13
  char v25; // [sp+4h] [bp-3DCh]@13
  int v26; // [sp+94h] [bp-34Ch]@13
  char v27; // [sp+3BCh] [bp-24h]@7

  printf("<form method=get name=staticlease_fm>");
  print_sub_title("수동 IP 할당 설정", 0);
  puts("<input type=hidden name=\"tmenu\" value=\"netconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"lansetup\">");
  v0 = puts("<input type=hidden name=\"act\" value=\"\">");
  v1 = print_start_content_table(v0);
  str(v1);
  v2 = printf("<td align=left class=itemdesc_td >");
  if ( get_ipmac_bind(v2) & 2 )
    v3 = "checked";
  else
    v3 = "";
  v4 = printf(
         "<input type=checkbox name=ipmac_bind value=1 %s>%s",
         v3,
         "설정된 IP와  다른 IP를 가진 MAC주소 통신 차단");
  v5 = br(v4);
  if ( get_ipmac_bind(v5) & 1 )
    v6 = "checked";
  else
    v6 = "";
  printf("<input type=checkbox name=mac_restrict value=1 %s>%s", v6, "설정된 MAC주소 통신만 허용");
  printf("</td>");
  printf("<td align=right width=40 class=item_td>");
  printf("<input type=button name=ipbind_apply_bt value=\"%s\" onclick=\"ApplyIPMACBind();\">", "적용");
  v7 = printf("</td>");
  v8 = etr(v7);
  print_end_content_table(v8);
  v9 = print_blank_line(1, 20);
  v10 = print_start_content_table(v9);
  str(v10);
  printf("<td align=left class=slim_itemdesc_td width=22>&nbsp;</td>");
  puts("<td width=60 align=left class=slim_itemdesc_td>");
  v11 = printf(
          "<input type=button name=\"mac_bt\" class=\"navi_bt\" value=\"%s\" onclick=\"RemoveStaticLease();\">\n",
          "삭제");
  br(v11);
  puts("<input type=checkbox name=\"del_allchk\" onclick=\"CheckAllCheckBox(static_lease.document, this, 'dellease');\">");
  puts("</td>");
  puts("<td align=left width=240 class=slim_itemdesc_td>");
  printf("<span class=bold_item_text>%s</span>", "설정된 IP/MAC 주소");
  puts("</td>");
  puts("<td align=left class=slim_itemdesc_td style=\"padding:0 2\">");
  v12 = printf("<input type=button class=navi_bt name=add_bt value=\"%s\" onclick=\"AddStaticLease();\">", "추가");
  br(v12);
  puts("<input type=checkbox name=\"add_allchk\" onclick=\"CheckAllCheckBox(lan_pcinfo.document, this, 'addlease');\">");
  puts("</td>");
  puts("<td align=left width=240 class=slim_itemdesc_td>");
  printf("<span class=bold_item_text>%s</span>", "검색된 IP/MAC 주소");
  v13 = puts("</td>");
  v14 = etr(v13);
  str(v14);
  printf("<td colspan=3 class=slim_item_td >");
  v15 = getenv("REMOTE_ADDR");
  v16 = get_internal_pc_hardware_address(v15, &v27);
  if ( is_mobile_agent(v16) )
  {
    sub_1682C((int)"150px", (int)"300px", (int)"");
    v17 = puts("<iframe src=\"timepro.cgi?tmenu=iframe&smenu=static_lease\" frameborder=\"no\" scrolling=\"auto\" name=static_lease noresize height=150 width=300 ></iframe>");
    sub_16878(v17);
  }
  else
  {
    puts("<iframe src=\"timepro.cgi?tmenu=iframe&smenu=static_lease\" frameborder=\"no\" scrolling=\"auto\" name=static_lease noresize height=150 width=300 ></iframe>");
  }
  puts("</td>");
  v18 = printf("<td colspan=2 class=slim_item_leftline_td>");
  if ( is_mobile_agent(v18) )
  {
    sub_1682C((int)"150px", (int)"300px", (int)"");
    v19 = puts("<iframe src=\"timepro.cgi?tmenu=iframe&smenu=lan_pcinfo\" frameborder=\"no\" scrolling=\"auto\" name=lan_pcinfo noresize height=150 width=300 ></iframe>");
    sub_16878(v19);
  }
  else
  {
    puts("<iframe src=\"timepro.cgi?tmenu=iframe&smenu=lan_pcinfo\" frameborder=\"no\" scrolling=\"auto\" name=lan_pcinfo noresize height=150 width=300 ></iframe>");
  }
  v20 = puts("</td>");
  v21 = etr(v20);
  str(v21);
  printf("<td class=item_td colspan=4><font color='gray'>");
  dhcpd_read_config(&v25);
  printf("등록 가능한 최대 MAC 주소는 %d개 입니다.", v26);
  v22 = printf("</td>");
  v23 = etr(v22);
  print_end_content_table(v23);
  return printf("</form>");
}
// 102C8: using guessed type int __fastcall get_ipmac_bind(_DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0001EB1C) --------------------------------------------------------
int __fastcall sub_1EB1C(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  int v3; // r0@11
  int v4; // r0@11
  int v5; // [sp+0h] [bp-480h]@9
  int v6; // [sp+10h] [bp-470h]@9
  int v7; // [sp+24h] [bp-45Ch]@9
  char v8; // [sp+38h] [bp-448h]@9
  int v9; // [sp+4Ch] [bp-434h]@9
  int v10; // [sp+60h] [bp-420h]@9
  char v11; // [sp+3B8h] [bp-C8h]@1
  char v12; // [sp+3D8h] [bp-A8h]@9
  char v13; // [sp+3ECh] [bp-94h]@9
  char v14; // [sp+400h] [bp-80h]@7
  int v15; // [sp+414h] [bp-6Ch]@7
  int v16; // [sp+428h] [bp-58h]@6
  int v17; // [sp+43Ch] [bp-44h]@4
  char dest; // [sp+450h] [bp-30h]@3
  int v19; // [sp+464h] [bp-1Ch]@11

  v1 = a1;
  result = get_value(a1, "commit", &v11, 32);
  if ( result )
  {
    result = strcmp(&v11, "lanip_chg");
    if ( !result )
    {
      strcpy(&dest, "");
      result = get_ip_value(v1, "ip", &dest);
      if ( result )
      {
        result = get_ip_value(v1, "sm", &v17);
        if ( result )
        {
          get_value(v1, "use_local_gateway", &v11, 32);
          if ( !strcmp(&v11, "1") && get_ip_value(v1, "gw", &v16) )
          {
            set_use_local_gateway(1);
            set_lan_ipconfig(&dest, &v17, &v16);
            get_ip_value(v1, "fdns", &v15);
            get_ip_value(v1, "sdns", &v14);
            set_dns_shadow("br0", "local", &v15, &v14);
          }
          else
          {
            set_use_local_gateway(0);
            set_lan_ipconfig(&dest, &v17, 0);
          }
          dhcpd_read_config(&v5);
          sf_strncpy(&v8, &dest, 20);
          sf_strncpy(&v9, &v17, 20);
          get_subnet_range(&dest, &v17, &v6, &v7);
          get_ifconfig("br0", &v13, &v12);
          if ( !strcmp((const char *)&v10, &v13) )
            sf_strncpy(&v10, &dest, 20);
          v3 = dhcpd_commit_config(&v5);
          dhcpd_flush_dynamic_lease(v3);
          v4 = get_intvalue(v1, "wizard", &v19);
          if ( v4 )
          {
            if ( v19 )
              v4 = set_wan_type("wan1", "dynamic");
          }
          result = saveconf(v4);
        }
      }
    }
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 104B4: using guessed type int __fastcall set_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A90: using guessed type int __fastcall dhcpd_flush_dynamic_lease(_DWORD);
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 10DA8: using guessed type int __fastcall set_wan_type(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11354: using guessed type int __fastcall dhcpd_commit_config(_DWORD);
// 114A4: using guessed type int __fastcall set_use_local_gateway(_DWORD);
// 117E0: using guessed type int __fastcall get_subnet_range(_DWORD, _DWORD, _DWORD, _DWORD);
// 11828: using guessed type int __fastcall set_lan_ipconfig(_DWORD, _DWORD, _DWORD);

//----- (0001ED78) --------------------------------------------------------
int __fastcall sub_1ED78(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  int v3; // r0@5
  int v4; // r0@9
  int v5; // r0@13
  int v6; // r0@15
  int v7; // r0@15
  int v8; // r4@17
  int v9; // r0@18
  int v10; // r0@18
  int v11; // r0@18
  signed int v12; // r6@22
  int v13; // r0@27
  int v14; // [sp+0h] [bp-410h]@5
  char v15; // [sp+10h] [bp-400h]@5
  char v16; // [sp+24h] [bp-3ECh]@5
  char v17; // [sp+38h] [bp-3D8h]@15
  char v18; // [sp+4Ch] [bp-3C4h]@15
  char v19; // [sp+60h] [bp-3B0h]@7
  char v20; // [sp+74h] [bp-39Ch]@7
  char v21; // [sp+8Ch] [bp-384h]@7
  char v22; // [sp+94h] [bp-37Ch]@5
  char v23; // [sp+3B8h] [bp-58h]@1
  char v24; // [sp+3D8h] [bp-38h]@15
  char v25; // [sp+3ECh] [bp-24h]@15

  v1 = a1;
  result = get_value(a1, "act", &v23, 32);
  if ( result )
  {
    if ( !strcmp(&v23, "dhcp_conf") )
    {
      if ( get_value(v1, "dhcp_enable", &v23, 32) && !strcmp(&v23, "on") )
      {
        dhcpd_set_op(1);
        v3 = dhcpd_read_config(&v14);
        dhcpd_stop(v3);
        get_ip_value(v1, "spool_conf", &v15);
        get_ip_value(v1, "epool_conf", &v16);
        get_value(v1, "domain", &v22, 32);
        if ( check_unpermitted_chars(&v22) )
          strcpy(&v22, "");
        get_intvalue(v1, "leasetime", &v21);
        get_domain_name_server(&v19, &v20);
        set_autodns(1);
        v4 = get_value(v1, "dhcp_auto_detect", &v23, 32) && !strcmp(&v23, "on");
        set_dhcp_auto_detect(v4);
        v5 = get_value(v1, "dhcp_access_policy", &v23, 32) && !strcmp(&v23, "on");
        set_dhcp_access_policy(v5);
        get_ifconfig("br0", &v25, &v24);
        sf_strncpy(&v17, &v25, 20);
        sf_strncpy(&v18, &v24, 20);
        v6 = dhcpd_commit_config(&v14);
        dhcpd_start(v6);
        v7 = syslog_msg(1, "관리자가 DHCP 서버를 실행함");
      }
      else
      {
        v7 = get_value(v1, "dhcp_enable", &v23, 32);
        if ( v7 )
        {
          v7 = strcmp(&v23, "off");
          v8 = v7;
          if ( !v7 )
          {
            dhcpd_set_op(0);
            set_dhcp_auto_detect(v8);
            v9 = set_dhcp_access_policy(v8);
            v10 = dhcpd_stop(v9);
            dhcpd_flush_dynamic_lease(v10);
            v11 = syslog_msg(2, "관리자가 DHCP 서버를 중지함");
            v7 = check_twinip_enable(v11);
            if ( v7 )
              v7 = dhcpd_start(v7);
          }
        }
      }
    }
    else
    {
      v7 = strcmp(&v23, "ipbind");
      if ( !v7 )
      {
        if ( get_value(v1, "ipmac_bind", &v23, 32) )
          v12 = 2;
        else
          v12 = 0;
        if ( get_value(v1, "mac_restrict", &v23, 32) )
          v12 |= 1u;
        v7 = set_ipmac_bind(v12);
      }
    }
    v13 = signal_update(v7);
    result = signal_save(v13);
  }
  return result;
}
// 100AC: using guessed type int __fastcall dhcpd_start(_DWORD);
// 101A8: using guessed type int __fastcall set_autodns(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1028C: using guessed type int __fastcall set_dhcp_access_policy(_DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10784: using guessed type int __fastcall set_dhcp_auto_detect(_DWORD);
// 10A48: using guessed type int __fastcall dhcpd_set_op(_DWORD);
// 10A90: using guessed type int __fastcall dhcpd_flush_dynamic_lease(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 111A4: using guessed type int __fastcall dhcpd_read_config(_DWORD);
// 11354: using guessed type int __fastcall dhcpd_commit_config(_DWORD);
// 114C8: using guessed type int __cdecl dhcpd_stop(_DWORD);
// 115DC: using guessed type int __fastcall get_domain_name_server(_DWORD, _DWORD);
// 119B4: using guessed type int __fastcall set_ipmac_bind(_DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11C9C: using guessed type int __fastcall check_twinip_enable(_DWORD);

//----- (0001F090) --------------------------------------------------------
int __fastcall sub_1F090(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r6@1

  v3 = a3;
  v4 = a1;
  v5 = a2;
  printf("<TR height=20 ID=%s STYLE=\"cursor:pointer; background-color:#%s;\" ONCLICK=\"clickSysconf(this);\">", a1);
  return printf("<TD></TD><TD>%s</TD><TD CLASS=text_gray ID=%s_value >%s</TD><TD>%s</TD></TR>\n", v5, v4, v3);
}

//----- (0001F0F0) --------------------------------------------------------
int sub_1F0F0()
{
  printf("<TR height=20 STYLE=\"cursor:pointer; background-Color:#%s\">");
  return printf("<TD></TD><TD></TD><TD CLASS=text_gray></TD><TD></TD></TR>");
}

//----- (0001F128) --------------------------------------------------------
int __fastcall sub_1F128(int a1, int a2, char *a3)
{
  int v3; // r7@1
  bool v4; // zf@1
  int v5; // r4@1
  int v6; // r1@6
  char *v7; // r2@7
  int v8; // r3@9

  v3 = a2;
  v4 = a3 == 0;
  v5 = 0;
  if ( !a3 )
    a3 = "";
  if ( !v4 )
    a3 = "disabled";
  printf("<select name=%s %s>", a1, a3, "disabled");
  do
  {
    v6 = v5;
    if ( v5 == v3 )
      v7 = "selected";
    else
      v7 = "";
    v8 = v5++;
    printf("<option value=%d %s >%d", v6, v7, v8);
  }
  while ( v5 != 24 );
  return printf("</select>");
}

//----- (0001F1A8) --------------------------------------------------------
int sub_1F1A8()
{
  int v1; // [sp+0h] [bp-108h]@1

  get_hostname(&v1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td colspan=4 style=\"padding-left:5px;\">");
  printf("<input type=text name=hostname  size=60 maxlength=60 value='%s'>", &v1);
  printf("</td></tr>");
  return printf("</TABLE>");
}
// 11B10: using guessed type int __fastcall get_hostname(_DWORD);

//----- (0001F204) --------------------------------------------------------
int __fastcall sub_1F204(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_autosaving(a1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;width:\" colspan=4>");
  if ( v1 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=autosaving value=1 %s> %s", v2, "실행");
  print_nbsp(10);
  if ( v1 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=autosaving value=0 %s> %s", v3, "중단");
  printf("</td></tr>");
  return printf("</TABLE>");
}
// 10BA4: using guessed type int __fastcall get_autosaving(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0001F29C) --------------------------------------------------------
int __fastcall sub_1F29C(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_fakedns(a1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=fakedns value=1 %s > %s", v2, "실행");
  print_nbsp(10);
  if ( v1 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=fakedns value=0 %s > %s", v3, "중단");
  printf("</td></tr>");
  printf("<tr height=5><td colspan=4>&nbsp;</td></tr>");
  printf(
    "<tr valign=bottom height=10><td colspan=4 style=\"padding-left:5px;\"><span class=gray_text><LI>%s</span></td></tr>",
    "인터넷 끊김시 공유기 설정화면으로 자동으로 연결되는 기능");
  return printf("</TABLE>");
}
// 1001C: using guessed type int __fastcall get_fakedns(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0001F354) --------------------------------------------------------
int __fastcall sub_1F354(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_nologin(a1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "";
  else
    v2 = "checked";
  printf(
    "<input type=radio name=nologin value=0 %s > %s",
    v2,
    "설정 화면 접속시 로그인 페이지를 보여줍니다.");
  printf("</td></tr><tr height=23px><td style=\"padding-left:5px;\"colspan=4 >");
  if ( v1 )
    v3 = "checked";
  else
    v3 = "";
  printf(
    "<input type=radio name=nologin value=1 %s > %s",
    v3,
    "설정 화면 접속시 로그인 페이지를 보여주지 않습니다.");
  printf("</td></tr>");
  return printf("</TABLE>");
}
// 10A54: using guessed type int __fastcall get_nologin(_DWORD);

//----- (0001F3F0) --------------------------------------------------------
int __fastcall sub_1F3F0(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_wbm_popup_flag(a1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=wbmpopup value=1 %s > %s", v2, "팝업으로 새 창 띄움");
  print_nbsp(10);
  if ( v1 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=wbmpopup value=0 %s > %s", v3, "현재 창 사용");
  printf("</td></tr>");
  return printf("</TABLE>");
}
// 102BC: using guessed type int __fastcall get_wbm_popup_flag(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0001F488) --------------------------------------------------------
int sub_1F488()
{
  char *v0; // r2@1
  char *v1; // r2@3
  int v2; // r0@5
  int v3; // r0@5
  int result; // r0@5
  int v5; // r0@7
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@5

  get_led_silent_control(&v6);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  printf("<input type=radio name=led value=%d onclick=\"OnClickSilentLED_2();\" %s> %s");
  printf("</td></tr>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  printf("<input type=radio name=led value=%d onclick=\"OnClickSilentLED_2();\" %s> %s");
  printf("</td></tr>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  printf("<input type=radio name=led value=%d onclick=\"OnClickSilentLED_2();\" %s> ");
  v0 = (char *)(v6 - 2);
  if ( v6 != 2 )
    v0 = (char *)1;
  sub_1F128((int)"ledstart", v7, v0);
  printf("시 부터 ");
  v1 = (char *)(v6 - 2);
  if ( v6 != 2 )
    v1 = (char *)1;
  sub_1F128((int)"ledend", v8, v1);
  printf("시 까지 공유기의 LED를 끕니다.");
  v2 = printf("</td></tr></table>");
  br(v2);
  printf("<table border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%><tr><td height=5 colspan=4 style=\"padding-left:5px;\">");
  printf("<span class=gray_text><li>");
  printf("%s", "일부 LED는 꺼지지 않을 수 있습니다.");
  printf("</span>");
  v3 = printf("</td></tr></table>");
  result = get_timed_status(v3);
  if ( !result && v6 == 2 )
  {
    br(0);
    v5 = printf("<span class=gray_text>주의) 공유기가 시스템시간을 인터넷으로 부터 얻어오지 못했습니다.</span>");
    br(v5);
    print_nbsp(10);
    result = printf("<span class=gray_text><a href=\"JavaScript:MovePagetoMain('sysconf','realtime');\">[시스템 시간 설정]</a>페이지에서 설정이 올바른지 확인하십시오.</span>");
  }
  return result;
}
// 10C28: using guessed type int __fastcall get_led_silent_control(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (0001F638) --------------------------------------------------------
int __fastcall sub_1F638(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_macclone_in_giga(a1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "";
  else
    v2 = "checked";
  printf("<input type=radio name=macclone_giga value=0 %s > %s", v2, "실행");
  print_nbsp(10);
  if ( v1 )
    v3 = "checked";
  else
    v3 = "";
  printf("<input type=radio name=macclone_giga value=1 %s > %s", v3, "중단");
  printf("</td></tr>");
  return printf("</TABLE>");
}
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 1133C: using guessed type int __fastcall get_macclone_in_giga(_DWORD);

//----- (0001F6D0) --------------------------------------------------------
int __fastcall sub_1F6D0(int a1, int a2, char *a3)
{
  int v3; // r7@1
  bool v4; // zf@1
  int v5; // r4@1
  int v6; // r1@6
  char *v7; // r2@7
  int v8; // r3@9

  v3 = a2;
  v4 = a3 == 0;
  v5 = 0;
  if ( !a3 )
    a3 = "";
  if ( !v4 )
    a3 = "disabled";
  printf("<select name=%s %s>", a1, a3, "disabled");
  do
  {
    v6 = v5;
    if ( v5 == v3 )
      v7 = "selected";
    else
      v7 = "";
    v8 = v5++;
    printf("<option value=%d %s>%d", v6, v7, v8);
  }
  while ( v5 != 60 );
  return printf("</select>");
}

//----- (0001F750) --------------------------------------------------------
int sub_1F750()
{
  char *v0; // r1@2
  char *v1; // r1@5
  int v2; // r0@7
  char *v3; // r1@8
  char *v4; // r1@11
  char *v5; // r1@14
  char *v6; // r1@17
  char *v7; // r1@20
  char *v8; // r1@23
  char *v9; // r1@26
  char *v10; // r1@29
  int v11; // r0@31
  int v12; // r0@31
  int v13; // r0@33
  int v15; // [sp+0h] [bp-58h]@1
  int v16; // [sp+24h] [bp-34h]@7
  char v17; // [sp+28h] [bp-30h]@10
  char v18; // [sp+29h] [bp-2Fh]@13
  char v19; // [sp+2Ah] [bp-2Eh]@16
  char v20; // [sp+2Bh] [bp-2Dh]@19
  char v21; // [sp+2Ch] [bp-2Ch]@22
  char v22; // [sp+2Dh] [bp-2Bh]@25
  char v23; // [sp+2Eh] [bp-2Ah]@28
  int v24; // [sp+34h] [bp-24h]@31
  int v25; // [sp+38h] [bp-20h]@31
  int v26; // [sp+44h] [bp-14h]@1

  get_autoreboot_config(&v26);
  memset(&v15, 0, 0x44u);
  read_sched_array("autoreboot", &v15, 1);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=40>");
  printf("<td style=\"padding-left:5px;padding-top:2px;\">");
  if ( v26 )
    v0 = "checked";
  else
    v0 = "";
  printf(
    "<input type=radio name=autoreboot value=1 onclick=\"ClickAutoReboot_2(document.sysconf_fm);\" %s> %s",
    v0,
    "실행");
  print_nbsp(10);
  if ( v26 )
    v1 = "";
  else
    v1 = "checked";
  v2 = printf(
         "<input type=radio name=autoreboot value=0 onclick=\"ClickAutoReboot_2(document.sysconf_fm);\" %s> %s",
         v1,
         "중단");
  br(v2);
  if ( v16 )
    v3 = "checked";
  else
    v3 = "";
  printf(
    "<input type=checkbox name=everyday value=1 onclick=\"ClickEveryDay_2(document.sysconf_fm);\" %s>%s",
    v3,
    "매일");
  print_nbsp(10);
  if ( v17 )
    v4 = "checked";
  else
    v4 = "";
  printf(" <input type=checkbox name=sun value=1 %s>%s", v4, "일");
  if ( v18 )
    v5 = "checked";
  else
    v5 = "";
  printf(" <input type=checkbox name=mon value=1 %s>%s", v5, "월");
  if ( v19 )
    v6 = "checked";
  else
    v6 = "";
  printf(" <input type=checkbox name=tue value=1 %s>%s", v6, "화");
  if ( v20 )
    v7 = "checked";
  else
    v7 = "";
  printf(" <input type=checkbox name=wed value=1 %s>%s", v7, "수");
  if ( v21 )
    v8 = "checked";
  else
    v8 = "";
  printf(" <input type=checkbox name=thu value=1 %s>%s", v8, "목");
  if ( v22 )
    v9 = "checked";
  else
    v9 = "";
  printf(" <input type=checkbox name=fri value=1 %s>%s", v9, "금");
  if ( v23 )
    v10 = "checked";
  else
    v10 = "";
  v11 = printf(" <input type=checkbox name=sat value=1 %s>%s", v10, "토");
  br(v11);
  print_nbsp(1);
  sub_1F128((int)"autorebootHour", v24, 0);
  printf("시");
  print_nbsp(3);
  sub_1F6D0((int)"autorebootMin", v25, 0);
  printf("분");
  v12 = printf("에 공유기를 자동으로 재시작합니다.");
  if ( !get_timed_status(v12) && v26 )
  {
    br(0);
    v13 = printf("<span class=gray_text>주의) 공유기가 시스템시간을 인터넷으로 부터 얻어오지 못했습니다.</span>");
    br(v13);
    print_nbsp(10);
    printf("<span class=gray_text><a href=\"JavaScript:MovePagetoMain('sysconf','realtime');\">[시스템 시간 설정]</a>페이지에서 설정이 올바른지 확인하십시오.</span>");
  }
  printf("</td>");
  printf("</tr></table>");
  return printf("<script> ClickAutoReboot_2(document.sysconf_fm);</script>");
}
// 1073C: using guessed type int __fastcall read_sched_array(_DWORD, _DWORD, _DWORD);
// 10E2C: using guessed type int __fastcall get_autoreboot_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (0001FA00) --------------------------------------------------------
int sub_1FA00()
{
  int v0; // r4@1
  char *v1; // r1@2
  char *v2; // r1@5
  int v3; // r0@7
  char *v4; // r1@8
  char *v5; // r1@11
  char *v6; // r1@14
  int v8; // [sp+0h] [bp-30h]@1
  char v9; // [sp+10h] [bp-20h]@7
  int v10; // [sp+18h] [bp-18h]@7
  int v11; // [sp+1Ch] [bp-14h]@7

  v0 = get_temperature("cpu");
  get_fan_config(&v8);
  printf("<table width=100%% CELLPADDING=0 CELLSPACING=0 border=0>");
  printf("<tr><td style=\"padding-left:5px;padding-top:2px;width:160px;\">");
  printf("%s", "현재 시스템 온도");
  printf("</td><td>");
  printf("CPU - %d &#8451", v0);
  printf("</td></tr>");
  printf("<tr><td style=\"padding-left:5px;width:160px;\">");
  printf("%s", "팬 속도 조절");
  printf("</td><td>");
  if ( !strcmp((const char *)&v8, "auto") )
    v1 = "checked";
  else
    v1 = "";
  printf("<input type=radio name=fan value=auto %s onclick=\"ClickFanMethod_2();\"> %s", v1, "자동");
  print_nbsp(10);
  if ( !strcmp((const char *)&v8, "auto") )
    v2 = "";
  else
    v2 = "checked";
  printf("<input type=radio name=fan value=manual %s onclick=\"ClickFanMethod_2();\"> %s", v2, "수동");
  printf("</td></tr></table>");
  printf("<div id=\"fan_auto_div\" style=\"padding-left:160px;padding-top:5px;\">");
  printf((const char *)&unk_5BD8A, v11, "이하 끄기");
  v3 = printf(
         "<input type=text style=\"width:30px;\" size=3 maxlength=3 name=maxtemper value=%d ONKEYUP=\"UpdateMinDesc_2();\">&#8451 %s",
         v10,
         "이상 고속");
  br(v3);
  printf("<span id=fan_min_start></span>&#8451 ~ <span id=fan_min_end></span>&#8451 %s", "저속");
  printf("</div>");
  printf("<div id=\"fan_manual_div\" style=\"padding-left:165px;padding-top:5px;\">");
  printf("%s", "팬 속도");
  print_nbsp(5);
  puts("<select name=manualop>");
  if ( !strcmp(&v9, "off") )
    v4 = "selected";
  else
    v4 = "";
  printf("<option value=off %s> 꺼짐", v4);
  if ( !strcmp(&v9, "min") )
    v5 = "selected";
  else
    v5 = "";
  printf((const char *)&unk_5BF6E, v5);
  if ( !strcmp(&v9, "max") )
    v6 = "selected";
  else
    v6 = "";
  printf("<option value=max %s> 고속", v6);
  printf("</select>");
  printf("</div>");
  printf("<script>");
  printf("UpdateMinDesc_2();");
  printf("ClickFanMethod_2();");
  return printf("</script>");
}
// 104D8: using guessed type int __fastcall get_fan_config(_DWORD);
// 10748: using guessed type int __fastcall get_temperature(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (0001FC78) --------------------------------------------------------
int sub_1FC78()
{
  int v0; // r0@1
  char *v1; // r1@2
  int v2; // r0@4
  int v3; // r0@4
  char *v4; // r1@5

  v0 = printf((const char *)&unk_5BFCF);
  if ( get_usb_mode(v0) == 2 )
    v1 = "checked";
  else
    v1 = "";
  v2 = printf("<input type=radio name=usb_mode value=2 %s onclick=\"ShowUSBMessage_2();\"> %s", v1, "USB2.0모드");
  v3 = br(v2);
  if ( get_usb_mode(v3) == 3 )
    v4 = "checked";
  else
    v4 = "";
  printf("<input type=radio name=usb_mode value=3 %s onclick=\"ShowUSBMessage_2();\"> %s", v4, "USB3.0모드");
  printf("</td><td style=\"padding:25 0 0 10;\">");
  printf(
    "<span ID=usb30_desc style=\"display:none;\" class=\"gray_text\">%s</span>",
    "(USB3.0사용 시, 2.4GHz무선 간섭이 발생할 수 있음)");
  printf("</td></tr></table>");
  return printf("<script> ShowUSBMessage_2(); </script>");
}
// 112C4: using guessed type int __fastcall get_usb_mode(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (0001FD20) --------------------------------------------------------
int sub_1FD20()
{
  printf("<table CELLPADDING=0 CELLSPACING=0><tr height=23px><td style=\"padding-left:5px;\">");
  printf("%s", "공유기가 다시 시작된 후 \"기타 설정\" 페이지로 접속됩니다.");
  printf("</td>");
  return printf("</tr></table>");
}

//----- (0001FD60) --------------------------------------------------------
int __fastcall sub_1FD60(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_apcplan_flag(a1);
  printf("<table width=100%% CELLPADDING=0 CELLSPACING=0 border=0>");
  printf("<tr height=23px>");
  printf("<td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=apcplan value=1 %s> %s", v2, "실행");
  print_nbsp(10);
  if ( v1 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=apcplan value=0 %s> %s", v3, "중단");
  printf("</td><tr height=15px><td>&nbsp;</td></tr><tr height=23px><td style=\"padding-left:5px;\">");
  printf("<span class=gray_text><li>");
  printf("설치도우미를 통한 내부 네트워크 설정 변경을 허용합니다.");
  puts("</span>");
  printf("</td>");
  return printf("</tr></table>");
}
// 10E14: using guessed type int __fastcall get_apcplan_flag(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0001FE34) --------------------------------------------------------
int __fastcall sub_1FE34(int a1)
{
  int v1; // r6@1
  char *v2; // r1@2
  char *v3; // r1@5

  v1 = get_upnp(a1);
  printf("<table width=100%% CELLPADDING=0 CELLSPACING=0 border=0>");
  printf("<tr height=23px>");
  printf("<td style=\"padding-left:5px;\" colspan=4>");
  if ( v1 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=upnp value=1 %s> %s", v2, "실행");
  print_nbsp(10);
  if ( v1 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=upnp value=0 %s> %s", v3, "중단");
  printf("</td></tr><tr height=10px><td colspan=4></td></tr> ");
  printf("<tr><td colspan=4 style=\"padding-left:5px;\"");
  printf("<div id=\"upnp_div\">");
  printf("<table width=100%% border=0 cellspacing=0 cellpadding=0>\n");
  puts("<tr><td class=\"st_text_td\">");
  printf(
    "<SPAN class=\"movetomain\"><a href=\"javascript:MovePagetoMainURL('natrouterconf','portforward','mode=upnp');\"><u>%"
    "s</u></a> %s</SPAN>",
    "[NAT/라우터 관리] - [포트포워드 설정]",
    "에서 UPNP 포트포워딩 리스트를 확인할 수 있습니다.");
  printf("</td>");
  printf("</tr>");
  puts("</table>");
  printf("</div>");
  printf("</td>");
  printf("</tr>");
  printf("<tr><td>");
  printf("<div id=\"upnp_desc\" style=\"border:none; width:100%%; height:100px;\">");
  printf("</div>");
  return printf("</td></tr></table>");
}
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 114D4: using guessed type int __fastcall get_upnp(_DWORD);

//----- (0001FF84) --------------------------------------------------------
int __fastcall sub_1FF84(const char *a1)
{
  const char *v1; // r4@1
  int result; // r0@25

  v1 = a1;
  if ( !strcmp(a1, "hostname") )
    sub_1F1A8();
  if ( !strcmp(v1, "autosaving") )
    sub_1F204((int)v1);
  if ( !strcmp(v1, "fakedns") )
    sub_1F29C((int)v1);
  if ( !strcmp(v1, "fan") )
    sub_1FA00();
  if ( !strcmp(v1, "nologin") )
    sub_1F354((int)v1);
  if ( !strcmp(v1, (const char *)&unk_5C5EA) )
    sub_1F3F0((int)v1);
  if ( !strcmp(v1, "upnp") )
    sub_1FE34((int)v1);
  if ( !strcmp(v1, "led") )
    sub_1F488();
  if ( !strcmp(v1, "autoreboot") )
    sub_1F750();
  if ( !strcmp(v1, "usb_mode") )
    sub_1FC78();
  if ( !strcmp(v1, "restart") )
    sub_1FD20();
  if ( !strcmp(v1, "apcplan") )
    sub_1FD60((int)v1);
  result = strcmp(v1, "macclone_giga");
  if ( !result )
    result = sub_1F638((int)v1);
  return result;
}

//----- (00020164) --------------------------------------------------------
int __fastcall sub_20164(const char *a1, int a2)
{
  const char *v2; // r4@1
  int v3; // r5@1

  v2 = a1;
  v3 = a2;
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%% ID=%s_table STYLE=\"display:none;\">", a1);
  printf(
    "<tr><td height=20 valign=center style=\"padding:3px;width:180px;\">&nbsp; <b>%s</b></td><td align=right>%s</td></tr>",
    v3);
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td colspan=2></td></tr>");
  printf("<tr><td  colspan=2 valign=top style=\"padding:5px\" >");
  sub_1FF84(v2);
  return puts((const char *)&unk_5C75F);
}

//----- (000201D8) --------------------------------------------------------
int __fastcall sub_201D8(int a1)
{
  int v1; // r5@1
  int result; // r0@1
  unsigned int v3; // r0@3
  int v4; // r0@8
  int v5; // r4@11
  const char *v6; // r1@12
  int v7; // r0@14
  int v8; // r0@17
  int v9; // r0@20
  int v10; // r0@23
  int v11; // r0@26
  int v12; // r0@28
  int v13; // r0@28
  unsigned int v14; // r0@28
  int v15; // r0@28
  int v16; // r6@30
  int v17; // r0@36
  char *v18; // r0@37
  const char *v19; // r1@37
  bool v20; // nf@38
  unsigned __int8 v21; // vf@38
  int v22; // r0@42
  int v23; // r0@52
  int v24; // r6@54
  int v25; // r0@54
  bool v26; // zf@54
  signed int v27; // r6@57
  int v28; // r7@62
  int v29; // r0@62
  signed int v30; // r3@62
  int v31; // r6@69
  int v32; // r0@69
  signed int v33; // r3@69
  char v34; // r0@73
  int v35; // r6@75
  int v36; // r0@75
  signed int v37; // r3@75
  char v38; // r0@79
  int v39; // r6@81
  int v40; // r0@81
  signed int v41; // r3@81
  char v42; // r0@85
  int v43; // r6@87
  int v44; // r0@87
  signed int v45; // r3@87
  char v46; // r0@91
  int v47; // r6@93
  int v48; // r0@93
  signed int v49; // r3@93
  char v50; // r0@97
  int v51; // r6@99
  int v52; // r0@99
  signed int v53; // r3@99
  char v54; // r0@103
  int v55; // r6@113
  int v56; // r0@114
  unsigned int v57; // r0@115
  int v58; // r0@120
  int v59; // r0@120
  int v60; // r0@122
  char s; // [sp+4h] [bp-1BCh]@3
  int v62; // [sp+24h] [bp-19Ch]@62
  int v63; // [sp+28h] [bp-198h]@61
  char v64; // [sp+2Ch] [bp-194h]@67
  char v65; // [sp+2Dh] [bp-193h]@75
  char v66; // [sp+2Eh] [bp-192h]@81
  char v67; // [sp+2Fh] [bp-191h]@87
  char v68; // [sp+30h] [bp-190h]@93
  char v69; // [sp+31h] [bp-18Fh]@99
  char v70; // [sp+32h] [bp-18Eh]@105
  int v71; // [sp+34h] [bp-18Ch]@106
  int v72; // [sp+38h] [bp-188h]@107
  int v73; // [sp+3Ch] [bp-184h]@109
  int v74; // [sp+40h] [bp-180h]@107
  int v75; // [sp+44h] [bp-17Ch]@109
  int v76; // [sp+104h] [bp-BCh]@32
  int v77; // [sp+108h] [bp-B8h]@47
  int v78; // [sp+10Ch] [bp-B4h]@49
  unsigned __int8 v79; // [sp+144h] [bp-7Ch]@1
  char v80; // [sp+184h] [bp-3Ch]@30
  int v81; // [sp+194h] [bp-2Ch]@33
  int v82; // [sp+19Ch] [bp-24h]@36
  int v83; // [sp+1A0h] [bp-20h]@35
  int v84; // [sp+1A4h] [bp-1Ch]@54

  v1 = a1;
  result = get_value_post(a1, "service", &v79, 64);
  if ( !result )
    return result;
  if ( !strcmp((const char *)&v79, "hostname") )
  {
    v3 = get_value_post(v1, "hostnameh", &s, 255);
    if ( v3 )
    {
      v3 = check_unpermitted_chars(&s);
      if ( !v3 )
        v3 = set_hostname(&s);
    }
    goto LABEL_123;
  }
  if ( !strcmp((const char *)&v79, "autosaving") )
  {
    result = get_value_post(v1, "autosavingh", &v79, 64);
    if ( !result )
      return result;
    v4 = atoi((const char *)&v79);
    v3 = set_autosaving(v4);
    goto LABEL_123;
  }
  if ( !strcmp((const char *)&v79, "fakedns") )
  {
    result = get_value_post(v1, "fakednsh", &v79, 64);
    if ( !result )
      return result;
    v5 = atoi((const char *)&v79);
    if ( v5 )
      v6 = "관리자가 '설정 화면 자동연결' 기능 설정함";
    else
      v6 = "관리자가 '설정 화면 자동연결' 기능 해제함";
    syslog_msg(1, v6);
    v7 = set_fakedns(v5);
    goto LABEL_50;
  }
  if ( !strcmp((const char *)&v79, "nologin") )
  {
    result = get_value_post(v1, "nologinh", &v79, 64);
    if ( !result )
      return result;
    v8 = atoi((const char *)&v79);
    v3 = set_nologin(v8);
    goto LABEL_123;
  }
  if ( !strcmp((const char *)&v79, (const char *)&unk_5C5EA) )
  {
    result = get_value_post(v1, "wbmpopuph", &v79, 64);
    if ( !result )
      return result;
    v9 = atoi((const char *)&v79);
    v3 = set_wbm_popup_flag(v9);
    goto LABEL_123;
  }
  if ( !strcmp((const char *)&v79, "apcplan") )
  {
    result = get_value_post(v1, "apcplanh", &v79, 64);
    if ( !result )
      return result;
    v10 = atoi((const char *)&v79);
    v3 = set_apcplan_flag(v10);
    goto LABEL_123;
  }
  if ( !strcmp((const char *)&v79, "usb_mode") )
  {
    result = get_value_post(v1, "usbmodeh", &v79, 64);
    if ( !result )
      return result;
    v11 = atoi((const char *)&v79);
    if ( v11 != 3 )
      v11 = 2;
    set_usb_mode(v11);
    v12 = syslog_msg(1, "관리자가 시스템을 재시작함");
    v13 = syslog_save(v12);
    saveconf(v13);
    v14 = sleep(3u);
    send_system_reboot_signal(v14);
    v15 = 0;
LABEL_117:
    exit(v15);
  }
  if ( strcmp((const char *)&v79, "fan") )
  {
    if ( !strcmp((const char *)&v79, "led") )
    {
      get_led_silent_control(&v76);
      v76 = 0;
      result = get_value_post(v1, "ledh", &v79, 64);
      if ( !result )
        return result;
      v76 = atoi((const char *)&v79);
      if ( get_value_post(v1, "ledstart", &v79, 64) )
      {
        result = v79;
        if ( !v79 )
          return result;
        v77 = atoi((const char *)&v79);
      }
      get_value_post(v1, "ledend", &v79, 64);
      result = v79;
      if ( !v79 )
        return result;
      v78 = atoi((const char *)&v79);
      v7 = set_led_silent_control(&v76);
LABEL_50:
      v3 = signal_update(v7);
      goto LABEL_123;
    }
    if ( !strcmp((const char *)&v79, "autoreboot") )
    {
      *(_WORD *)&v80 = 0;
      v23 = get_value_post(v1, "autorebooth", &v79, 64);
      if ( v23 )
        v23 = atoi((const char *)&v79);
      v84 = v23;
      set_autoreboot_config(&v84);
      memset(&s, 0, 0x44u);
      v24 = get_value_post(v1, "everyday", &v80, 2);
      v25 = atoi(&v80);
      v26 = v24 == 0;
      if ( v24 )
        v26 = v25 == 0;
      v27 = !v26;
      if ( v26 )
        v25 = v27;
      v63 = v25;
      if ( !v25 )
      {
        LOWORD(v76) = 0;
        v62 = 1;
        v28 = get_value_post(v1, "sun", &v76, 2);
        v29 = strcmp((const char *)&v76, "1");
        v30 = v28;
        if ( v28 )
          v30 = 1;
        if ( v29 )
          v30 = 0;
        if ( v30 )
          v64 = atoi((const char *)&v76);
        else
          v64 = 0;
        v31 = get_value_post(v1, "mon", &v76, 2);
        v32 = strcmp((const char *)&v76, "1");
        v33 = v31;
        if ( v31 )
          v33 = 1;
        if ( v32 )
          v33 = 0;
        v34 = v33;
        if ( v33 )
          v34 = atoi((const char *)&v76);
        v65 = v34;
        v35 = get_value_post(v1, "tue", &v76, 2);
        v36 = strcmp((const char *)&v76, "1");
        v37 = v35;
        if ( v35 )
          v37 = 1;
        if ( v36 )
          v37 = 0;
        v38 = v37;
        if ( v37 )
          v38 = atoi((const char *)&v76);
        v66 = v38;
        v39 = get_value_post(v1, "wed", &v76, 2);
        v40 = strcmp((const char *)&v76, "1");
        v41 = v39;
        if ( v39 )
          v41 = 1;
        if ( v40 )
          v41 = 0;
        v42 = v41;
        if ( v41 )
          v42 = atoi((const char *)&v76);
        v67 = v42;
        v43 = get_value_post(v1, "thu", &v76, 2);
        v44 = strcmp((const char *)&v76, "1");
        v45 = v43;
        if ( v43 )
          v45 = 1;
        if ( v44 )
          v45 = 0;
        v46 = v45;
        if ( v45 )
          v46 = atoi((const char *)&v76);
        v68 = v46;
        v47 = get_value_post(v1, "fri", &v76, 2);
        v48 = strcmp((const char *)&v76, "1");
        v49 = v47;
        if ( v47 )
          v49 = 1;
        if ( v48 )
          v49 = 0;
        v50 = v49;
        if ( v49 )
          v50 = atoi((const char *)&v76);
        v69 = v50;
        v51 = get_value_post(v1, "sat", &v76, 2);
        v52 = strcmp((const char *)&v76, "1");
        v53 = v51;
        if ( v51 )
          v53 = 1;
        if ( v52 )
          v53 = 0;
        v54 = v53;
        if ( v53 )
          v54 = atoi((const char *)&v76);
        v70 = v54;
      }
      v71 = 0;
      if ( get_value_post(v1, "autorebootHour", &v79, 64) )
      {
        v72 = atoi((const char *)&v79);
        v74 = v72;
      }
      if ( get_value_post(v1, "autorebootMin", &v79, 64) )
      {
        v73 = atoi((const char *)&v79);
        v75 = v73;
      }
      remove_all_gen_schedule("autoreboot");
      if ( v84 )
        add_gen_schedule("autoreboot", &s);
      v7 = iconfig_remove_config_tag("last_autoboot_stamp");
      goto LABEL_50;
    }
    v55 = strcmp((const char *)&v79, "restart");
    if ( v55 )
    {
      v55 = strcmp((const char *)&v79, "upnp");
      if ( !v55 )
      {
        result = get_value_post(v1, "upnph", &v76, 2);
        if ( !result )
          return result;
        v58 = atoi((const char *)&v76);
        set_upnp(v58);
        v59 = syslog_msg(1, "관리자가 시스템을 재시작함");
        saveconf(v59);
        v57 = sleep(3u);
        goto LABEL_116;
      }
      v55 = strcmp((const char *)&v79, "macclone_giga");
      if ( v55 )
        return 0;
      get_value_post(v1, "macclone_giga", &v76, 64);
      v60 = atoi((const char *)&v76);
      v56 = set_macclone_in_giga(v60);
    }
    else
    {
      v56 = syslog_msg(1, "관리자가 시스템을 재시작함");
    }
    v57 = saveconf(v56);
LABEL_116:
    send_system_reboot_signal(v57);
    v15 = v55;
    goto LABEL_117;
  }
  v16 = get_temperature("cpu");
  get_fan_config(&v80);
  if ( !get_value_post(v1, "fanh", &v79, 64) )
    return 0;
  sf_strncpy(&v80, &v79, 16);
  if ( !strcmp(&v80, "manual") )
  {
    result = get_value_post(v1, "manualop", &v76, 64);
    if ( !result )
      return result;
    sf_strncpy(&v81, &v76, 8);
    goto LABEL_42;
  }
  result = get_value_post(v1, "mintemper", &v76, 64);
  if ( result )
  {
    v83 = atoi((const char *)&v76);
    result = get_value_post(v1, "maxtemper", &v76, 64);
    if ( result )
    {
      v17 = atoi((const char *)&v76);
      v82 = v17;
      if ( v16 > v83 )
      {
        v21 = __OFSUB__(v16, v17);
        v20 = v16 - v17 < 0;
        v18 = (char *)&v81;
        if ( v20 ^ v21 )
          v19 = "min";
        else
          v19 = "max";
      }
      else
      {
        v18 = (char *)&v81;
        v19 = "off";
      }
      strcpy(v18, v19);
LABEL_42:
      v22 = set_fan_config(&v80);
      signal_update(v22);
      v3 = sleep(1u);
LABEL_123:
      signal_save(v3);
      sleep(2u);
      return 1;
    }
  }
  return result;
}
// 10088: using guessed type int __fastcall syslog_save(_DWORD);
// 1019C: using guessed type int __fastcall set_nologin(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102D4: using guessed type int __fastcall set_led_silent_control(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 104D8: using guessed type int __fastcall get_fan_config(_DWORD);
// 10574: using guessed type int __fastcall set_upnp(_DWORD);
// 10688: using guessed type int __fastcall send_system_reboot_signal(_DWORD);
// 106F4: using guessed type int __fastcall set_autosaving(_DWORD);
// 10748: using guessed type int __fastcall get_temperature(_DWORD);
// 107C0: using guessed type int __fastcall set_autoreboot_config(_DWORD);
// 10A18: using guessed type int __fastcall set_wbm_popup_flag(_DWORD);
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10C28: using guessed type int __fastcall get_led_silent_control(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10DE4: using guessed type int __fastcall set_fan_config(_DWORD);
// 10F28: using guessed type int __fastcall set_hostname(_DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11144: using guessed type int __fastcall set_apcplan_flag(_DWORD);
// 111BC: using guessed type int __fastcall iconfig_remove_config_tag(_DWORD);
// 112B8: using guessed type int __fastcall set_fakedns(_DWORD);
// 11774: using guessed type int __fastcall set_usb_mode(_DWORD);
// 11798: using guessed type int __fastcall add_gen_schedule(_DWORD, _DWORD);
// 11804: using guessed type int __fastcall set_macclone_in_giga(_DWORD);
// 119A8: using guessed type int __fastcall remove_all_gen_schedule(_DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00020B30) --------------------------------------------------------
int sub_20B30()
{
  FILE *v0; // r7@1
  int v1; // r4@2
  char *v2; // r0@4
  const char *v3; // r6@5
  char *v4; // r0@5
  const char *v5; // r10@6
  unsigned __int16 v6; // r11@6
  char *v7; // r0@6
  const char *v8; // r9@7
  char *v9; // r0@7
  const char *v10; // r6@8
  int v11; // r9@8
  int v12; // r5@11
  int v14; // [sp+0h] [bp-A8h]@4

  printf("<html><head></head><body width=100%% bottommargin=0 rightmargin=0 leftmargin=0 topmargin=0 marginheight=0 >");
  printf("<form method=post action=\"timepro.cgi\" name=\"upnp_list_fm\">");
  printf("<input type=hidden name=\"tmenu\" value=\"popup\">");
  printf("<input type=hidden name=\"smenu\" value=\"upnp_list\">");
  printf("<table cellspacing=0px cellpadding=0px border=0 width=100%% align=left>");
  v0 = fopen("/var/run/upnp_pmlist", "r");
  if ( v0 )
  {
    v1 = 0;
    while ( fgets((char *)&v14, 128, v0) )
    {
      v2 = strchr((const char *)&v14, 59);
      ++v1;
      if ( v2 )
      {
        *v2 = 0;
        v3 = v2 + 1;
        v4 = strchr(v2 + 1, 59);
        if ( v4 )
        {
          *v4 = 0;
          v5 = v4 + 1;
          v6 = atoi(v3);
          v7 = strchr(v5, 59);
          if ( v7 )
          {
            *v7 = 0;
            v8 = v7 + 1;
            v9 = strchr(v7 + 1, 59);
            if ( v9 )
            {
              *v9 = 0;
              v10 = v9 + 1;
              v11 = (unsigned __int16)atoi(v8);
              *strchr(v10, 10) = 0;
              printf("<tr style=\"background:#%s;height:20px;\">");
              printf("<td width=72px style=\"padding-left:5px;\">%s</td>\n", &v14);
              printf("<td width=76px>%d</td>\n", v6);
              printf("<td width=146px>%s:%d</td>\n", v5, v11);
              printf("<td width=318px>%s</td>\n", v10);
              printf("</tr>");
            }
          }
        }
      }
    }
    fclose(v0);
  }
  else
  {
    v1 = 0;
  }
  v12 = 0;
  while ( v12 < 5 - v1 )
  {
    ++v12;
    sub_1F0F0();
  }
  printf("</table>");
  printf("</form>");
  return printf((const char *)&unk_5CAB4);
}

//----- (00020D14) --------------------------------------------------------
int __fastcall sub_20D14(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r0@2
  bool v5; // zf@2
  char *v6; // r1@2
  char *v7; // r0@2
  int result; // r0@5
  int v9; // r0@11
  int v10; // r5@14
  char *v11; // r3@16
  int v12; // r0@17
  char *v13; // r3@21
  int v14; // r0@22
  int v15; // r0@25
  int v16; // r0@28
  int v17; // r0@31
  int v18; // r0@34
  int v19; // r0@37
  int v20; // r0@40
  int v21; // r0@46
  int v22; // r0@49
  char v23; // [sp+10h] [bp-4C0h]@9
  char s; // [sp+210h] [bp-2C0h]@9
  char v25; // [sp+310h] [bp-1C0h]@8
  char v26; // [sp+410h] [bp-C0h]@5
  char dest; // [sp+450h] [bp-80h]@2
  char v28; // [sp+490h] [bp-40h]@14
  int v29; // [sp+4A0h] [bp-30h]@15
  char v30; // [sp+4B0h] [bp-20h]@34
  int v31; // [sp+4BCh] [bp-14h]@43

  v2 = a2;
  v3 = a1;
  print_file("/home/httpd/js/sysconf2.js");
  sub_201D8(v2);
  if ( !v3 )
  {
    result = get_value_post(v2, "service", &v26, 64);
    if ( !result )
      return result;
    v7 = &dest;
    v6 = &v26;
    goto LABEL_7;
  }
  v4 = get_pvalue(v3, "service");
  v6 = (char *)v4;
  v5 = v4 == 0;
  v7 = &dest;
  if ( !v5 )
  {
LABEL_7:
    sf_strncpy(v7, v6, 64);
    goto LABEL_8;
  }
  strcpy(&dest, "hostname");
LABEL_8:
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  printf("<form method=post action=\"timepro.cgi\" name=\"main_form\">");
  puts("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=\"smenu\" value=\"sysconf_misc\">");
  puts("<input type=hidden name=\"click_id\" value=>");
  puts("<input type=hidden name=\"click_bg\" value=>");
  puts("<input type=hidden name=service value=>");
  puts("<input type=hidden name=run value=>");
  puts("<input type=hidden name=hostnameh value=>");
  puts("<input type=hidden name=autosavingh value=>");
  puts("<input type=hidden name=fakednsh value=>");
  puts("<input type=hidden name=nologinh value=>");
  puts("<input type=hidden name=wbmpopuph value=>");
  puts("<input type=hidden name=remotesupporth value=>");
  puts("<input type=hidden name=apcplanh value=>");
  puts("<input type=hidden name=usbmodeh value=>");
  puts("<input type=hidden name=fanh value=>");
  puts("<input type=hidden name=mintemper value=>");
  puts("<input type=hidden name=maxtemper value=>");
  puts("<input type=hidden name=manualop value=>");
  puts("<input type=hidden name=ledh value=>");
  puts("<input type=hidden name=ledstart value=>");
  puts("<input type=hidden name=ledend value=>");
  puts("<input type=hidden name=autorebooth value=>");
  puts("<input type=hidden name=everyday value=>");
  puts("<input type=hidden name=autorebootHour value=>");
  puts("<input type=hidden name=autorebootMin value=>");
  puts("<input type=hidden name=sun value=>");
  puts("<input type=hidden name=mon value=>");
  puts("<input type=hidden name=tue value=>");
  puts("<input type=hidden name=wed value=>");
  puts("<input type=hidden name=thu value=>");
  puts("<input type=hidden name=fri value=>");
  puts("<input type=hidden name=sat value=>");
  puts("<input type=hidden name=macclone_giga value=>");
  puts("<input type=hidden name=restarth value=>");
  puts("<input type=hidden name=upnph value=>");
  printf("<table style=\"border-collapse:collapse; border-style:none none none none; width:100%%;\" cellspacing=0px cellpadding=0px>\n");
  printf("<COL WIDTH=9><COL WIDTH=220><COL width=350><COL>");
  memset(&v25, 0, 0xFFu);
  get_hostname(&v25);
  if ( v25 )
  {
    snprintf(
      &s,
      0x100u,
      "<span id=hostname_status title=\"%s\" style=\" display:block; overflow:hidden; white-space:nowrap;  text-overflow:"
      "ellipsis; width:350px; \">%s </span>",
      &v25,
      &v25);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap;  text-overflow:ellipsis;\">%s</span>",
      "hostname",
      "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=hostname_status>%s</span>", "설정되지 않음");
    strcpy(&v23, "");
  }
  sub_1F090((int)"hostname", (int)"공유기 이름", (int)&s);
  snprintf(&s, 0x100u, "<span id=restart_status></span>");
  snprintf(
    &v23,
    0x200u,
    "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
    "restart",
    "");
  v9 = sub_1F090((int)"restart", (int)"공유기 다시 시작", (int)&s);
  if ( get_autosaving(v9) <= 0 )
  {
    snprintf(&s, 0x100u, "<span id=autosaving_status>%s</span>", "중단", 1);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=autosaving_status>%s</span>", "실행", 1);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap;  text-overflow:ellipsis;\">%s</span>",
      "auto_saving",
      "");
  }
  sub_1F090((int)"autosaving", (int)"자동 설정 저장", (int)&s);
  get_fan_config(&v28);
  v10 = get_temperature("cpu");
  if ( !strcmp(&v28, "auto") )
  {
    if ( !strcmp((const char *)&v29, "off") )
    {
      v11 = "꺼짐";
    }
    else
    {
      v12 = strcmp((const char *)&v29, "min");
      v11 = "저속";
      if ( v12 )
        v11 = "고속";
    }
    snprintf(&s, 0x100u, "<span id=fan_status >%s:%d &#8451 / %s:%s</span>", "시스템 온도", v10, "팬 속도", v11);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "fan",
      "");
  }
  else
  {
    if ( !strcmp((const char *)&v29, "off") )
    {
      v13 = "꺼짐";
    }
    else
    {
      v14 = strcmp((const char *)&v29, "min");
      v13 = "저속";
      if ( v14 )
        v13 = "고속";
    }
    snprintf(&s, 0x100u, "<span id=fan_status>%s:%d &#8451 /%s:%s</span>", "시스템 온도", v10, "팬 속도", v13);
    strcpy(&v23, "");
  }
  v15 = sub_1F090((int)"fan", (int)"팬 설정", (int)&s);
  if ( get_fakedns(v15) <= 0 )
  {
    snprintf(&s, 0x100u, "<span id=fakedns_status>%s</span>", "중단", 3);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=fakedns_status>%s</span>", "실행", 3);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap;  text-overflow:ellipsis;\">%s</span>",
      "fakedns",
      "");
  }
  v16 = sub_1F090((int)"fakedns", (int)"설정화면 자동연결", (int)&s);
  if ( get_nologin(v16) )
  {
    snprintf(&s, 0x100u, "<span id=nologin_status>%s</span>", "로그인 페이지 숨김", 4);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=nologin_status>%s</span>", "로그인 페이지 보임", 4);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "nologin",
      "");
  }
  v17 = sub_1F090((int)"nologin", (int)"로그인 페이지 설정", (int)&s);
  if ( get_wbm_popup_flag(v17) <= 0 )
  {
    snprintf(&s, 0x100u, "<span id=wbm_popup_status>%s</span>", "현재 창 사용", 5);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=wbm_popup_status>%s</span>", "팝업으로 새 창 띄움", 5);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap;  text-overflow:ellipsis;\">%s</span>",
      &unk_5C5EA,
      "");
  }
  sub_1F090((int)&unk_5C5EA, (int)"관리도구 접속방법", (int)&s);
  get_led_silent_control(&v30);
  v18 = get_ledswitch_status(0);
  if ( v18 )
  {
    get_led_silent_state(v18);
    snprintf(&s, 0x100u, "<span id=led_status>%s</span>");
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=led_status>%s</span>", "LED스위치에 의해  LED꺼짐", 6);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "led",
      "");
  }
  v19 = sub_1F090((int)"led", (int)"나이트 LED모드", (int)&s);
  if ( get_upnp(v19) <= 0 )
  {
    snprintf(&s, 0x100u, "<span id=upnp_status>%s</span>", "중단", 7);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=upnp_status>%s</span>", "실행", 7);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "upnp",
      "");
  }
  v20 = sub_1F090((int)"upnp", (int)"UPNP 설정", (int)&s);
  if ( get_apcplan_flag(v20) <= 0 )
  {
    snprintf(&s, 0x100u, "<span id=apcpd_status>%s</span>", "중단", 8);
    strcpy(&v23, "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=apcpd_status>%s</span>", "실행", 8);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap;  text-overflow:ellipsis;\">%s</span>",
      "apcpd",
      "");
  }
  sub_1F090((int)"apcplan", (int)"내부 네트워크 자동 변경", (int)&s);
  get_autoreboot_config(&v31);
  memset(&v25, 0, 0x44u);
  read_sched_array("autoreboot", &v25, 1);
  if ( v31 )
  {
    snprintf(&s, 0x100u, "<span id=autoreboot_status>%s</span>", "실행", 9);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "autoreboot",
      "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=autoreboot_status>%s</span>", "중단", 9);
    strcpy(&v23, "");
  }
  v21 = sub_1F090((int)"autoreboot", (int)"공유기 자동 재시작", (int)&s);
  if ( get_usb_mode(v21) == 2 )
  {
    snprintf(&s, 0x100u, "<span id=usb_mode_status>%s</span>", "USB2.0모드", 10);
    snprintf(
      &v23,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; text-overflow:ellipsis;\">%s</span>",
      "usb_mode",
      "");
  }
  else
  {
    snprintf(&s, 0x100u, "<span id=usb_mode_status>%s</span>", "USB3.0모드", 10);
    strcpy(&v23, "");
  }
  v22 = sub_1F090((int)"usb_mode", (int)"USB모드 설정", (int)&s);
  get_macclone_in_giga(v22);
  snprintf(&s, 0x100u, "<span id=macclone_giga_status>%s</span>");
  strcpy(&v23, "");
  sub_1F090((int)"macclone_giga", (int)"MAC주소(WAN포트) 자동설정", (int)&s);
  sub_1F0F0();
  sub_1F0F0();
  printf("</table>");
  printf("</BODY>");
  printf("<script>");
  printf("clickSysconf(document.getElementById('%s'));\n", &dest);
  if ( strcmp(&dest, "restart") && strcmp(&dest, "upnp") && strcmp(&dest, "usb_mode") && strcmp(&dest, "wan_for_lan") )
  {
    if ( strcmp(&dest, "mgmt_port") )
      puts("UnMaskIt(parent.document,'apply_mask_sysconf');");
  }
  return printf("</script>");
}
// 1001C: using guessed type int __fastcall get_fakedns(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102BC: using guessed type int __fastcall get_wbm_popup_flag(_DWORD);
// 104D8: using guessed type int __fastcall get_fan_config(_DWORD);
// 1073C: using guessed type int __fastcall read_sched_array(_DWORD, _DWORD, _DWORD);
// 10748: using guessed type int __fastcall get_temperature(_DWORD);
// 10A54: using guessed type int __fastcall get_nologin(_DWORD);
// 10BA4: using guessed type int __fastcall get_autosaving(_DWORD);
// 10C28: using guessed type int __fastcall get_led_silent_control(_DWORD);
// 10D84: using guessed type int __fastcall get_ledswitch_status(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10E14: using guessed type int __fastcall get_apcplan_flag(_DWORD);
// 10E2C: using guessed type int __fastcall get_autoreboot_config(_DWORD);
// 112C4: using guessed type int __fastcall get_usb_mode(_DWORD);
// 1133C: using guessed type int __fastcall get_macclone_in_giga(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 114D4: using guessed type int __fastcall get_upnp(_DWORD);
// 118AC: using guessed type int __cdecl get_led_silent_state(_DWORD);
// 11B10: using guessed type int __fastcall get_hostname(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00021898) --------------------------------------------------------
int __fastcall sub_21898(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  char *v3; // r5@1
  int v4; // r3@1
  int v6; // [sp+0h] [bp-330h]@1
  char dest; // [sp+200h] [bp-130h]@1
  char v8; // [sp+300h] [bp-30h]@4
  int v9; // [sp+318h] [bp-18h]@4
  int v10; // [sp+31Ch] [bp-14h]@4

  v1 = a1;
  strcpy(&dest, "");
  printf("<form method=\"get\" action=\"timepro.cgi\" name=\"sysconf_fm\"> ");
  puts("<table style=\"border-collapse:collapse; border-style:none solid solid solid; border-width:0px 1px 1px 1px; border-color:#eeeeee;width:642 \" cellspacing=0px cellpadding=0px>");
  printf("<input type=hidden name=tmenu value=sysconf>");
  printf("<input type=hidden name=\"smenu\" value=\"misc\">");
  v2 = printf("<input type=hidden name=\"act\"id=act  value=\"\">");
  str(v2);
  printf("<td width=100%% height=%d colspan=2>", 260);
  v3 = (char *)&v6 + snprintf((char *)&v6, 0x80u, (const char *)&unk_5D82D);
  v4 = get_pvalue(v1, "act");
  if ( v4 || (v4 = get_pvalue(v1, "service")) != 0 )
    snprintf(v3, 0x80u, "&service=%s", v4);
  printf(
    "<iframe name=\"sysconf_misc_iframe\" src=\"%s\" frameborder=no width=100%% height=300 align=left scrolling=yes></iframe>",
    &v6);
  printf("</td></tr>");
  puts("<tr height=205 style=\"background-Color:#eeeeee\"><td valign=top colspan=2>");
  sub_20164("hostname", (int)"공유기 이름");
  sub_20164("autosaving", (int)"자동 설정 저장");
  sub_20164("fakedns", (int)"설정화면 자동연결");
  sub_20164("nologin", (int)"로그인 페이지 설정");
  sub_20164((const char *)&unk_5C5EA, (int)"관리도구 접속방법");
  sub_20164("led", (int)"나이트 LED모드");
  sub_20164("remotesupport", (int)"원격 지원");
  sub_20164("autoreboot", (int)"공유기 자동 재시작");
  sub_20164("fan", (int)"팬 설정");
  sub_20164("usb_mode", (int)"USB모드 설정");
  sub_20164("restart", (int)"공유기 다시 시작");
  sub_20164("apcplan", (int)"내부 네트워크 자동 변경");
  sub_20164("macclone_giga", (int)"MAC주소(WAN포트) 자동설정");
  sub_20164("upnp", (int)"UPNP 설정");
  hwinfo_get_fan_control_default(&v8);
  printf("</td></tr>");
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td colspan=2></td></tr>");
  printf("<tr align=right valign=middle height=28 style=\"background-Color:#eeeeee\"><td align=right width=595>");
  printf(
    "<input type=button value=\"%s\" id=\"fanReset\" onclick=\"fan_reset(%d,%d);\" name=\"fanReset_name\" style=\"display:none;\" >",
    "기본값으로",
    v10,
    v9);
  printf("</td><td align=right>");
  printf("<input type=button id=apply_bt name=params_bt value=\"%s\" onclick=\"ApplySysconfig();\">", "적용");
  printf("</td></tr>");
  printf("</table>");
  return printf("</form>");
}
// 1031C: using guessed type int __fastcall hwinfo_get_fan_control_default(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00021BC4) --------------------------------------------------------
int __fastcall sub_21BC4(int a1)
{
  int v1; // r5@1
  int result; // r0@1
  int v3; // r0@3
  int v4; // r0@5
  int v5; // r0@7
  int v6; // r6@8
  int v7; // r4@10
  int v8; // r2@13
  int v9; // r0@14
  int v10; // [sp+0h] [bp-38h]@1

  v1 = a1;
  result = get_value_post(a1, "act", &v10, 32);
  if ( result )
  {
    if ( !strcmp((const char *)&v10, "remove") )
    {
      v3 = syslog_clear();
    }
    else
    {
      if ( !strcmp((const char *)&v10, "sendmail") )
      {
        v4 = syslog_set_sendmail();
        return signal_update(v4);
      }
      if ( get_value_post(v1, "log_flag", &v10, 32) )
      {
        v5 = strcmp((const char *)&v10, "on") == 0;
        syslog_set_status(v5);
      }
      v6 = get_value_post(v1, "log_email_chk", &v10, 32);
      if ( v6 )
        v6 = strcmp((const char *)&v10, "on") == 0;
      v7 = get_value_post(v1, "email_hour", &v10, 32);
      if ( v7 )
        v7 = atoi((const char *)&v10);
      if ( get_value_post(v1, "log_rmflag_chk", &v10, 32) )
        v8 = strcmp((const char *)&v10, "on") == 0;
      v9 = syslog_set_email_status(v6, v7);
      v3 = signal_update(v9);
    }
    result = signal_save(v3);
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10AA8: using guessed type int __fastcall syslog_set_status(_DWORD);
// 10B5C: using guessed type int syslog_clear(void);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 118B8: using guessed type int __fastcall syslog_set_email_status(_DWORD, _DWORD);
// 119D8: using guessed type int syslog_set_sendmail(void);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00021D28) --------------------------------------------------------
FILE *sub_21D28()
{
  FILE *result; // r0@1
  FILE *v1; // r5@1
  char *v2; // r0@4
  char *v3; // r10@4
  char *v4; // r0@5
  const char *v5; // r10@8
  int v6; // r8@8
  char *v7; // r0@8
  int v8; // r6@9
  const char *v9; // r0@10
  int v10; // r0@14
  int v11; // r0@15
  char v12; // r6@15
  int v13; // [sp+0h] [bp-160h]@3
  char v14; // [sp+100h] [bp-60h]@1

  syslog_get_filename(&v14);
  result = fopen(&v14, "r");
  v1 = result;
  if ( result )
  {
    while ( 1 )
    {
      v11 = feof(v1);
      v12 = v11;
      if ( v11 )
        break;
      if ( fgets((char *)&v13, 256, v1) )
      {
        v2 = strchr((const char *)&v13, 35);
        v3 = v2;
        if ( v2 )
        {
          *v2 = v12;
          v4 = strchr((const char *)&v13, 32);
          if ( v4 && v4 < v3 )
            *v4 = v12;
          v5 = v3 + 1;
          v6 = atoi((const char *)&v13);
          v7 = strchr(v5, 35);
          if ( v7 )
          {
            *v7 = 0;
            v8 = (int)(v7 + 1);
            printf("<tr onclick=\"ChangeToClickColor(this);\" onmouseover=\"ChangeToOverColor(this);\" onmouseout=\"ChangeToOutColor(this)\">");
            printf(
              "<td style=\"height:20px; padding: 0px 10px 0px 10px; border-collapse:collapse; border-style:solid none sol"
              "id none; border-width:1 1 1 1;  border-color:#EFEBDE; \" >%s</td>",
              v5);
            puts("<td style=\"height:20px; padding: 0px 10px 0px 10px; border-collapse:collapse; border-style:solid none solid none; border-width:1 1 1 1;  border-color:#EFEBDE; \" >");
            if ( v6 == 2 )
            {
              v9 = "<span class=\"log_warning_text\">";
            }
            else if ( v6 == 3 )
            {
              v9 = "<span class=\"log_error_text\">";
            }
            else
            {
              v9 = "<span class=\"log_info_text\">";
            }
            puts(v9);
            printf("%s", v8);
            v10 = printf("</span></td>");
            etr(v10);
          }
        }
      }
    }
    result = (FILE *)fclose(v1);
  }
  return result;
}
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11834: using guessed type int __fastcall syslog_get_filename(_DWORD);

//----- (00021E64) --------------------------------------------------------
int __fastcall sub_21E64(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  char *v4; // r1@2
  int v5; // r0@4
  char *v6; // r1@5
  int v7; // r0@7
  int v8; // r0@7
  int v9; // r0@7
  int v10; // r0@7
  int v11; // r7@7
  int v12; // r0@7
  int v13; // r0@7
  int v14; // r0@7
  int v15; // r0@9
  char *v16; // r1@10
  int v17; // r0@15
  int v18; // r0@15
  char *v19; // r1@16
  int v20; // r0@18
  int v21; // r0@18
  int v22; // r0@18
  int v23; // r0@20
  int v24; // r0@20
  int v25; // r0@20
  int v26; // r0@20
  int v27; // r0@20
  FILE *v28; // r0@20
  int v29; // r0@20
  int result; // r0@20
  char v31; // [sp+Ch] [bp-224h]@21
  char v32; // [sp+8Ch] [bp-1A4h]@20
  char v33; // [sp+10Ch] [bp-124h]@8
  char v34; // [sp+18Ch] [bp-A4h]@7
  int v35; // [sp+20Ch] [bp-24h]@7
  unsigned int v36; // [sp+210h] [bp-20h]@7
  int v37; // [sp+214h] [bp-1Ch]@7

  print_start_main_table(a1);
  puts("<form method=post action=timepro.cgi name=syslog_fm>");
  puts("<input type=hidden name=tmenu value=sysconf>");
  puts("<input type=hidden name=smenu value=syslog>");
  puts("<input type=hidden name=act value=>");
  v1 = print_sub_title("시스템 로그 설정", 1);
  v2 = print_start_content_table(v1);
  str(v2);
  print_item_desc("로그 기능 설정 ");
  v3 = puts("<td class=item_td>");
  if ( syslog_get_status(v3) )
    v4 = "checked";
  else
    v4 = "";
  printf("<input type=radio name=log_flag value=on %s> %s", v4, "실행");
  v5 = print_nbsp(5);
  if ( syslog_get_status(v5) )
    v6 = "";
  else
    v6 = "checked";
  printf("<input type=radio name=log_flag value=off %s> %s", v6, "중지");
  printf("</td>");
  printf("</td>");
  puts("<td align=right class=item_td>");
  v7 = printf("<input type=button name=rmlog_bt value=\"%s\" onclick=\"ApplySyslog();\">", "적용");
  v8 = etr(v7);
  str(v8);
  print_item_desc("로그 기능 상태 ");
  v9 = puts("<td class=item_td>");
  v10 = syslog_get_count(v9);
  v11 = v10;
  v12 = syslog_max_count(v10);
  printf("%s : %d(%d)</span>", "로그갯수(최대갯수)", v11, v12, 0);
  printf("</td>");
  puts("<td align=right class=item_td>");
  printf("<input type=button name=rmlog_bt value=\"%s\" onclick=\"RemoveLog();\">", "전체 삭제");
  v13 = printf("</td>");
  v14 = etr(v13);
  str(v14);
  print_item_desc("E-mail 보고 기능");
  puts("<td colspan=2 class=item_td>");
  syslog_get_email_status(&v37, &v36, &v35);
  if ( get_admin_email(&v34) && get_smtp_server(&v33) )
  {
    printf("<table class=menu_content_list_noline_table>");
    v15 = print_blank_line(2, 10);
    str(v15);
    printf("<td colspan=2 class=item_td>");
    if ( v37 )
      v16 = "checked";
    else
      v16 = "";
    printf("<input type=checkbox name=log_email_chk %s onclick=\"ToggleEmailLog();\"  >", v16);
    print_nbsp(3);
    printf("로그 내용을 매일 ");
    if ( v36 > 0x17 )
      printf("<input type=text name=email_hour size=2 maxlength=2 >");
    else
      printf("<input type=text name=email_hour size=2 maxlength=2 value=%d>");
    printf("시에 관리자에게 E-mail로 보고합니다.");
    v17 = printf("</td>");
    v18 = etr(v17);
    str(v18);
    printf("<td colspan=2 class=item_td>");
    if ( v35 )
      v19 = "checked";
    else
      v19 = "";
    printf("<input type=checkbox name=\"log_rmflag_chk\" %s>", v19, "");
    print_nbsp(3);
    v20 = printf("E-mail 전송 후 로그 삭제");
    v21 = etr(v20);
    str(v21);
    printf("<td align=left class=item_td>");
    printf(
      "<input type=button class=navi_bt name=\"sendmail_bt\" value=\"%s\" onclick=\"Send_Email();\">",
      "지금 E-mail 보내기");
    printf("</td>");
    printf("<td align=right class=item_td>");
    printf("<input type=button class=navi_bt name=\"email_bt\" value=\"%s\" onclick=\"Apply_Email();\">", "적용");
    v22 = printf("</td>");
    etr(v22);
    print_blank_line(2, 10);
    printf("</table>");
  }
  else
  {
    printf(
      "<span class=movetomain><a href=\"%s\"><U>[ 관리자 E-mail을 설정 ]</U></a></span>하여야 E-mail 보고기"
      "을 사용할수 있습니다.",
      "JavaScript:MovePagetoMain('sysconf','login');");
  }
  v23 = printf("</td>");
  v24 = etr(v23);
  print_end_content_table(v24);
  puts("</form>");
  v25 = print_sub_title("시스템 로그 보기", 0);
  v26 = print_start_content_table(v25);
  str(v26);
  print_item_desc("발생시간");
  v27 = print_item_desc("로그 내용");
  etr(v27);
  v28 = sub_21D28();
  v29 = print_end_content_table(v28);
  print_end_main_table(v29);
  result = get_admin_email(&v32);
  if ( result )
  {
    result = get_smtp_server(&v31);
    if ( result )
    {
      puts((const char *)&unk_5E254);
      puts("<!--");
      puts("ToggleEmailLog();");
      puts("-->");
      result = puts("</script>");
    }
  }
  return result;
}
// 100E8: using guessed type int __fastcall syslog_get_status(_DWORD);
// 10208: using guessed type int __fastcall syslog_get_email_status(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10BBC: using guessed type int __fastcall syslog_get_count(_DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11378: using guessed type int __cdecl syslog_max_count(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11810: using guessed type int __fastcall get_smtp_server(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11A38: using guessed type int __fastcall get_admin_email(_DWORD);

//----- (000222AC) --------------------------------------------------------
int __fastcall sub_222AC(int a1)
{
  int v1; // r4@1
  int v2; // r1@1
  int v3; // r2@1
  int v4; // r8@1
  _DWORD *v5; // r2@8
  unsigned int v6; // r3@8
  signed int v7; // r1@9
  int v8; // r0@16
  char *v9; // r1@17
  char *v10; // r1@20
  int v11; // r0@22
  int v12; // r0@22
  void *v13; // r0@22
  char *v14; // r1@23
  int v15; // r0@25
  int v16; // r0@25
  int v17; // r0@27
  int v18; // r0@27
  char *v19; // r2@28
  char *v20; // r2@33
  char *v21; // r2@37
  char *v22; // r2@41
  char *v23; // r2@45
  char *v24; // r2@49
  char *v25; // r2@53
  char *v26; // r2@57
  char *v27; // r2@61
  char *v28; // r2@65
  char *v29; // r2@70
  char *v30; // r2@75
  char *v31; // r2@80
  char *v32; // r2@84
  char *v33; // r2@88
  bool v34; // zf@91
  char *v35; // r1@94
  int v36; // r4@97
  int v37; // r0@97
  char *v38; // r1@98
  int v39; // r0@100
  char *v40; // r1@101
  char *v41; // r1@104
  int v42; // r0@106
  int v43; // r0@106
  char *v44; // r2@107
  int v45; // r0@109
  int v46; // r0@109
  char *v47; // r1@110
  char *v48; // r1@113
  char *v49; // r1@116
  char *v50; // r1@119
  int v51; // r5@121
  int v52; // r0@121
  int v53; // r0@121
  int v54; // r0@122
  int v55; // r0@123
  int v56; // r0@123
  int v57; // r0@123
  int v59; // [sp+0h] [bp-6B0h]@109
  int v60; // [sp+8h] [bp-6A8h]@3
  int v61; // [sp+Ch] [bp-6A4h]@22
  int v62; // [sp+8Ch] [bp-624h]@8
  int v63; // [sp+90h] [bp-620h]@3
  int v64; // [sp+94h] [bp-61Ch]@5
  int v65; // [sp+98h] [bp-618h]@5
  int v66; // [sp+9Ch] [bp-614h]@5
  int v67; // [sp+A0h] [bp-610h]@5
  int v68; // [sp+A4h] [bp-60Ch]@22
  int v69; // [sp+A8h] [bp-608h]@27
  int v70; // [sp+ACh] [bp-604h]@29
  int v71; // [sp+C4h] [bp-5ECh]@109
  int v72; // [sp+C8h] [bp-5E8h]@106
  char v73; // [sp+138h] [bp-578h]@100
  int v74; // [sp+3A4h] [bp-30Ch]@10
  char v75; // [sp+3D4h] [bp-2DCh]@6
  int v76; // [sp+4C4h] [bp-1ECh]@8
  char v77; // [sp+4D0h] [bp-1E0h]@97
  char v78; // [sp+4F0h] [bp-1C0h]@97
  int v79; // [sp+570h] [bp-140h]@97
  int v80; // [sp+578h] [bp-138h]@26
  int v81; // [sp+678h] [bp-38h]@4
  int v82; // [sp+67Ch] [bp-34h]@5
  int v83; // [sp+680h] [bp-30h]@5
  int v84; // [sp+684h] [bp-2Ch]@5
  int v85; // [sp+688h] [bp-28h]@5
  int v86; // [sp+68Ch] [bp-24h]@1
  int v87; // [sp+694h] [bp-1Ch]@1

  v1 = a1;
  print_file("/home/httpd/js/wirelessconf2.js");
  v4 = sub_14FF4(v1, v2, v3);
  if ( !get_active_wl(v4, &v86, &v87) )
    printf("Debug it..!!");
  read_wireless_conf(&v60, &v86);
  sub_14B34((const char *)&v86);
  if ( v63 )
  {
    v81 = v63;
    v82 = v64;
    v83 = v65;
    v84 = v66;
    v85 = v67;
  }
  else
  {
    wireless_api_get_current_channelspec(&v86, &v81);
  }
  printf("<form method=get action=timepro.cgi name=basicsetup_fm>");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=smenu value=basicsetup>");
  printf("<input type=hidden name=act value=>");
  printf("<input type=hidden name=wl_mode value=%d>", v4);
  printf("<input type=hidden name=modechange value=0>");
  if ( check_wifi_regulation(&v75) )
    printf("<input type=hidden name=regulation_warning value=l>");
  printf("<input type=hidden name=dynamic_channel value=%d>", v76);
  v6 = v62 - 1;
  if ( (unsigned int)(v62 - 1) > 2 )
  {
    v7 = v74;
    if ( !v74 )
    {
      if ( v6 > 0xA )
        v7 = 40;
      else
        v5 = &unk_5E284;
      if ( v6 <= 0xA )
        v7 = v5[v6];
    }
  }
  else
  {
    v7 = 20;
  }
  printf("<input type=hidden name=channel_width value=%d>", v7);
  printf("<input type=hidden name=auto_channel value=%d>");
  printf("<input type=hidden name=wireless_mode value=%d>", 0);
  printf("<input type=hidden name=mode value=%d>", v62);
  printf("<input type=hidden name=country value=%s>", &v75);
  printf("<table class=v3_iframe_table>");
  v8 = printf("<COL width=\"27%%\"><COL width=\"27%%\"><COL WIDTH=\"46%%\">");
  str(v8);
  print_item_desc("동작 설정");
  puts("<td class=item_td colspan=2>");
  if ( v60 )
    v9 = "checked";
  else
    v9 = "";
  printf(
    "<input type=radio name=run value=1 %s onclick=\"SetWirelessForm(document,document.basicsetup_fm)\"> %s ",
    v9,
    "실행");
  print_nbsp(10);
  if ( v60 )
    v10 = "";
  else
    v10 = "checked";
  printf(
    "<input type=radio name=run value=0 %s onclick=\"SetWirelessForm(document,document.basicsetup_fm)\"> %s",
    v10,
    "중단");
  v11 = printf("</td>");
  v12 = etr(v11);
  str(v12);
  print_item_desc("네트워크이름(SSID)");
  puts("<td class=item_td>");
  v13 = sub_15F34((const char *)&v61);
  printf("<input type=text name=ssid style=\"width:205px;\" maxlength=32 size=32 value='%s'>\n", v13);
  printf((const char *)&unk_5E6AE);
  if ( v68 )
    v14 = "checked";
  else
    v14 = "";
  printf("<input type=checkbox name=broadcast_ssid value=1 %s> %s", v14, "네트워크이름 알림");
  v15 = printf("</td>");
  v16 = etr(v15);
  str(v16);
  print_item_desc("채널");
  printf("<td class=item_td>");
  printf((const char *)&unk_5E723);
  printf((const char *)&unk_5E6AE);
  if ( !v87 )
  {
    snprintf((char *)&v80, 0x100u, "timepro.cgi?tmenu=popup&smenu=searchwireless&search=channel&wl_mode=%d", v4, 0);
    printf(
      "<input type=button name='%s' value='%s' onclick=\"wireless_popup(document.basicsetup_fm, '%s','%s','%s')\">",
      "search_channel_bt",
      "채널 검색",
      &v80,
      "search_channel",
      "width=500px,height=325px,scrollbars=no,menubar=no,toolbar=no,resizable=no");
  }
  v17 = printf("</td>");
  v18 = etr(v17);
  str(v18);
  print_item_desc("인증 및 암호화");
  printf("<td class=item_td>");
  puts("<select name=personal_list style=\"width:205px;\" onchange=\"SetWirelessForm(document,document.basicsetup_fm);\">");
  printf("<option value=\"%s\" %s>%s \n", "nouse");
  if ( v69 == 9 )
  {
    if ( v70 == 4 )
      v19 = "selected";
    else
      v19 = "";
  }
  else
  {
    v19 = "";
  }
  printf("<option value=\"%s\" %s>%s (%s) \n", "wpa2psk_aes", v19, "WPA2PSK + AES", "권장");
  if ( v69 == 10 )
  {
    v20 = "selected";
    if ( v70 != 4 )
      v20 = "";
  }
  else
  {
    v20 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5E950, v20, &unk_5E962);
  if ( v69 == 5 )
  {
    v21 = "selected";
    if ( v70 != 4 )
      v21 = "";
  }
  else
  {
    v21 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_aes", v21, "WPAPSK + AES");
  if ( v69 == 9 )
  {
    v22 = "selected";
    if ( v70 != 5 )
      v22 = "";
  }
  else
  {
    v22 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", "wpa2psk_tkipaes", v22, "WPA2PSK + TKIP/AES");
  if ( v69 == 10 )
  {
    v23 = "selected";
    if ( v70 != 5 )
      v23 = "";
  }
  else
  {
    v23 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", &unk_5E98F, v23, &unk_5E9A5);
  if ( v69 == 5 )
  {
    v24 = "selected";
    if ( v70 != 5 )
      v24 = "";
  }
  else
  {
    v24 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_tkipaes", v24, "WPAPSK + TKIP/AES");
  if ( v69 == 5 )
  {
    v25 = "selected";
    if ( v70 != 3 )
      v25 = "";
  }
  else
  {
    v25 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_tkip", v25, "WPAPSK + TKIP");
  if ( v69 == 9 )
  {
    v26 = "selected";
    if ( v70 != 3 )
      v26 = "";
  }
  else
  {
    v26 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5EA00, v26, &unk_5EA14);
  if ( v69 == 10 )
  {
    v27 = "selected";
    if ( v70 != 3 )
      v27 = "";
  }
  else
  {
    v27 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5E9FA, v27, &unk_5EA0D);
  if ( v69 == 3 )
  {
    if ( (unsigned int)(v70 - 1) > 1 )
      v28 = "";
    else
      v28 = "selected";
  }
  else
  {
    v28 = "";
  }
  printf("<option value=\"%s\" %s>%s", "auto_wep", v28, "자동 + WEP");
  if ( v69 == 1 )
  {
    if ( (unsigned int)(v70 - 1) > 1 )
      v29 = "";
    else
      v29 = "selected";
  }
  else
  {
    v29 = "";
  }
  printf("<option value=\"%s\" %s>%s", "open_wep", v29, "개방 모드 + WEP");
  if ( v69 == 2 )
  {
    if ( (unsigned int)(v70 - 1) > 1 )
      v30 = "";
    else
      v30 = "selected";
  }
  else
  {
    v30 = "";
  }
  printf("<option value=\"%s\" %s>%s", "key_wep", v30, "공유 모드 + WEP");
  puts("</select>");
  puts("<select name=enterprise_list style=\"width:205px;\" onchange=\"SetWirelessForm(document,document.basicsetup_fm);\">");
  if ( v69 == 8 )
  {
    v31 = "selected";
    if ( v70 != 4 )
      v31 = "";
  }
  else
  {
    v31 = "";
  }
  printf("<option value=\"%s\" %s>%s (%s)\n", "wpa2_aes", v31, "WPA2 + AES", "권장");
  if ( v69 == 11 )
  {
    v32 = "selected";
    if ( v70 != 5 )
      v32 = "";
  }
  else
  {
    v32 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", &unk_5EB15, v32, &unk_5EB25);
  if ( v69 == 4 )
  {
    v33 = "selected";
    if ( v70 != 4 )
      v33 = "";
  }
  else
  {
    v33 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpa_aes", v33, "WPA + AES");
  puts("</select>");
  printf((const char *)&unk_5998A);
  v34 = v69 == 4;
  if ( v69 != 4 )
    v34 = v69 == 8;
  if ( v34 )
  {
    v35 = "checked";
  }
  else
  {
    v35 = "";
    if ( v69 == 11 )
      v35 = "checked";
  }
  v36 = 0;
  printf(
    "<input type=checkbox name=use_enterprise value=\"on\" onclick=\"SetWirelessForm(document,document.basicsetup_fm)\" %s> %s",
    v35,
    "802.1x 보안(기업용 설정)");
  v37 = printf("</td>");
  etr(v37);
  printf("<tr id=radius_server>");
  print_item_desc("RADIUS 서버 주소");
  printf("<td class=item_td colspan=2>");
  sub_157CC((int)"radius_server", &v77, 1);
  printf("</td>");
  printf("</tr>");
  printf("<tr id=radius_secret>");
  print_item_desc("RADIUS 서버 비밀키");
  printf("<td class=item_td>");
  printf(
    "<input type=password size=32 maxlength=64 name=radius_secret value='%s' style=\"width:205px;height:20px;ime-mode:disabled\">",
    &v78);
  printf(
    "<input type=text size=32 maxlength=64 name=radius_secret_text style=\"width:205px;height:20px;display:none;ime-mode:"
    "disabled;\" value='%s'>",
    &v78);
  printf("</td>");
  printf("<td class=item_td>");
  printf(
    "<INPUT TYPE=checkbox NAME=radius_password_view value=1 onclick=\"PasswordView(radius_secret,radius_secret_text,radiu"
    "s_password_view);\" > %s",
    "암호보기");
  printf("</td>");
  printf("</tr>");
  printf("<tr id=radius_port>");
  print_item_desc("RADIUS 서버 포트");
  printf("<td class=item_td colspan=2>");
  printf("<input type=text size=5 maxlength=5 name=radius_port value='%d' style=\"ime-mode:disabled\">", v79);
  print_nbsp(2);
  if ( v79 == 1812 )
    v38 = "";
  else
    v38 = "checked";
  printf(
    "<input type=checkbox name=radius_port_method value=manual onclick=\"ClickManualPortMethod(this,radius_port,'1812')\" %s> %s</td>",
    v38,
    "수동설정");
  printf("</td>");
  printf("</tr>");
  printf("<tr id=wpapsk_key>");
  print_item_desc("네트워크 암호");
  printf("<td class=item_td>");
  printf(
    "<input type=password maxlength=64 name=wpapsk_key value='%s' style=\"width:205px;height:20px;ime-mode:disabled\">",
    &v73);
  printf(
    "<input type=text maxlength=64 name=wpapsk_key_text style=\"width:205px;height:20px;display:none;ime-mode:disabled;\" value='%s'>",
    &v73);
  printf((const char *)&unk_5998A);
  printf(
    "<INPUT TYPE=checkbox NAME=wpapsk_password_view value=1 onclick=\"PasswordView(wpapsk_key,wpapsk_key_text,wpapsk_pass"
    "word_view);\" > %s",
    "암호보기");
  printf("</td>");
  printf("</tr>");
  printf("<tr id=wep_key>");
  print_item_desc("네트워크 암호");
  printf("<td class=item_td colspan=2>");
  printf("<table class=menu_content_list_noline_table>");
  printf("<COL width=\"30%%\"><COL width=\"70%%\">");
  v39 = print_blank_line(2, 5);
  str(v39);
  print_item_desc("WEP 암호 방식");
  printf("<td class=item_td>");
  if ( v70 == 2 )
    v40 = "";
  else
    v40 = "checked";
  printf(
    "<input type=radio name=wepkey_length value=5 %s onclick=\"SetWirelessForm(document,document.basicsetup_fm);\"> %s",
    v40,
    "WEP64");
  print_nbsp(5);
  if ( v70 == 2 )
    v41 = "checked";
  else
    v41 = "";
  printf(
    "<input type=radio name=wepkey_length value=13 %s onclick=\"SetWirelessForm(document,document.basicsetup_fm);\"> %s",
    v41,
    "WEP128");
  v42 = printf("</td>");
  v43 = etr(v42);
  str(v43);
  print_item_desc("암호 입력 방법");
  printf("<td class=item_td>");
  if ( v72 )
    v44 = "";
  else
    v44 = "checked";
  printf(
    "<input type=radio name=key_input value=%d %s onclick=\"SetWirelessForm(document,document.basicsetup_fm);\"> %s",
    0,
    v44,
    "문자열",
    0);
  print_nbsp(5);
  printf("<input type=radio name=key_input value=%d %s onclick=\"SetWirelessForm(document,document.basicsetup_fm);\"> %s");
  v45 = printf("</td>");
  v46 = etr(v45);
  str(v46);
  v59 = 0;
  print_item_desc("기본 암호 선택");
  printf("<td class=item_td>");
  if ( v71 == 1 )
    v47 = "checked";
  else
    v47 = "";
  printf("<input type=radio name=default_key value=1 %s> 1", v47);
  print_nbsp(5);
  if ( v71 == 2 )
    v48 = "checked";
  else
    v48 = "";
  printf("<input type=radio name=default_key value=2 %s> 2", v48);
  print_nbsp(5);
  if ( v71 == 3 )
    v49 = "checked";
  else
    v49 = "";
  printf("<input type=radio name=default_key value=3 %s> 3", v49);
  print_nbsp(5);
  if ( v71 == 4 )
    v50 = "checked";
  else
    v50 = "";
  printf("<input type=radio name=default_key value=4 %s> 4", v50);
  v51 = 0;
  v52 = printf("</td>");
  v53 = etr(v52);
  str(v53);
  printf("<td class=itemdesc_td>");
  printf(
    "%s<br><input type=text class=noline_desc_text name=key_length_desc value='' size=32 readOnly>",
    "암호 값을 입력하십시오");
  printf("</td>");
  printf("<td class=item_td>");
  do
  {
    ++v51;
    v54 = printf(
            "%d : <input type=text name=wep_key%d value='%s' style=\"ime-mode:disabled\">",
            v51,
            v51,
            (char *)&v60 + v36 + 196,
            v59);
    br(v54);
    v36 += 27;
  }
  while ( v51 != 4 );
  v55 = printf("</td>");
  etr(v55);
  print_blank_line(2, 5);
  printf("</table>");
  printf("</td>");
  v56 = printf("</tr>");
  str(v56);
  printf("<td class=item_td align=right colspan=3>");
  printf("<input type=button class=navi_bt name=apply_bt value=\"적용\" onclick=\"ApplyWirelessForm(document.basicsetup_fm)\">");
  v57 = printf("</td>");
  etr(v57);
  printf("</table>");
  puts("</form>");
  puts("<script>");
  puts("SetWirelessForm(document,document.basicsetup_fm);");
  printf("ChangeCountryCode(%d,%d);\n", v81, v82);
  return printf("</script>");
}
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 11450: using guessed type int __fastcall wireless_api_get_current_channelspec(_DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 117C8: using guessed type int __fastcall check_wifi_regulation(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00023004) --------------------------------------------------------
int __fastcall sub_23004(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r0@1
  int v5; // r0@4
  int v6; // r6@5
  const char *v7; // r0@7
  const char *v8; // r6@7
  char *v9; // r0@10
  const char *v10; // r7@11
  int v11; // r0@11
  const char *v12; // r0@12
  const char *v13; // r0@14
  int v14; // r0@15
  int v15; // r6@15
  const char *v16; // r0@18
  int v17; // r0@20
  const char *v18; // r1@20
  int v19; // r1@22
  signed int v20; // r2@23
  int *v21; // r0@23
  const char *v22; // r6@25
  const char *v23; // r0@27
  int v24; // r0@29
  const char *v25; // r1@29
  int v26; // r1@35
  int v27; // r1@38
  int v28; // r1@41
  const char *v29; // r0@47
  int v30; // r3@49
  int v31; // r0@51
  int v33; // [sp+4h] [bp-5ACh]@3
  char v34; // [sp+8h] [bp-5A8h]@7
  int v35; // [sp+8Ch] [bp-524h]@9
  int v36; // [sp+90h] [bp-520h]@9
  int v37; // [sp+A0h] [bp-510h]@51
  int v38; // [sp+A4h] [bp-50Ch]@15
  int v39; // [sp+A8h] [bp-508h]@15
  int v40; // [sp+C0h] [bp-4F0h]@35
  int v41; // [sp+C4h] [bp-4ECh]@35
  char dest; // [sp+C8h] [bp-4E8h]@36
  char v43; // [sp+E3h] [bp-4CDh]@39
  __int16 v44; // [sp+FEh] [bp-4B2h]@42
  _BYTE v45[3]; // [sp+119h] [bp-497h]@45
  int v46; // [sp+134h] [bp-47Ch]@32
  int v47; // [sp+4B4h] [bp-FCh]@3
  int v48; // [sp+4C0h] [bp-F0h]@11
  int v49; // [sp+4CCh] [bp-E4h]@17
  int v50; // [sp+4ECh] [bp-C4h]@23
  int v51; // [sp+56Ch] [bp-44h]@18
  int v52; // [sp+574h] [bp-3Ch]@52
  int v53; // [sp+578h] [bp-38h]@52
  int v54; // [sp+588h] [bp-28h]@1
  int v55; // [sp+590h] [bp-20h]@25
  int v56; // [sp+594h] [bp-1Ch]@1

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  if ( !get_active_wl(v4, &v54, &v56) )
    printf("Debug it..!!");
  read_wireless_conf(&v33, &v54);
  get_intvalue(v3, "run", &v33);
  get_intvalue(v3, "wl_mode", &v47);
  if ( !v33 )
  {
    set_wireless_conf(&v33, &v54);
    v5 = write_wireless_conf(&v33, &v54);
    signal_save(v5);
    return 0;
  }
  v6 = get_pvalue(v3, "ssid");
  if ( v6 )
  {
    if ( !check_unpermitted_ssid_chars() )
    {
      sf_strncpy(&v34, v6, 33);
      v7 = (const char *)get_pvalue(v3, "channel");
      v8 = v7;
      if ( v7 )
      {
        if ( !strcmp(v7, "0") )
        {
          v35 = 0;
          v36 = 0;
        }
        else
        {
          v9 = strchr(v8, 46);
          if ( v9 )
          {
            *v9 = 0;
            v10 = v9 + 1;
            v35 = atoi(v8);
            v11 = atoi(v10);
            v48 = 0;
            v36 = v11;
          }
        }
        v12 = (const char *)get_pvalue(v3, "use_enterprise");
        if ( v12 && !strcmp(v12, "on") )
        {
          v13 = (const char *)get_pvalue(v3, "enterprise_list");
          if ( v13 )
          {
            sub_159DC(v13, 0, &v38, &v39);
            v14 = get_pvalue(v3, "radius_server");
            v15 = v14;
            if ( v14 )
            {
              if ( !check_unpermitted_chars(v14) )
                sf_strncpy(&v49, v15, 32);
              get_intvalue(v3, "radius_port", &v51);
              v16 = (const char *)get_pvalue(v3, "radius_password_view");
              if ( v16 && !strcmp(v16, "1") )
              {
                v17 = v3;
                v18 = "radius_secret_text";
              }
              else
              {
                v18 = "radius_secret";
                v17 = v3;
              }
              v19 = get_pvalue(v17, v18);
              if ( v19 )
              {
                v20 = 128;
                v21 = &v50;
LABEL_33:
                sf_strncpy(v21, v19, v20);
                goto LABEL_47;
              }
            }
          }
        }
        else
        {
          v55 = 0;
          v22 = (const char *)get_pvalue(v3, "personal_list");
          if ( !v22 )
            return 0;
          get_intvalue(v3, "wepkey_length", &v55);
          sub_159DC(v22, v55, &v38, &v39);
          if ( (unsigned int)(v39 - 3) > 2 )
          {
            if ( (unsigned int)(v39 - 1) <= 1 )
            {
              get_intvalue(v3, "default_key", &v40);
              get_intvalue(v3, "key_input", &v41);
              v26 = get_pvalue(v3, "wep_key1");
              if ( v26 )
                sf_strncpy(&dest, v26, 27);
              else
                strcpy(&dest, "");
              v27 = get_pvalue(v3, "wep_key2");
              if ( v27 )
                sf_strncpy(&v43, v27, 27);
              else
                strcpy(&v43, "");
              v28 = get_pvalue(v3, "wep_key3");
              if ( v28 )
                sf_strncpy(&v44, v28, 27);
              else
                strcpy((char *)&v44, "");
              v19 = get_pvalue(v3, "wep_key4");
              if ( v19 )
              {
                v20 = 27;
                v21 = (int *)v45;
                goto LABEL_33;
              }
              strcpy(v45, "");
            }
LABEL_47:
            v29 = (const char *)get_pvalue(v3, &unk_5F528);
            v30 = v29 && !strcmp(v29, "1");
            v37 = v30;
            set_active_wl(&v54, v56);
            write_wireless_conf(&v33, &v54);
            set_wireless_conf(&v33, &v54);
            v31 = signal_start("fwsched");
            signal_save(v31);
            if ( !v35 )
            {
              sleep(0xAu);
              wireless_api_get_current_channelspec(&v54, &v52);
              printf("<script>");
              puts("parent.basicsetup_fm.auto_channel.value = 1;");
              printf((const char *)&unk_5F56C, v52, v53);
              printf("</script>");
            }
            return 0;
          }
          v23 = (const char *)get_pvalue(v3, "wpapsk_password_view");
          if ( v23 && !strcmp(v23, "1") )
          {
            v24 = v3;
            v25 = "wpapsk_key_text";
          }
          else
          {
            v25 = "wpapsk_key";
            v24 = v3;
          }
          v19 = get_pvalue(v24, v25);
          if ( v19 )
          {
            v20 = 65;
            v21 = &v46;
            goto LABEL_33;
          }
        }
      }
    }
  }
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1037C: using guessed type int __fastcall set_wireless_conf(_DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 110C0: using guessed type int __fastcall set_active_wl(_DWORD, _DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 11450: using guessed type int __fastcall wireless_api_get_current_channelspec(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11654: using guessed type int check_unpermitted_ssid_chars(void);
// 11ABC: using guessed type int __fastcall write_wireless_conf(_DWORD, _DWORD);

//----- (00023508) --------------------------------------------------------
signed int __fastcall sub_23508(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r5@1
  int v4; // r1@2
  int v5; // r2@2

  v1 = a1;
  v2 = (const char *)get_pvalue(a1, "act");
  v3 = v2;
  if ( v2 )
  {
    if ( !strcmp(v2, "apply") )
      sub_23004(v1, v4, v5);
    else
      printf("Unknown ACT: %s", v3);
  }
  return 1;
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (0002355C) --------------------------------------------------------
int __fastcall sub_2355C(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@6
  int v3; // r1@7
  unsigned int v4; // r2@7
  signed int v6; // r5@10
  bool v7; // cf@15
  bool v8; // zf@15
  int v9; // r6@20
  int v10; // r0@20
  int v11; // r0@22
  int v12; // r0@22
  int v13; // r0@22
  int v14; // r0@22
  int v15; // r0@30
  char v16; // [sp+14h] [bp-64h]@20
  char s1; // [sp+34h] [bp-44h]@1
  char dest; // [sp+44h] [bp-34h]@1
  char v19; // [sp+54h] [bp-24h]@3
  int v20; // [sp+5Ch] [bp-1Ch]@7
  unsigned int v21; // [sp+60h] [bp-18h]@5
  int v22; // [sp+64h] [bp-14h]@20

  v1 = a1;
  strcpy(&dest, "");
  get_value(v1, "search", &dest, 16);
  if ( !get_value(v1, "scan_type", &s1, 16) )
    strcpy(&s1, "normal");
  if ( !get_value(v1, "country", &v19, 8) )
    strcpy(&v19, "KR");
  if ( !get_intvalue(v1, "mode", &v21) )
  {
    v2 = "mode must be defined";
    return puts(v2);
  }
  if ( !get_intvalue(v1, "channel_width", &v20) )
  {
    v2 = "channel_width must be defined";
    return puts(v2);
  }
  v6 = v20;
  if ( v20 )
  {
    if ( v20 != 80 )
    {
      if ( v20 == 40 )
      {
        v4 = v21 - 4;
        v7 = v21 >= 9;
        v8 = v21 == 9;
        if ( v21 != 9 )
        {
          v7 = v4 >= 2;
          v8 = v4 == 2;
        }
        if ( !v8 && v7 )
          v6 = 20;
        else
          v6 = 40;
      }
      else
      {
        v6 = 20;
      }
    }
  }
  else
  {
    v6 = 40;
  }
  v9 = sub_14FF4(v1, v3, v4);
  get_active_wl(v9, &v16, &v22);
  printf("<body BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=5 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
  puts("<form method=get action=timepro.cgi name=wizard>");
  puts("<input type=hidden name=tmenu value=popup>");
  puts("<input type=hidden name=smenu value=search_fm>");
  v10 = printf("<table height=280px border=0 width=480 class=blank_table>");
  str(v10);
  puts("<td align=left valign=bottom>");
  if ( !strcmp(&dest, "channel") )
    printf("<input type=text class=noline_text name=best_ch value='' size=52 readOnly>");
  printf("</td>");
  puts("<td align=right>");
  strcmp(&dest, "channel");
  printf("<input type=button name=search_bt value=\"%s\" onclick=\"parent.iframe_scan.document.scan_fm.submit();\" disabled>");
  v11 = printf("</td>");
  v12 = etr(v11);
  str(v12);
  puts("<td colspan=2>");
  printf("<table class=wizard_outline_table><tr><td>");
  printf(
    "<iframe name=iframe_scan src=\"timepro.cgi?tmenu=iframe&smenu=%sscan&stage=start&country=%s&scan_type=%s&wl_mode=%d&"
    "ifname=%s&bw=%d\" width=485 height=240 frameborder=no scrolling=auto name=wizardscan >",
    &dest,
    &v19,
    &s1,
    v9,
    &v16,
    v6);
  printf("</iframe>");
  printf("</td></tr></table>");
  v13 = printf("</td>");
  v14 = etr(v13);
  str(v14);
  printf("<td valign=top align=left>");
  if ( !strcmp(&dest, "channel") )
    printf("설정할 채널을 두 번 클릭하거나, '채널 선택' 버튼을 클릭합니다.");
  if ( strcmp(&s1, "normal") )
    printf("접속할 AP를 두 번 클릭하거나, 'AP 선택' 버튼을 클릭합니다.");
  printf("</td>");
  printf("<td valign=top align=right>");
  if ( strcmp(&s1, "normal") || v22 || !strcmp(&dest, "channel") )
  {
    v8 = strcmp(&dest, "channel") == 0;
    printf("<input type=button name=select_bt value=\"%s\" onclick=\"%s\">");
  }
  puts("</form>");
  v15 = printf("</td>");
  etr(v15);
  printf("</table>");
  return printf("</body>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);

//----- (000238E4) --------------------------------------------------------
int __fastcall sub_238E4(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r4@1

  v1 = a1;
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  v2 = v1;
  v3 = 0;
  sub_23508(v2);
  printf("<form method=get action=timepro.cgi name=submit_fm>");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=wl_apply>");
  printf("<input type=hidden name=act value=>");
  printf("<input type=hidden name=wl_mode>");
  printf("<input type=hidden name=run>");
  printf("<input type=hidden name=ssid>");
  printf("<input type=hidden name=channel>");
  printf("<input type=hidden name=broadcast_ssid>");
  printf("<input type=hidden name=mbss_policy>");
  printf("<input type=hidden name=personal_list>");
  printf("<input type=hidden name=enterprise_list>");
  printf("<input type=hidden name=use_enterprise>");
  printf("<input type=hidden name=radius_server>");
  printf("<input type=hidden name=radius_secret>");
  printf("<input type=hidden name=radius_port>");
  printf("<input type=hidden name=wpapsk_key>");
  printf("<input type=hidden name=wepkey_length>");
  printf("<input type=hidden name=key_input>");
  printf("<input type=hidden name=default_key>");
  do
    printf("<input type=hidden name=wep_key%d>", ++v3);
  while ( v3 != 4 );
  puts("</form>");
  printf("</BODY>");
  return printf("<script> UnMaskIt(parent.document,'apply_mask'); </script>");
}

//----- (00023B30) --------------------------------------------------------
int __fastcall sub_23B30(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r0@4
  int v6; // r0@5
  int v7; // r0@5
  int v8; // r0@5
  int v9; // r0@6
  int v10; // r0@6
  int *v11; // r5@18
  int v12; // r0@18
  int v13; // r7@18
  int v14; // r10@19
  int v15; // r10@19
  int v16; // r0@19
  const char *v17; // r10@20
  void *v18; // r0@20
  unsigned int v19; // r10@37
  unsigned int v20; // r0@37
  unsigned int v21; // r11@37
  int v22; // r1@37
  int v23; // r10@37
  int v24; // r0@37
  int v25; // r9@37
  int v26; // r1@37
  int v27; // r10@37
  int v28; // r0@37
  int v29; // r1@37
  int v30; // r10@37
  int v32; // [sp+4h] [bp-34A4h]@37
  int v33; // [sp+Ch] [bp-349Ch]@4
  char v34; // [sp+10h] [bp-3498h]@4
  int v35; // [sp+14h] [bp-3494h]@4
  int v36; // [sp+3234h] [bp-274h]@19
  int v37; // [sp+3434h] [bp-74h]@37
  int v38; // [sp+3438h] [bp-70h]@37
  int v39; // [sp+343Ch] [bp-6Ch]@37
  unsigned int v40; // [sp+3440h] [bp-68h]@37
  int v41; // [sp+3460h] [bp-48h]@1

  v3 = a2;
  v4 = a3;
  if ( get_value(a1, "act", &v41, 32) && !strcmp((const char *)&v41, "clear") )
    wireless_api_clear_station_info(v3);
  v33 = 0;
  sf_strncpy(&v35, v3, 32);
  wireless_api_get_station_list(&v33);
  printf("<form method=get action=\"timepro.cgi\" name=\"wireless_info_fm\">");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=\"smenu\" value=\"info\">");
  printf("<input type=hidden name=wl_mode value=%d>", v4);
  v5 = printf("<input type=hidden name=\"act\" value=\"clear\">");
  if ( v34 & 2 )
  {
    v6 = print_start_content_table(v5);
    str(v6);
    puts("<td class=\"item_td\" align=right >");
    printf(
      "<input type=button class=\"navi_bt\" name=reset_bt value=\"%s\" onclick=\"document.forms[0].submit();\");\">",
      "통계 초기화");
    v7 = puts("</td>");
    v8 = etr(v7);
    v5 = print_end_content_table(v8);
  }
  v9 = print_start_content_table(v5);
  str(v9);
  puts("<td class=\"slim_itemdesc_td\">");
  puts("<td class=\"itemdesc_td\" width=120>");
  v10 = printf("%s", "MAC 주소");
  if ( v34 & 0x20 )
  {
    puts("<td class=\"itemdesc_td\" width=200>");
    v10 = printf("%s", "무선네트워크");
  }
  if ( v34 & 1 )
  {
    puts("<td class=\"itemdesc_td\" width=60>");
    v10 = printf("%s", "연결상태");
  }
  if ( v34 & 8 )
  {
    puts("<td class=\"itemdesc_td\">");
    v10 = printf("%s", "수신감도");
  }
  if ( v34 & 2 )
  {
    puts("<td class=\"itemdesc_td\">");
    printf("%s", "수신패킷");
    puts("<td class=\"itemdesc_td\">");
    v10 = printf("%s", "송신패킷");
  }
  if ( v34 & 4 )
  {
    puts("<td class=\"itemdesc_td\">");
    v10 = printf("%s", "마지막 통신시각");
  }
  if ( v34 & 0x10 )
  {
    puts("<td class=\"itemdesc_td\">");
    v10 = printf("%s", "접속 시간");
  }
  v11 = &v33;
  v12 = etr(v10);
  v13 = 0;
  while ( v13 < v33 )
  {
    v14 = v13++;
    str(v12);
    sprintf((char *)&v36, "%d", v13);
    puts("<td class=\"slim_item_td\">");
    printf("%s", &v36);
    puts("<td class=\"item_td\">");
    v15 = 200 * v14;
    convert_mac((char *)&v33 + v15 + 40);
    v16 = printf("%s", (char *)&v33 + v15 + 40);
    if ( v34 & 0x20 )
    {
      v17 = (char *)&v33 + v15 + 96;
      printf("<td class=item_td>");
      printf(
        "<span title=\"%s\" style=\"overflow:hidden; display:inline-block; white-space:nowrap; width:200px; text-overflow:ellipsis;\">",
        v17);
      v18 = sub_15F34(v17);
      printf("%s", v18);
      v16 = printf("</span>");
    }
    if ( v34 & 1 )
    {
      sprintf((char *)&v36, "%d Mbps", v11[20]);
      puts("<td class=\"item_td\">");
      v16 = printf("%s", &v36);
    }
    if ( v34 & 8 )
    {
      if ( v11[56] )
        sprintf((char *)&v36, "%u%%(%d dBm)", v11[23]);
      else
        sprintf((char *)&v36, "%u%%", v11[23]);
      puts("<td class=\"item_td\">");
      v16 = printf("%s", &v36);
    }
    if ( v34 & 2 )
    {
      sprintf((char *)&v36, "%u", v11[18]);
      puts("<td class=\"item_td\">");
      printf("%s", &v36);
      sprintf((char *)&v36, "%u", v11[19]);
      puts("<td class=\"item_td\">");
      v16 = printf("%s", &v36);
    }
    if ( v34 & 4 )
    {
      if ( v11[17] && get_timed_status(v16) )
        sub_1655C(v11[17], (char *)&v36, 0x200u, 1);
      else
        strcpy((char *)&v36, "-----------");
      puts("<td class=\"item_td\">");
      v16 = printf("%s", &v36);
    }
    if ( v34 & 0x10 )
    {
      puts("<td class=item_td>");
      memset(&v37, 0, 0x2Cu);
      v19 = v11[17];
      v20 = sub_4EB80(v11[17], 0x15180u);
      v21 = v20;
      v40 = v20;
      sub_4EC28(v19, 0x15180u);
      v23 = v22;
      v24 = sub_4EC48(v22, 3600);
      v25 = v24;
      v39 = v24;
      sub_4ED24(v23, 0xE10u);
      v27 = v26;
      v28 = sub_4EC48(v26, 60);
      v32 = v28;
      v38 = v28;
      v16 = sub_4ED24(v27, 0x3Cu);
      v30 = v29;
      v37 = v29;
      if ( v21 )
        v16 = printf("%d %s ", v21, "일");
      if ( v25 )
        v16 = printf("%d %s ", v25, "시간");
      if ( v32 )
        v16 = printf("%d %s ");
      if ( v30 )
        v16 = printf("%d %s ", v30, "초");
    }
    v11 += 50;
    v12 = etr(v16);
  }
  return print_end_content_table(v12);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 105E0: using guessed type int __fastcall wireless_api_get_station_list(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 113C0: using guessed type int __fastcall wireless_api_clear_station_info(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (00024104) --------------------------------------------------------
int __fastcall sub_24104(int a1, int *a2, int a3)
{
  int v3; // r5@1
  int v4; // r7@1
  int v5; // r4@1
  void *v6; // r0@1
  int v7; // r0@1
  const char *v8; // r0@2
  const char *v9; // r0@6
  int v10; // r0@8
  const char *v11; // r0@9
  const char *v12; // r1@9
  int v13; // r0@13
  int v14; // r0@13
  void *v15; // r0@13
  int v16; // r0@13
  int v17; // r0@13
  void *v18; // r0@13
  int v19; // r0@13
  int v20; // r0@13
  const char *v21; // r0@13
  int v22; // r0@13
  int v23; // r0@13
  void *v24; // r0@15
  int v25; // r0@17
  int v26; // r0@17
  const char *v27; // r1@19
  int v28; // r0@21
  void *v29; // r0@22
  int v30; // r0@22
  int v31; // r0@22
  void *v32; // r0@22
  int v33; // r0@22
  int v34; // r0@22
  int v35; // r7@23
  const char *v36; // r0@24
  const char *v37; // r1@24
  int v38; // r0@30
  int v39; // r0@31
  int v40; // r0@31
  int s; // [sp+Ch] [bp-6C4h]@1
  char v43; // [sp+10h] [bp-6C0h]@13
  int v44; // [sp+90h] [bp-640h]@13
  int v45; // [sp+A8h] [bp-628h]@18
  int v46; // [sp+ACh] [bp-624h]@22
  int v47; // [sp+B0h] [bp-620h]@22
  char s1; // [sp+3D8h] [bp-2F8h]@13
  int v49; // [sp+57Ch] [bp-154h]@1
  char v50; // [sp+650h] [bp-80h]@13
  char v51; // [sp+690h] [bp-40h]@15
  int v52; // [sp+6A4h] [bp-2Ch]@31

  v3 = a1;
  v4 = a3;
  v5 = *a2;
  memset(&s, 0, 0x570u);
  read_wireless_conf(&s, v3);
  v6 = memset(&v49, 0, 0xD4u);
  v7 = print_start_content_table(v6);
  str(v7);
  print_item_desc("동작 상태");
  puts("<td class=\"item_td\" width=390>");
  if ( s )
  {
    if ( get_ifstatus(v3) )
    {
      if ( get_wifi_switch_status(0) )
        v9 = "동작중";
      else
        v9 = "무선 스위치에 의해 꺼짐";
      printf(v9);
      v10 = printf(" - ");
      if ( wireless_api_get_mimo(v10) )
      {
        v11 = "%s ";
        v12 = (const char *)&unk_55260;
      }
      else
      {
        v11 = "%s ";
        v12 = "AP 모드";
      }
      printf(v11, v12);
      goto LABEL_13;
    }
    v8 = (const char *)&unk_518CC;
  }
  else
  {
    v8 = "중단됨";
  }
  printf(v8);
LABEL_13:
  v13 = puts("</td>");
  v14 = etr(v13);
  str(v14);
  print_item_desc("네트워크 이름(SSID)");
  puts("<td class=\"item_td\">");
  v15 = sub_15F34(&v43);
  printf("%s", v15);
  v16 = puts("</td>");
  v17 = etr(v16);
  str(v17);
  print_item_desc("모드");
  puts("<td class=\"item_td\">");
  v18 = sub_15410(v44);
  printf("%s", v18);
  v19 = puts("</td>");
  v20 = etr(v19);
  str(v20);
  print_item_desc("지역 ");
  puts("<td class=\"item_td\">");
  v21 = sub_1497C(&s1);
  sf_strncpy(&v50, v21, 64);
  printf("%s", &v50);
  v22 = puts("</td>");
  v23 = etr(v22);
  str(v23);
  print_item_desc("채널");
  puts("<td class=\"item_td\">");
  if ( s && get_ifstatus(v3) )
  {
    wireless_api_get_current_channelspec(v3, &v51);
    v24 = sub_14A54((int)&v51);
    printf("%s", v24);
  }
  else
  {
    printf("--");
  }
  v25 = puts("</td>");
  v26 = etr(v25);
  if ( !v5 )
  {
    str(v26);
    print_item_desc("네트워크이름(SSID) 알림 기능");
    puts("<td class=\"item_td\">");
    if ( v45 )
      v27 = "동작중";
    else
      v27 = "중단됨";
    printf("%s", v27, "중단됨");
    v28 = puts("</td>");
    v26 = etr(v28);
  }
  str(v26);
  print_item_desc("인증방법");
  puts("<td class=\"item_td\">");
  v29 = sub_13300(v46);
  printf("%s", v29);
  v30 = puts("</td>");
  v31 = etr(v30);
  str(v31);
  print_item_desc("암호화방법");
  puts("<td class=\"item_td\">");
  v32 = sub_133EC(v47);
  printf("%s", v32);
  v33 = puts("</td>");
  v34 = etr(v33);
  if ( !v5 )
  {
    v35 = macauth_get_policy(v4 << 16);
    str(v35);
    print_item_desc("MAC 주소 인증");
    puts("<td class=\"item_td\">");
    if ( v35 )
    {
      if ( v35 == 1 )
      {
        v36 = "%s";
        v37 = "등록된 주소만 차단";
      }
      else
      {
        if ( v35 != 2 )
        {
LABEL_30:
          v38 = puts("</td>");
          v34 = etr(v38);
          goto LABEL_31;
        }
        v36 = "%s";
        v37 = "등록된 주소만 허용";
      }
    }
    else
    {
      v36 = "%s";
      v37 = "모두 허용";
    }
    printf(v36, v37);
    goto LABEL_30;
  }
LABEL_31:
  str(v34);
  print_item_desc("무선 MAC 주소");
  strcpy((char *)&v52, "");
  get_hwaddr_kernel(v3, &v52);
  convert_mac(&v52);
  printf("<td class=item_td>%s\n", &v52);
  v39 = puts("</td>");
  v40 = etr(v39);
  return print_end_content_table(v40);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11000: using guessed type int __fastcall wireless_api_get_mimo(_DWORD);
// 11270: using guessed type int __fastcall macauth_get_policy(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11450: using guessed type int __fastcall wireless_api_get_current_channelspec(_DWORD, _DWORD);
// 11474: using guessed type int __fastcall get_wifi_switch_status(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11B70: using guessed type int __fastcall get_ifstatus(_DWORD);

//----- (00024590) --------------------------------------------------------
int __fastcall sub_24590(int a1, int a2, int a3)
{
  int v3; // r7@1
  int v4; // r4@1
  const char *v5; // r0@2
  char v7; // [sp+4h] [bp-3Ch]@1
  int v8; // [sp+24h] [bp-1Ch]@1

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  get_active_wl(v4, &v7, &v8);
  print_sub_title("무선 설정 상태", 1);
  sub_24104((int)&v7, &v8, v4);
  print_blank_line(3, 15);
  if ( wireless_get_multibridge_enable(v4) )
  {
    v5 = "무선 멀티브리지 설정 상태(2.4GHz)";
    if ( v4 == 1 )
      v5 = "무선 멀티브리지 설정 상태(5GHz)";
    print_sub_title(v5, 1);
    sub_15158((int)&v7, 1);
    print_blank_line(3, 15);
  }
  if ( !v8 && wireless_api_get_run(&v7) )
  {
    print_sub_title("무선 클라이언트 정보", 1);
    sub_23B30(v3, (int)&v7, v4);
  }
  return printf("</form>");
}
// 100A0: using guessed type int __fastcall wireless_get_multibridge_enable(_DWORD);
// 10808: using guessed type int __fastcall wireless_api_get_run(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (000246E4) --------------------------------------------------------
int sub_246E4()
{
  printf("<TR height=20 STYLE=\"cursor:pointer; background-Color:#%s\">");
  return printf("<TD colspan=3></TD></TR>");
}

//----- (00024738) --------------------------------------------------------
int __fastcall sub_24738(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  char *v4; // r0@2
  char *v5; // r2@5
  int v6; // r4@8
  char *v8; // [sp+0h] [bp-340h]@0
  char *v9; // [sp+4h] [bp-33Ch]@0
  char s; // [sp+8h] [bp-338h]@1
  char v11[256]; // [sp+208h] [bp-138h]@1
  char v12; // [sp+308h] [bp-38h]@8

  v2 = a1;
  v3 = a2;
  memset(&s, 0, 0x200u);
  convert_euckr_to_utf8(v2, &s);
  strcpy(v11, "");
  if ( *(_BYTE *)(v2 + 128) )
    v4 = &v11[snprintf(v11, 0x80u, "%s", v2 + 128)];
  else
    v4 = v11;
  if ( s )
  {
    v5 = ")";
    v8 = &s;
    if ( v4 == v11 )
      v5 = "";
    v9 = v5;
    snprintf(v4, 0x80u, "%s%s%s");
  }
  v6 = v2 + 148;
  printf("<tr id=\"mac_row_%d\" style=\"cursor:pointer; background-color:#%s;\">", v3);
  printf(
    "<td align=left style=\"padding-left:5px;\"><input type=checkbox name=\"addmacchk\" value=\"%s_%s\"></td>",
    v6,
    v11);
  printf("<td onclick=\"ClickMac('%d', '%s', '%s')\">", v3, v6, &s, v8, v9);
  sf_strncpy(&v12, v6, 32);
  convert_mac(&v12);
  printf("%s", &v12);
  printf("</td><td align=left onclick=\"ClickMac('%d', '%s','%s');\">", v3, v6, &s);
  printf(
    "<span title=\"%s\" style=\"color:#888888; overflow:hidden; display:inline-block; white-space:nowrap; width:120px; te"
    "xt-overflow:ellipsis;\">%s</span>",
    v11,
    v11);
  return printf("</td></tr>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 1103C: using guessed type int __fastcall convert_euckr_to_utf8(_DWORD, _DWORD);
// 24738: using guessed type char var_138[256];

//----- (000248E8) --------------------------------------------------------
int __fastcall sub_248E8(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r5@1
  int v4; // r9@2
  int v5; // r6@3
  const char *v6; // r0@7
  const char *v7; // r5@7
  const char *v8; // r0@9
  const char *v9; // r4@9
  int v10; // r1@10
  int v11; // r0@11
  int v12; // r0@17
  int v13; // r5@22
  const char *v14; // r1@22
  int v15; // r10@22
  int v16; // r8@24
  int v17; // r4@24
  int v18; // r5@24
  int v19; // r6@28
  int v20; // r7@28
  const char *v21; // r2@28
  void *v22; // r1@30
  char *v23; // r3@30
  char v24; // r12@30
  int v25; // r2@33
  int v26; // r12@38
  const char *v27; // r0@42
  const char *v28; // r0@45
  void *v29; // r0@53
  const char *v30; // r1@54
  int v31; // r5@58
  const char *v32; // r1@60
  int v34; // [sp+0h] [bp-5F8h]@0
  char v35; // [sp+8h] [bp-5F0h]@32
  int v36; // [sp+10h] [bp-5E8h]@24
  int v37; // [sp+18h] [bp-5E0h]@25
  int v38; // [sp+1Ch] [bp-5DCh]@37
  int v39; // [sp+588h] [bp-70h]@30
  int v40; // [sp+5A8h] [bp-50h]@24
  int v41; // [sp+5C8h] [bp-30h]@7
  int v42; // [sp+5CCh] [bp-2Ch]@1

  v1 = a1;
  v42 = 0;
  get_intvalue(a1, "bssidx", &v42);
  v2 = (const char *)get_pvalue(v1, "refresh");
  v3 = v2;
  if ( !v2 )
    goto LABEL_6;
  v4 = strcmp(v2, "right");
  if ( v4 )
  {
    v5 = strcmp(v3, "left");
    if ( !v5 )
    {
      v4 = 1;
      goto LABEL_7;
    }
LABEL_6:
    v5 = 1;
    v4 = 1;
    goto LABEL_7;
  }
  v5 = 1;
LABEL_7:
  v41 = 0;
  v6 = (const char *)get_pvalue(v1, "act");
  v7 = v6;
  if ( v6 )
  {
    if ( strcmp(v6, "apply") )
    {
      v12 = strcmp(v7, "refresh");
      if ( !v12 )
        v12 = get_intvalue(v1, "bssidx", &v41);
      goto LABEL_21;
    }
    get_intvalue(v1, "bssidx", &v41);
    v8 = (const char *)get_pvalue(v1, "policy");
    v9 = v8;
    if ( v8 )
    {
      v10 = strcmp(v8, "open");
      if ( v10 )
      {
        if ( !strcmp(v9, "deny") )
        {
          v11 = v41;
          v10 = 2;
        }
        else
        {
          if ( strcmp(v9, "accept") )
            goto LABEL_17;
          v11 = v41;
          v10 = 1;
        }
      }
      else
      {
        v11 = v41;
      }
      macauth_set_policy(v11, v10);
LABEL_17:
      v12 = strcmp(v9, "open");
      if ( v12 )
        v12 = bcm_wireless_macauth_kickall(v41);
LABEL_21:
      signal_save(v12);
      goto LABEL_22;
    }
  }
LABEL_22:
  print_file("/home/httpd/js/wirelessconf2.js");
  v13 = HIWORD(v42);
  v14 = "eth2";
  v15 = 0;
  if ( HIWORD(v42) == 1 )
    v14 = "eth1";
  v16 = v5;
  sf_strncpy(&v40, v14, 32);
  v36 = wireless_api_get_run(&v40);
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  printf("<form method=get action=timepro.cgi name=bsslist_fm>");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=macauth_bsslist>");
  printf("<input type=hidden name=ifname value=\"%s\">", &v40);
  v17 = 0;
  printf("<input type=hidden name=act value=>");
  printf("<input type=hidden name=wl_mode value=%d>", v13);
  v18 = v13 << 16;
  printf("<input type=hidden name=bssidx>");
  printf("<input type=hidden name=policy>");
  printf("<table class=v3_iframe_table>");
  printf("<COL WIDTH=7%%><COL WIDTH=40%%><COL WIDTH=53%%>");
  while ( 1 )
  {
    memset(&v37, 0, 0x570u);
    if ( v42 == v18 )
      v15 = v17;
    if ( !read_mbssid_conf(v18, &v37) )
      break;
    v19 = macauth_get_policy(v18);
    v20 = macauth_get_count(v18);
    v21 = "";
    if ( !v37 )
      v21 = (const char *)&unk_6058E;
    strcpy((char *)&v39, v21);
    printf(
      "<TR height=26 ID=bss_row_%d STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickMacAuthBss(%d, 1,1);\">",
      v17);
    v22 = sub_16094();
    v23 = "off";
    v24 = v36;
    if ( v36 )
      v24 = 1;
    v35 = v24;
    if ( v37 )
      v25 = v24 & 1;
    else
      v25 = 0;
    if ( v25 )
      v23 = "on";
    printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_%s.png\"></TD>", v22, v23);
    sub_15F34((const char *)&v38);
    v34 = v17;
    printf("<TD %s>%s</TD><TD %s ID=bssidx_%d_value>");
    if ( v37 )
      v26 = v35 & 1;
    else
      v26 = 0;
    if ( !v26 )
    {
      v27 = "무선기능 OFF";
      goto LABEL_52;
    }
    if ( !v19 )
    {
      v27 = "<span class='gray_text'>MAC주소 인증 사용하지 않음</span>";
LABEL_52:
      printf(v27);
      goto LABEL_53;
    }
    if ( v19 != 1 )
    {
      if ( v19 != 2 )
        goto LABEL_53;
      printf("MAC주소 인증 사용 중");
      if ( !v20 )
        goto LABEL_53;
      v28 = "(허용된 MAC주소: %d 개)";
      goto LABEL_50;
    }
    printf("MAC주소 인증 사용 중");
    if ( v20 )
    {
      v28 = "(차단된 MAC주소: %d 개)";
LABEL_50:
      printf(v28, v20);
    }
LABEL_53:
    printf("</TD>");
    printf("</TR>");
    v29 = sub_15F34((const char *)&v38);
    printf("<input type=hidden name=\"m_ssid\" value='%s'>\n", v29);
    if ( v19 )
    {
      v30 = "deny";
      if ( v19 == 1 )
        v30 = "accept";
    }
    else
    {
      v30 = "open";
    }
    ++v17;
    printf("<input type=hidden name=\"m_policy\" value=\"%s\">\n", v30);
    printf("<input type=hidden name=\"m_bssidx\" value=\"%d\">\n", v18++);
  }
  v31 = 0;
  while ( v31 < 5 - v17 )
  {
    if ( ((_BYTE)v31 + (_BYTE)v17) & 1 )
      v32 = "f7f7f7";
    else
      v32 = "ffffff";
    ++v31;
    printf("<TR height=26 STYLE=\"cursor:pointer; background-Color:#%s\">", v32);
    printf("<TD colspan=%d></TD></TR>", 3);
  }
  printf("</TABLE>");
  printf("</form>");
  puts("<script>");
  printf("ClickMacAuthBss(%d, %d, %d);", v15, v4, v16, v34);
  return puts("</script>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10808: using guessed type int __fastcall wireless_api_get_run(_DWORD);
// 10D90: using guessed type int __fastcall macauth_set_policy(_DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11270: using guessed type int __fastcall macauth_get_policy(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 1151C: using guessed type int __fastcall read_mbssid_conf(_DWORD, _DWORD);
// 116F0: using guessed type int __fastcall macauth_get_count(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 11C24: using guessed type int __fastcall bcm_wireless_macauth_kickall(_DWORD);

//----- (00024E24) --------------------------------------------------------
signed int __fastcall sub_24E24(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r10@1
  int v7; // r6@1
  int i; // r7@1
  int v9; // r0@2
  int v10; // r8@2

  v4 = a2;
  v5 = a3;
  v6 = a4;
  v7 = a1;
  for ( i = 0; i < v4; ++i )
  {
    v9 = maccmp(v7 + 20, v5);
    v10 = v7;
    v7 += 108;
    if ( !v9 )
    {
      sf_strncpy(v6, v10 + 44, 128);
      return 1;
    }
  }
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1184C: using guessed type int __fastcall maccmp(_DWORD, _DWORD);

//----- (00024E88) --------------------------------------------------------
signed int __fastcall sub_24E88(int a1, char *a2, int a3)
{
  int v3; // r5@1
  int v4; // r0@1
  void *v5; // r9@1
  int v6; // r5@1
  signed int v7; // r6@1
  char *v8; // r8@3
  signed int v9; // r4@6
  void *v10; // r7@6
  void *v11; // r5@6
  int v12; // r10@6
  int v13; // r8@7
  int i; // r11@8
  int v15; // r3@15
  bool v16; // nf@15
  unsigned __int8 v17; // vf@15
  char *base; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@1
  int v21; // [sp+1Ch] [bp-4h]@1
  int v22[3208]; // [sp+20h] [bp+0h]@1
  int v23[3208]; // [sp+28h] [bp+8h]@1

  v3 = a1;
  base = a2;
  v21 = a3;
  v4 = dhcpd_get_all_dynamic_lease(0);
  v5 = malloc(108 * v4);
  v20 = dhcpd_get_all_dynamic_lease(v5);
  v22[0] = 0;
  sf_strncpy(v23, v3, 32);
  v6 = 0;
  wireless_api_get_station_list(v22);
  v7 = 0;
  while ( v6 < v22[0] )
  {
    if ( strcmp((const char *)&v22[50 * v6 + 10], "00:00:00:00:00:00") )
    {
      convert_mac(&v22[50 * v6 + 10]);
      v8 = &base[188 * v7++];
      memset(v8, 0, 0xBCu);
      sf_strncpy(v8 + 148, &v22[50 * v6 + 10], 20);
      get_ip_by_hwaddr(v8 + 128, v8 + 148);
      sub_24E24((int)v5, v20, (int)(v8 + 148), (int)v8);
      convert_mac2(v8 + 148);
    }
    ++v6;
  }
  v9 = v7;
  v10 = malloc(0x604u);
  v11 = v10;
  memset(v10, 0, 0x604u);
  macauth_read_trylist(v10, "/proc/driver/wireless_mac_try_list");
  v12 = 0;
  while ( 1 )
  {
    v15 = *(_DWORD *)v10;
    v17 = __OFSUB__(v9, v21);
    v16 = v9 - v21 < 0;
    if ( v9 < v21 )
    {
      v17 = __OFSUB__(v12, v15);
      v16 = v12 - v15 < 0;
    }
    if ( !(v16 ^ v17) )
      break;
    v13 = (int)&base[188 * v9];
    memset((void *)v13, 0, 0xBCu);
    sprintf(
      (char *)(v13 + 148),
      "%02X:%02X:%02X:%02X:%02X:%02X",
      *((_BYTE *)v11 + 4),
      *((_BYTE *)v11 + 5),
      *((_BYTE *)v11 + 6),
      *((_BYTE *)v11 + 7),
      *((_BYTE *)v11 + 8),
      *((_BYTE *)v11 + 9));
    if ( strcmp((const char *)(v13 + 148), "00:00:00:00:00:00") )
    {
      for ( i = 0; i < v22[0]; ++i )
      {
        if ( !maccmp(&v22[50 * i + 10], v13 + 148) )
          goto LABEL_14;
      }
      get_ip_by_hwaddr(v13 + 128, v13 + 148);
      sub_24E24((int)v5, v20, v13 + 148, v13);
      ++v9;
    }
LABEL_14:
    ++v12;
    v11 = (char *)v11 + 12;
  }
  free(v10);
  free(v5);
  qsort(base, v9, 0xBCu, (__compar_fn_t)sub_2472C);
  return v9;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10304: using guessed type int __fastcall get_ip_by_hwaddr(_DWORD, _DWORD);
// 1052C: using guessed type int __cdecl dhcpd_get_all_dynamic_lease(_DWORD);
// 105E0: using guessed type int __fastcall wireless_api_get_station_list(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10A30: using guessed type int __fastcall convert_mac2(_DWORD);
// 11660: using guessed type int __fastcall macauth_read_trylist(_DWORD, _DWORD);
// 1184C: using guessed type int __fastcall maccmp(_DWORD, _DWORD);
// 2472C: using guessed type int sub_2472C();
// 24E88: using guessed type int var_322C[3208];

//----- (0002510C) --------------------------------------------------------
signed int __fastcall sub_2510C(_DWORD *a1, int a2, const char *a3)
{
  _DWORD *v3; // r4@1
  const char *v4; // r5@1
  int v5; // r6@1
  int v6; // r8@2
  signed int result; // r0@4
  void *v8; // r0@5
  __int16 v9; // r1@10
  int v10; // r6@10
  int v11; // r2@12
  _DWORD *v12; // [sp+0h] [bp-20h]@1
  int v13; // [sp+4h] [bp-1Ch]@1

  v12 = a1;
  v13 = a2;
  v3 = a1;
  v4 = a3;
  v5 = 0;
  strtomac(a2, &v12);
  while ( 1 )
  {
    if ( v5 >= *v3 )
    {
      v9 = v13;
      v10 = (int)&v3[4 * *v3];
      *(_DWORD *)(v10 + 8) = v12;
      *(_WORD *)(v10 + 12) = v9;
      if ( v4 )
        *(_DWORD *)(v10 + 16) = strdup(v4);
      result = 1;
      v11 = (int)&v3[4 * (*v3)++];
      *(_DWORD *)(v11 + 4) = 0;
      return result;
    }
    v6 = (int)&v3[4 * v5];
    if ( !memcmp(&v12, (const void *)(v6 + 8), 6u) )
      break;
    ++v5;
  }
  if ( v4 )
  {
    v8 = *(void **)(v6 + 16);
    if ( v8 )
      free(v8);
    v3[4 * v5 + 4] = strdup(v4);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106C4: using guessed type int __fastcall strtomac(_DWORD, _DWORD);

//----- (000251D4) --------------------------------------------------------
signed int __fastcall sub_251D4(_DWORD *a1, int a2)
{
  _DWORD *v2; // r5@1
  int v3; // r4@1
  int v4; // r6@2
  _DWORD *v6; // [sp+0h] [bp-20h]@1
  int v7; // [sp+4h] [bp-1Ch]@1

  v6 = a1;
  v7 = a2;
  v2 = a1;
  v3 = 0;
  strtomac(a2, &v6);
  while ( v3 < *v2 )
  {
    v4 = (int)&v2[4 * v3++];
    if ( !memcmp(&v6, (const void *)(v4 + 8), 6u) )
      *(_DWORD *)(v4 + 4) = 1;
  }
  return 1;
}
// 106C4: using guessed type int __fastcall strtomac(_DWORD, _DWORD);

//----- (0002522C) --------------------------------------------------------
int __fastcall sub_2522C(int a1)
{
  int v1; // r5@1
  int v2; // r10@1
  int v3; // r9@1
  int result; // r0@1
  int v5; // r4@2
  int v6; // r7@2
  char *v7; // r11@5
  const char *v8; // r0@12
  int v9; // r7@13
  int v10; // r7@22
  void *v11; // r0@25
  int v12; // r0@36
  char s; // [sp+Ch] [bp-36Ch]@22
  char v14; // [sp+20Ch] [bp-16Ch]@1
  char v15; // [sp+30Ch] [bp-6Ch]@20
  char v16; // [sp+32Ch] [bp-4Ch]@1
  int v17; // [sp+34Ch] [bp-2Ch]@1

  v1 = a1;
  v17 = 0;
  v2 = hwinfo_get_max_macauth(a1);
  get_intvalue_post(v1, "bssidx", &v17);
  v3 = macauth_get_policy(v17);
  strcpy(&v14, "");
  result = get_value_post(v1, "act", &v16, 32);
  if ( result )
  {
    v5 = macdb_read(v17, v2);
    v6 = strcmp(&v16, "register");
    if ( v6 )
    {
      v9 = strcmp(&v16, "unregister");
      if ( v9 )
      {
        if ( strcmp(&v16, (const char *)&unk_60979) )
        {
LABEL_36:
          v12 = macdb_free(v5);
          signal_save(v12);
          return 1;
        }
        if ( !get_value_post(v1, "manual_mac", &v15, 32) )
        {
          macdb_free(v5);
          return 0;
        }
        v10 = macdb_search(v5, &v15);
        strcpy(&s, "");
        get_value_post(v1, "info", &s, 512);
        if ( check_unpermitted_chars(&s) )
          strcpy(&s, "");
        if ( v10 )
        {
          v11 = *(void **)(v10 + 12);
          if ( v11 )
            free(v11);
          *(_DWORD *)(v10 + 12) = strdup(&s);
          macdb_write(v17, v5);
        }
        else if ( *(_DWORD *)v5 < v2 )
        {
          if ( !strcmp(&s, "설명을 입력하세요") )
            strcpy(&s, "");
          convert_mac2(&v15);
          if ( v3 == 1 )
            wireless_macauth_kickmac(v17, &v15);
          sub_2510C((_DWORD *)v5, (int)&v15, &s);
          qsort((void *)(v5 + 4), *(_DWORD *)v5, 0x10u, (__compar_fn_t)sub_2471C);
          macdb_write(v17, v5);
          wireless_apply_macauth(v17, v5);
        }
        v8 = "<script> parent.macauth_bsslist.location.href = 'timepro.cgi?tmenu=iframe&smenu=macauth_bsslist&bssidx=%d'; </script>";
      }
      else
      {
        while ( get_value_array_post(v1, "rmmacchk", v9, &v14) )
        {
          convert_mac2(&v14);
          if ( v3 == 2 )
            wireless_macauth_kickmac(v17, &v14);
          sub_251D4((_DWORD *)v5, (int)&v14);
          ++v9;
        }
        qsort((void *)(v5 + 4), *(_DWORD *)v5, 0x10u, (__compar_fn_t)sub_2471C);
        macdb_write(v17, v5);
        wireless_apply_macauth(v17, v5);
        signal_start("fwsched");
        v8 = "<script> parent.macauth_bsslist.location.href = 'timepro.cgi?tmenu=iframe&smenu=macauth_bsslist&bssidx=%d&r"
             "efresh=right'; </script>";
      }
    }
    else
    {
      while ( *(_DWORD *)v5 != v2 && get_value_array_post(v1, "addmacchk", v6, &v14) )
      {
        v7 = strchr(&v14, 95);
        if ( v7 )
          *v7++ = 0;
        convert_mac2(&v14);
        if ( v3 == 1 )
          wireless_macauth_kickmac(v17, &v14);
        if ( check_unpermitted_chars(v7) )
          strcpy(v7, "");
        ++v6;
        sub_2510C((_DWORD *)v5, (int)&v14, v7);
      }
      qsort((void *)(v5 + 4), *(_DWORD *)v5, 0x10u, (__compar_fn_t)sub_2471C);
      macdb_write(v17, v5);
      wireless_apply_macauth(v17, v5);
      v8 = "<script> parent.macauth_bsslist.location.href = 'timepro.cgi?tmenu=iframe&smenu=macauth_bsslist&bssidx=%d&ref"
           "resh=left'; </script>";
    }
    printf(v8, v17);
    goto LABEL_36;
  }
  return result;
}
// 10220: using guessed type int __fastcall get_intvalue_post(_DWORD, _DWORD, _DWORD);
// 102EC: using guessed type int __fastcall macdb_read(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10A30: using guessed type int __fastcall convert_mac2(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10C40: using guessed type int __fastcall macdb_search(_DWORD, _DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 10F7C: using guessed type int __fastcall wireless_macauth_kickmac(_DWORD, _DWORD);
// 10F88: using guessed type int __fastcall macdb_free(_DWORD);
// 110FC: using guessed type int __fastcall wireless_apply_macauth(_DWORD, _DWORD);
// 11270: using guessed type int __fastcall macauth_get_policy(_DWORD);
// 11300: using guessed type int __fastcall hwinfo_get_max_macauth(_DWORD);
// 11624: using guessed type int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11C78: using guessed type int __fastcall macdb_write(_DWORD, _DWORD);
// 2471C: using guessed type int sub_2471C();

//----- (000255E4) --------------------------------------------------------
int __fastcall sub_255E4(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r7@1
  int v4; // r6@1
  const char *v5; // r1@5
  _DWORD *v6; // r4@9
  void *v7; // r5@9
  signed int v8; // r10@9
  char *v9; // r0@9
  signed int v10; // r6@9
  signed int v11; // r8@9
  int v12; // r1@13
  int v14; // [sp+0h] [bp-58h]@7
  char v15; // [sp+20h] [bp-38h]@9
  int v16; // [sp+34h] [bp-24h]@1

  v2 = a2;
  v3 = a1;
  v16 = 0;
  v4 = hwinfo_get_max_macauth(a1);
  print_file("/home/httpd/js/wirelessconf2.js");
  if ( v2 )
    get_intvalue_post(v2, "bssidx", &v16);
  else
    get_intvalue(v3, "bssidx", &v16);
  if ( SHIWORD(v16) == 1 )
    v5 = "eth1";
  else
    v5 = "eth2";
  sf_strncpy(&v14, v5, 32);
  if ( v2 )
    sub_2522C(v2);
  v6 = (_DWORD *)macdb_read(v16, v4);
  v7 = malloc(0xBC00u);
  memset(v7, 0, 0xBC00u);
  v8 = sub_24E88((int)&v14, (char *)v7, 256);
  strcpy(&v15, "");
  v9 = getenv("REMOTE_ADDR");
  get_internal_pc_hardware_address(v9, &v15);
  puts("<BODY BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
  printf("<form name=\"macauth_pcinfo_fm\" method=post>");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"macauth_pcinfo\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"bssidx\" value=%d>", v16);
  printf("<input type=hidden name=\"maxmac_count\" value=\"%d\">", v4);
  v10 = 0;
  v11 = 0;
  printf("<input type=hidden name=\"rmac_count\" value=\"%d\">", *v6);
  printf("<table class=v3_table cellspacing=0px cellpadding=0px width=100%% border=0>");
  printf("<COL width=10%%><COL width=46%%><COL width=44%%>");
  while ( v11 < v8 )
  {
    if ( !macdb_search(v6, (char *)v7 + 148) )
    {
      if ( v15 )
        maccmp(&v15, (char *)v7 + 148);
      v12 = v10++;
      sub_24738((int)v7, v12);
    }
    ++v11;
    v7 = (char *)v7 + 188;
  }
  while ( v10 <= 12 )
  {
    ++v10;
    sub_246E4();
  }
  puts("</table>");
  puts("</form>");
  puts("</BODY>");
  return macdb_free(v6);
}
// 10220: using guessed type int __fastcall get_intvalue_post(_DWORD, _DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102EC: using guessed type int __fastcall macdb_read(_DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10C40: using guessed type int __fastcall macdb_search(_DWORD, _DWORD);
// 10F88: using guessed type int __fastcall macdb_free(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11300: using guessed type int __fastcall hwinfo_get_max_macauth(_DWORD);
// 1184C: using guessed type int __fastcall maccmp(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00025814) --------------------------------------------------------
int __fastcall sub_25814(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r7@1
  int v4; // r5@1
  signed int *v5; // r6@4
  int result; // r0@5
  int v7; // r0@6
  int v8; // r0@6
  const char *v9; // r0@7
  char *v10; // r0@9
  int v11; // r11@9
  signed int *v12; // r4@11
  int v13; // r5@11
  char *v14; // r3@12
  char *v15; // r3@18
  int v16; // r1@18
  signed int v17; // t1@20
  signed int v18; // r9@21
  int v19; // r0@22
  int v20; // r4@23
  char v21; // [sp+18h] [bp-80h]@12
  char s; // [sp+38h] [bp-60h]@12
  unsigned __int8 v23; // [sp+58h] [bp-40h]@9
  int v24; // [sp+6Ch] [bp-2Ch]@1

  v2 = a2;
  v3 = a1;
  v24 = 0;
  v4 = ((int (*)(void))hwinfo_get_max_macauth)();
  if ( v2 )
  {
    get_intvalue_post(v2, "bssidx", &v24);
    sub_2522C(v2);
  }
  else
  {
    get_intvalue(v3, "bssidx", &v24);
  }
  v5 = (signed int *)macdb_read(v24, v4);
  if ( v5 )
  {
    print_file("/home/httpd/js/wirelessconf2.js");
    puts("<BODY BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
    printf("<form name=\"macauth_dblist_fm\" method=post>");
    printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
    printf("<input type=hidden name=\"smenu\" value=\"macauth_dblist\">");
    printf("<input type=hidden name=\"act\" value=\"\">");
    v7 = printf("<input type=hidden name=bssidx value=%d>", v24);
    v8 = hwinfo_get_max_macauth(v7);
    printf("<input type=hidden name=\"maxmac_count\" value=\"%d\">", v8);
    printf("<input type=hidden name=\"rmac_count\" value=\"%d\">", *v5);
    printf("<input type=hidden name=\"manual_mac\">");
    printf("<input type=hidden name=\"info\">");
    printf("<table class=v3_table cellspacing=0px cellpadding=0px align=left border=0 width=100%%>\n");
    if ( *v5 <= 13 )
      v9 = "<COL width=46%%><COL width=38%%><COL width=16%%>";
    else
      v9 = "<COL width=46%%><COL width=44%%><COL width=10%%>";
    printf(v9);
    strcpy((char *)&v23, "");
    v10 = getenv("REMOTE_ADDR");
    get_internal_pc_hardware_address(v10, &v23);
    v11 = v23;
    if ( v23 )
      v11 = macdb_search(v5, &v23);
    v12 = v5;
    v13 = 0;
    while ( 1 )
    {
      v18 = *v5;
      if ( v13 >= *v5 )
        break;
      snprintf(
        &s,
        0x20u,
        "%02X:%02X:%02X:%02X:%02X:%02X",
        *((_BYTE *)v12 + 8),
        *((_BYTE *)v12 + 9),
        *((_BYTE *)v12 + 10),
        *((_BYTE *)v12 + 11),
        *((_BYTE *)v12 + 12),
        *((_BYTE *)v12 + 13));
      sf_strncpy(&v21, &s, 32);
      convert_mac(&v21);
      printf("<tr id=\"mac_row_%d\" style=\"cursor:pointer; background-color:#%s;\">", v13);
      v14 = (char *)v12[4];
      if ( !v14 )
        v14 = "";
      printf("<td onclick=\"ClickMacReg('%d','%s','%s');\" align=left style=\"padding-left:5px;\">", v13, &s, v14);
      if ( v11 == (_DWORD)&v5[4 * v13 + 1] )
        printf("<span style='font: normal normal bold 9pt arial; color:navy;'>");
      printf("%s", &v21);
      if ( v11 == (_DWORD)&v5[4 * v13 + 1] )
        printf("</span>");
      printf("</td>");
      v15 = (char *)v12[4];
      v16 = v13++;
      if ( !v15 )
        v15 = "";
      printf("<td onclick=\"ClickMacReg('%d','%s','%s');\" align=left style=\"padding-left:5px;\">", v16, &s, v15);
      v17 = v12[4];
      v12 += 4;
      printf("<span title=\"%s\" style=\"color:#888888; overflow:hidden; display:inline-block; white-space:nowrap; width:120px; text-overflow:ellipsis;\">%s</span>");
      printf("</td>");
      printf("<td align=left style=\"padding-left:5px;\"><input type=checkbox name=\"rmmacchk\" value=\"%s\"></td>", &s);
      puts("</tr>");
    }
    v19 = v13;
    while ( v18 <= 12 )
    {
      v20 = v19 + 1;
      ++v18;
      sub_246E4();
      v19 = v20;
    }
    puts("</table>");
    puts("</form>");
    puts("</BODY>");
    result = macdb_free(v5);
  }
  else
  {
    result = printf("Memory error: Refresh");
  }
  return result;
}
// 10220: using guessed type int __fastcall get_intvalue_post(_DWORD, _DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102EC: using guessed type int __fastcall macdb_read(_DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10C40: using guessed type int __fastcall macdb_search(_DWORD, _DWORD);
// 10F88: using guessed type int __fastcall macdb_free(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11300: using guessed type int __fastcall hwinfo_get_max_macauth(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00025B64) --------------------------------------------------------
int __fastcall sub_25B64(int a1)
{
  int v1; // r4@1
  int v2; // r1@1
  int v3; // r2@1
  int v4; // r4@1
  const char *v5; // r1@1
  void *v6; // r0@3
  void *v7; // r0@3
  void *v8; // r0@3
  int v9; // r0@3
  int v10; // r0@4
  int v11; // r0@6
  int v12; // r0@7
  void *v13; // r0@9
  int v14; // r0@9
  int v15; // r0@9
  char v17; // [sp+4h] [bp-24h]@3
  int v18; // [sp+14h] [bp-14h]@1

  v1 = a1;
  v18 = 0;
  print_file("/home/httpd/js/wirelessconf2.js");
  get_intvalue(v1, "bssidx", &v18);
  v4 = sub_14FF4(v1, v2, v3);
  v5 = "eth2";
  if ( v4 == 1 )
    v5 = "eth1";
  sf_strncpy(&v17, v5, 16);
  v18 |= v4 << 16;
  printf("<form method=get action=\"timepro.cgi\" name=\"macauth_fm\">");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=\"smenu\" value=\"macauth\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"wl_mode\" value=%d>", v4);
  printf("<input type=hidden name=bssidx>");
  printf("<table class=v3_table border=0>");
  printf("<COL width=\"38%%\"><COL width=\"5%%\"><COL width=\"7%%\"><COL width=\"2%%\"><COL width=\"38%%\"><COL width=\"10%%\">\n");
  printf("<tr><td height=104px colspan=6>");
  printf(
    "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=macauth_bsslist&bssidx=%d\" frameborder=\"no\" scrolling=\"no\" name=\""
    "macauth_bsslist\" noresize height=104 width=100%% ></iframe>\n",
    v18);
  printf("</td></tr>");
  printf("<tr><td style=\"padding-left:5px; background-color:#e6e6e6; border-style:solid; border-color:#c5c5c5; border-width:1px;\" height=22px colspan=6>");
  printf(
    "%s - <input type=input style=\"font-weight:bold;width:300px; border:0px solid #e6e6e6; background-color:#e6e6e6;\"  "
    "readOnly id=ssid_title>",
    "무선 MAC주소 인증 설정");
  printf("</td></tr>");
  printf("<tr style=\"background-color:#f7f7f7;\">");
  printf(
    "<td height=32px align=left style=\"padding-left:5px;\"><input type=checkbox name=macauth_enable onclick=\"ClickMacAu"
    "thCheck();\" value=\"on\">%s",
    "MAC주소 인증");
  print_nbsp(1);
  printf("<select name=policy_mode>");
  printf("<option value=\"deny\"> %s", "무선연결허용");
  printf("<option value=\"accept\"> %s", "무선연결차단");
  printf("</select>");
  printf("</td>");
  printf(
    "<td valign=bottom align=right><span onclick=\"UnRegisterMacAuth();\" style=\"cursor:pointer; color:#7a9263;\">%s</span></td>",
    "삭제");
  v6 = sub_160D0();
  printf(
    "<td align=left valign=bottom style=\"cursor:pointer; padding:0 0 2 3; \"><img onclick=\"UnRegisterMacAuth();\" borde"
    "r=0 src=\"%s\"></td>",
    v6);
  v7 = sub_160D0();
  printf(
    "<td onclick=\"RegisterMacAuth();\" valign=bottom style=\"cursor:pointer;padding:0 0 2 10;\" align=left><img border=0"
    " src=\"%s\"></td>",
    v7);
  printf(
    "<td valign=bottom align=left><span onclick=\"RegisterMacAuth();\" style=\"cursor:pointer; color:#7a9263;\">%s</span></td>",
    "등록");
  printf("<td></td>");
  printf("</tr>");
  printf("<tr height=30px>");
  printf(
    "<td align=left style=\"padding-left:5px; border-style:solid none solid solid; border-width:1px; border-color:#dddddd"
    ";\"><span style=\"color:#7a9263;\"><b>%s</b></span>",
    "등록된 MAC주소");
  printf("</td>");
  printf("<td colspan=2 align=right style=\"padding-right:22px; border-style:solid solid solid none; border-width:1px; border-color:#dddddd;\"><input type=checkbox name=\"del_allchk\" onclick=\"CheckAllCheckBox(macauth_dblist.document, this, 'rmmacchk');\"></td>");
  printf("<td  style=\"padding-left:5px; border-style:solid none solid solid; border-width:1px; border-color:#dddddd;\" align=left><input type=checkbox name=\"add_allchk\" onclick=\"CheckAllCheckBox(macauth_pcinfo.document, this, 'addmacchk');\"></td>");
  printf(
    "<td style=\"padding-left:5px; border-style:solid none solid none; border-width:1px; border-color:#dddddd;\"><span st"
    "yle=\"color:#7a9263;\"><b>%s</b></span>",
    "검색된 MAC주소");
  printf(
    "</td><td onclick=\"macauth_pcinfo.location.href='timepro.cgi?tmenu=iframe&smenu=macauth_pcinfo&bssidx=%d'\" align=ri"
    "ght style=\"cursor:pointer; padding-right:5px; border-style:solid solid solid none; border-width:1px; border-color:#dddddd;\">",
    v18);
  v8 = sub_160D0();
  printf("<img src=\"%s\">%s</td>", v8, "재검색");
  printf("</td>");
  printf("</tr>");
  v9 = printf("<tr><td colspan=3>");
  if ( is_mobile_agent(v9) )
  {
    sub_1682C((int)"260px", (int)"100%", (int)"display:inline-block;");
    v10 = printf(
            "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=macauth_dblist&bssidx=%d\" frameborder=\"no\" scrolling=\"yes\""
            " name=\"macauth_dblist\" noresize height=260 width=100%% ></iframe>\n",
            v18);
    sub_16878(v10);
  }
  else
  {
    printf(
      "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=macauth_dblist&bssidx=%d\" frameborder=\"no\" scrolling=\"yes\" name="
      "\"macauth_dblist\" noresize height=260 width=100%% ></iframe>\n",
      v18);
  }
  v11 = printf("</td><td colspan=3>");
  if ( is_mobile_agent(v11) )
  {
    sub_1682C((int)"260px", (int)"100%", (int)"display:inline-block;");
    v12 = printf(
            "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=macauth_pcinfo&bssidx=%d\" frameborder=\"no\" scrolling=\"yes\""
            " name=\"macauth_pcinfo\" noresize height=260 width=100%% ></iframe>\n",
            v18);
    sub_16878(v12);
  }
  else
  {
    printf(
      "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=macauth_pcinfo&bssidx=%d\" frameborder=\"no\" scrolling=\"yes\" name="
      "\"macauth_pcinfo\" noresize height=260 width=100%% ></iframe>\n",
      v18);
  }
  printf("</td></tr>");
  printf("<tr><td colspan=6>");
  printf("<table border=0 width=100%%>");
  printf("<COL width=20%%><COL width=22%%><COL width=58%%>");
  printf("<tr height=25px><td style=\"padding-left:5px;\">%s</td>", "MAC주소 수동 입력");
  printf(
    "<td align=right style=\"padding-top:3px;\"><span onclick=\"ManualRegisterMacAuth();\" style=\"cursor:pointer; color:"
    "#7a9263\">%s</span></td>",
    &unk_61BDB);
  v13 = sub_160D0();
  printf("<td style=\"cursor:pointer;\" align=left><img onclick=\"ManualRegisterMacAuth();\" src=\"%s\"></td>", v13);
  printf("</tr>");
  printf("</table>");
  printf("</td></tr>");
  printf("<tr><td height=27px colspan=6 style=\"padding-left:5px;\">");
  sub_15664((int)"hw", 0, 0);
  print_nbsp(2);
  printf(
    "<input type=text class=\"navi_text\" name=\"info\" size=17 maxlength=64 value=\"%s\" onfocus=\"FocusMacAuthInfo();\""
    " style=\"color:#888888\"\">",
    "설명을 입력하세요");
  printf("<input type=hidden name=\"default_info\" value=\"%s\">", "설명을 입력하세요");
  printf("</td></tr>");
  v14 = printf("<tr height=1px style=\"background-Color:#dddddd\"><td colspan=6></td></tr>");
  v15 = hwinfo_get_max_macauth(v14);
  printf(
    "<tr><td colspan=3 align=left><span class=\"gray_text\">등록 가능한 최대 MAC 주소는 %d개 입니다.</span>"
    "</td><td colspan=3 align=right>",
    v15);
  printf("<input type=button name=\"apply_bt\" value=\"%s\" onclick=\"ApplyWirelessMacAuth();\">", "적용");
  printf("</td></tr>");
  printf("</form>");
  return printf("</table>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11300: using guessed type int __fastcall hwinfo_get_max_macauth(_DWORD);
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00026080) --------------------------------------------------------
int __fastcall sub_26080(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r6@1

  v3 = a3;
  v4 = a1;
  v5 = a2;
  printf("<TR height=20 ID=%s STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickTr(this);\">", a1);
  return printf("<TD></TD><TD>%s</TD><TD CLASS=text_gray ID=%s_value>%s</TD></TR>", v5, v4, v3);
}

//----- (000260D4) --------------------------------------------------------
const char *__fastcall sub_260D4(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r0@1
  const char *result; // r0@3
  const char *v6; // r5@3
  int v7; // r1@7
  const char *v8; // r0@10
  const char *v9; // r0@13
  const char *v10; // r0@16
  const char *v11; // r0@19
  const char *v12; // r0@22
  const char *v13; // r0@25
  const char *v14; // r0@28
  const char *v15; // r0@31
  int v16; // r0@35
  char v17; // [sp+4h] [bp-58Ch]@3
  int v18; // [sp+88h] [bp-508h]@5
  int v19; // [sp+8Ch] [bp-504h]@33
  int v20; // [sp+90h] [bp-500h]@33
  int v21; // [sp+1ACh] [bp-3E4h]@11
  int v22; // [sp+1B8h] [bp-3D8h]@14
  int v23; // [sp+1BCh] [bp-3D4h]@17
  int v24; // [sp+1C8h] [bp-3C8h]@20
  int v25; // [sp+3A0h] [bp-1F0h]@29
  int v26; // [sp+3B4h] [bp-1DCh]@23
  int v27; // [sp+3B8h] [bp-1D8h]@23
  int v28; // [sp+3BCh] [bp-1D4h]@26
  char v29; // [sp+3D0h] [bp-1C0h]@8
  int v30; // [sp+4C0h] [bp-D0h]@32
  int v31; // [sp+4C4h] [bp-CCh]@33
  int v32; // [sp+574h] [bp-1Ch]@1
  int v33; // [sp+57Ch] [bp-14h]@1

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  if ( !get_active_wl(v4, &v32, &v33) )
    printf("Debug it..!!");
  read_wireless_conf(&v17, &v32);
  result = (const char *)get_pvalue(v3, "act");
  v6 = result;
  if ( result )
  {
    if ( !strcmp(result, "mode") )
    {
      get_intvalue(v3, "mode", &v18);
    }
    else if ( !strcmp(v6, "country") && (v7 = get_pvalue(v3, "country")) != 0 )
    {
      sf_strncpy(&v29, v7, 8);
    }
    else if ( !strcmp(v6, "tx_power") && (v8 = (const char *)get_pvalue(v3, "tx_power")) != 0 )
    {
      v21 = atoi(v8);
    }
    else if ( !strcmp(v6, "rts") && (v9 = (const char *)get_pvalue(v3, "rts")) != 0 )
    {
      v22 = atoi(v9);
    }
    else if ( !strcmp(v6, "frag") && (v10 = (const char *)get_pvalue(v3, "frag")) != 0 )
    {
      v23 = atoi(v10);
    }
    else if ( !strcmp(v6, "beacon_interval") && (v11 = (const char *)get_pvalue(v3, "beacon")) != 0 )
    {
      v24 = atoi(v11);
    }
    else if ( !strcmp(v6, "wmm") && (v12 = (const char *)get_pvalue(v3, "wmm")) != 0 )
    {
      v26 = atoi(v12);
      v27 = v26;
    }
    else if ( !strcmp(v6, "ldpc") && (v13 = (const char *)get_pvalue(v3, "ldpc")) != 0 )
    {
      v28 = strcmp(v13, "on") == 0;
    }
    else if ( !strcmp(v6, "channel_width") && (v14 = (const char *)get_pvalue(v3, "channel_width")) != 0 )
    {
      v25 = atoi(v14);
    }
    else if ( !strcmp(v6, (const char *)&unk_61F57) )
    {
      v15 = (const char *)get_pvalue(v3, &unk_61F57);
      if ( v15 )
      {
        v30 = atoi(v15);
        if ( v30 )
        {
          v19 = 0;
          v20 = 0;
          if ( get_intvalue(v3, "dcs_period_hour", &v31) )
            v31 *= 60;
        }
      }
    }
    set_wireless_conf(&v17, &v32);
    write_wireless_conf(&v17, &v32);
    v16 = signal_start("fwsched");
    result = (const char *)signal_save(v16);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1037C: using guessed type int __fastcall set_wireless_conf(_DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11ABC: using guessed type int __fastcall write_wireless_conf(_DWORD, _DWORD);

//----- (000263E8) --------------------------------------------------------
void *__fastcall sub_263E8(int a1)
{
  if ( *(_DWORD *)(a1 + 924) )
    snprintf((char *)&unk_916D8, 0x20u, "%d MHz");
  else
    snprintf((char *)&unk_916D8, 0x20u, "자동");
  return &unk_916D8;
}

//----- (00026430) --------------------------------------------------------
void *__fastcall sub_26430(int a1)
{
  snprintf((char *)&unk_916F8, 0x20u, "%d %%", a1);
  return &unk_916F8;
}

//----- (0002645C) --------------------------------------------------------
void *__fastcall sub_2645C(int a1, int a2)
{
  snprintf((char *)&unk_91718, 0x40u, "%d %s", a1, a2, a2);
  return &unk_91718;
}

//----- (0002648C) --------------------------------------------------------
int __fastcall sub_2648C(int a1)
{
  int v1; // r4@1
  int v2; // r5@1
  int result; // r0@2
  int v4; // r1@3
  void *v5; // r0@6
  const char *v6; // r0@6
  int v7; // r1@6
  int v8; // r2@6
  int v9; // r3@6
  void *v10; // r0@6
  void *v11; // r0@6
  const char *v12; // r2@7
  void *v13; // r0@9
  const char *v14; // r2@10
  void *v15; // r0@12
  void *v16; // r0@12
  void *v17; // r0@12
  signed int i; // r3@12
  char *v19; // r1@15
  int v20; // r4@17
  int v21; // [sp+0h] [bp-5C0h]@6
  int v22; // [sp+84h] [bp-53Ch]@6
  int v23; // [sp+1A8h] [bp-418h]@9
  int v24; // [sp+1B4h] [bp-40Ch]@12
  int v25; // [sp+1B8h] [bp-408h]@12
  int v26; // [sp+1C4h] [bp-3FCh]@12
  int v27; // [sp+3B0h] [bp-210h]@9
  int v28; // [sp+3B8h] [bp-208h]@6
  char s1; // [sp+3CCh] [bp-1F4h]@6
  char dest; // [sp+570h] [bp-50h]@4

  v1 = a1;
  v2 = get_pvalue(a1, "ifname");
  if ( v2 )
  {
    v4 = get_pvalue(v1, "act");
    if ( v4 )
      sf_strncpy(&dest, v4, 64);
    else
      strcpy(&dest, "mode");
    read_wireless_conf(&v21, v2);
    printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
    printf("<form method=get action=\"timepro.cgi\" name=\"main_form\">");
    printf("<input type=hidden name=tmenu value=ifname>");
    printf("<input type=hidden name=\"smenu\" value=\"wl_advanced\">");
    printf("<input type=hidden name=\"ifname\" value=\"%s\">", v2);
    printf("<input type=hidden name=\"click_id\" value=>");
    printf("<input type=hidden name=\"click_bg\" value=>");
    printf("<table style=\"border-collapse:collapse; border-style:none none none none; width:100%%;\" cellspacing=0px cellpadding=0px>\n");
    printf("<COL WIDTH=9><COL WIDTH=200><COL>");
    v5 = sub_15410(v22);
    sub_26080((int)"mode", (int)"모드", (int)v5);
    v6 = sub_1497C(&s1);
    sub_26080((int)"country", (int)"지역 ", (int)v6);
    v10 = sub_1551C((int)&v21, v7, v8, v9);
    sub_26080((int)&unk_61F57, (int)"동적 채널 변경", (int)v10);
    v11 = sub_263E8((int)&v21);
    sub_26080((int)"channel_width", (int)"채널 크기", (int)v11);
    if ( v28 )
      v12 = "동작중";
    else
      v12 = "중단됨";
    sub_26080((int)"ldpc", (int)"LDPC", (int)v12);
    v13 = sub_26430(v23);
    sub_26080((int)"tx_power", (int)"송신 파워", (int)v13);
    if ( v27 )
      v14 = "동작중";
    else
      v14 = "중단됨";
    sub_26080((int)"wmm", (int)"WMM 기능", (int)v14);
    v15 = sub_2645C(v24, (int)"bytes");
    sub_26080((int)"rts", (int)"RTS Threshold", (int)v15);
    v16 = sub_2645C(v25, (int)"bytes");
    sub_26080((int)"frag", (int)"Fragmentation Threshold", (int)v16);
    v17 = sub_2645C(v26, (int)"ms");
    sub_26080((int)"beacon_interval", (int)"Beacon주기", (int)v17);
    for ( i = 10; ; i = v20 )
    {
      v19 = i & 1 ? "f7f7f7" : "ffffff";
      v20 = i + 1;
      printf("<TR height=20 STYLE=\"cursor:pointer; background-Color:#%s\">", v19);
      printf("<TD></TD><TD></TD><TD CLASS=text_gray></TD></TR>");
      if ( v20 == 15 )
        break;
    }
    printf("</table>");
    printf("</BODY>");
    result = printf("<script> ClickTr(document.getElementById('%s')); </script>", &dest);
  }
  else
  {
    result = printf("Error");
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00026778) --------------------------------------------------------
int __fastcall sub_26778(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  bool v5; // zf@2
  int v6; // r0@2
  const char *v7; // r0@3

  v3 = a2;
  v4 = a3;
  puts("<select name=mode>");
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      v7 = "<option value=\"%d\" %s>%s\n";
      *(_DWORD *)(v4 + 132);
      goto LABEL_6;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v4 + 132) == 6;
    printf("<option value=\"%d\" %s>%s\n");
    *(_DWORD *)(v4 + 132);
    printf("<option value=%d %s>%s\n");
    *(_DWORD *)(v4 + 132);
    v6 = printf("<option value=\"%d\" %s>%s\n");
    if ( wireless_api_support_onlyb(v6) )
    {
      v7 = "<option value=\"%d\" %s>%s\n";
      *(_DWORD *)(v4 + 132);
LABEL_6:
      printf(v7);
      return printf("</select>");
    }
  }
  return printf("</select>");
}
// 11C84: using guessed type int __fastcall wireless_api_support_onlyb(_DWORD);

//----- (0002688C) --------------------------------------------------------
int __fastcall sub_2688C(int a1, int a2, int a3)
{
  int v3; // r4@1

  v3 = a3;
  printf("<select name=country>");
  sub_149CC(v3 + 972);
  return puts("</select>");
}

//----- (000268B8) --------------------------------------------------------
int __fastcall sub_268B8(int a1, int a2, int a3)
{
  char *v3; // r1@1
  int v4; // r4@1
  bool v5; // zf@1
  int v6; // r0@5
  char *v7; // r1@6

  v3 = *(char **)(a3 + 1212);
  v4 = a3;
  v5 = v3 == 0;
  if ( !v3 )
    v3 = "";
  if ( !v5 )
    v3 = "checked";
  printf("<input type=radio name=dynamic_channel value=1 %s onclick=\"ChangeWLParams2();\"> %s", v3, "실행");
  printf(" - %s :", "채널 검색 주기");
  v6 = sub_4EC48(*(_DWORD *)(v4 + 1216), 60);
  printf("<input type=text name=dcs_period_hour value=%d maxlength=3 size=3> %s <br>", v6, "시간");
  if ( *(_DWORD *)(v4 + 1212) )
    v7 = "";
  else
    v7 = "checked";
  printf("<input type=radio name=dynamic_channel value=0 %s onclick=\"ChangeWLParams2();\"> %s", v7, "중단");
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "주기적으로 무선 상황을 검사하여 자동으로 최적의 채널을 찾아 설정하는 기능입니다.");
}

//----- (00026968) --------------------------------------------------------
int __fastcall sub_26968(int a1, int a2, int a3)
{
  int v3; // r4@1
  char *v4; // r1@3
  int v5; // r0@5
  char *v6; // r1@7
  int v7; // r0@9
  char *v8; // r1@10
  int v9; // r0@12
  char *v10; // r1@13

  v3 = a3;
  if ( a2 == 1 )
  {
    if ( *(_DWORD *)(a3 + 924) == 80 )
      v4 = "checked";
    else
      v4 = "";
    v5 = printf(
           "<input type=radio name=channel_width value=80 %s> 80 MHz <span class=gray_text>- 80/40/20MHz - 11ac</span>",
           v4,
           "");
    br(v5);
  }
  if ( *(_DWORD *)(v3 + 924) == 40 )
    v6 = "checked";
  else
    v6 = "";
  v7 = printf(
         "<input type=radio name=channel_width value=40 %s> 40 MHz <span class=gray_text>- 40/20MHz - 11n</span>",
         v6);
  br(v7);
  if ( *(_DWORD *)(v3 + 924) == 20 )
    v8 = "checked";
  else
    v8 = "";
  v9 = printf("<input type=radio name=channel_width value=20 %s> 20 MHz", v8);
  br(v9);
  if ( *(_DWORD *)(v3 + 924) )
    v10 = "";
  else
    v10 = "checked";
  return printf(
           "<input type=radio name=channel_width value=0 %s> %s <span class=gray_text>-%s</span>",
           v10,
           "자동",
           "OBSS Coexistence");
}
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (00026A20) --------------------------------------------------------
int __fastcall sub_26A20(int a1, int a2, int a3)
{
  char *v3; // r1@1
  int v4; // r6@1
  bool v5; // zf@1
  char *v6; // r1@6

  v3 = *(char **)(a3 + 952);
  v4 = a3;
  v5 = v3 == 0;
  if ( !v3 )
    v3 = "";
  if ( !v5 )
    v3 = "checked";
  printf("<input type=radio name=ldpc value=on %s> 실행", v3);
  print_nbsp(5);
  if ( *(_DWORD *)(v4 + 952) )
    v6 = "";
  else
    v6 = "checked";
  printf("<input type=radio name=ldpc value=off %s> 중단", v6);
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "진보된 parity-check coding을 통하여 성능을 향상 시킬 수 있습니다.");
}
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (00026A90) --------------------------------------------------------
int __fastcall sub_26A90(int a1, int a2, int a3)
{
  printf("<input type=text name=tx_power size=3 maxlength=3 value=\"%d\" > %% ( 1 ~ 100 )", *(_DWORD *)(a3 + 424));
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "송신 파워를 조절하여 무선 전파가 전달되는 범위를 조절할 수 있습니다. <br>설정"
           "이 높을수록 무선 전파 전달 범위가 넓어집니다.");
}

//----- (00026ABC) --------------------------------------------------------
int __fastcall sub_26ABC(int a1, int a2, int a3)
{
  char *v3; // r1@1
  int v4; // r6@1
  bool v5; // zf@1
  int v6; // r0@5
  char *v7; // r1@6

  v3 = *(char **)(a3 + 944);
  v4 = a3;
  v5 = v3 == 0;
  if ( !v3 )
    v3 = "";
  if ( !v5 )
    v3 = "checked";
  v6 = printf("<input type=radio name=wmm value=1 %s> 사용함", v3);
  br(v6);
  if ( *(_DWORD *)(v4 + 944) )
    v7 = "";
  else
    v7 = "checked";
  return printf("<input type=radio name=wmm value=0 %s> 사용하지 않음", v7);
}
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (00026B14) --------------------------------------------------------
int __fastcall sub_26B14(int a1, int a2, int a3)
{
  printf("<input type=text name=rts size=4 maxlength=4 value=\"%d\"> bytes ", *(_DWORD *)(a3 + 436));
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "설정값 이상의 무선데이터 전송시 RTS/CTS방식으로 데이터를 전송합니다.<br> 작을 "
           "록 더욱 안정적인 무선통신을 보장하지만, 최대 속도는 감소합니다.<br> 설정가능"
           " 값은 1 ~ 2347 입니다.");
}

//----- (00026B40) --------------------------------------------------------
int __fastcall sub_26B40(int a1, int a2, int a3)
{
  printf("<input type=text name=frag size=4 maxlength=4 value=\"%d\"> bytes ", *(_DWORD *)(a3 + 440));
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "설정값 이상의 무선데이터 전송시 설정된 크기로 데이터를 나누어 전송합니다.<br>"
           " 이값을 작게할수록 더욱 안정적인 무선 통신을 보장하지만, 최대 속도는 감소합"
           "다.<br> 설정가능한 값은 256 ~ 2346 입니다.");
}

//----- (00026B6C) --------------------------------------------------------
int __fastcall sub_26B6C(int a1, int a2, int a3)
{
  printf("<input type=text name=beacon size=4 maxlength=4 value=\"%d\"> ms ", *(_DWORD *)(a3 + 452));
  return printf(
           "<br><br><span class=gray_text>%s</span>",
           "Beacon이 전송되는 주기를 조절할 수 있습니다.  일반적으로 100ms를 사용합니다. <br>"
           "정할 수 있는 값의 범위는 50 ~ 1024 입니다.");
}

//----- (00026B98) --------------------------------------------------------
int __fastcall sub_26B98(const char *a1, int a2, int a3)
{
  int v3; // r5@1
  const char *v4; // r4@1
  int v5; // r6@1
  int result; // r0@2

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( !strcmp(a1, "mode") )
  {
    result = sub_26778((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "country") )
  {
    result = sub_2688C((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, (const char *)&unk_61F57) )
  {
    result = sub_268B8((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "channel_width") )
  {
    result = sub_26968((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "ldpc") )
  {
    result = sub_26A20((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "tx_power") )
  {
    result = sub_26A90((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "wmm") )
  {
    result = sub_26ABC((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "rts") )
  {
    result = sub_26B14((int)v4, v3, v5);
  }
  else if ( !strcmp(v4, "frag") )
  {
    result = sub_26B40((int)v4, v3, v5);
  }
  else
  {
    result = strcmp(v4, "beacon_interval");
    if ( !result )
      result = sub_26B6C((int)v4, v3, v5);
  }
  return result;
}

//----- (00026D5C) --------------------------------------------------------
int __fastcall sub_26D5C(const char *a1, int a2, int a3, int a4)
{
  const char *v4; // r4@1
  int v5; // r5@1
  int v6; // r6@1
  int v7; // r7@1

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%% ID=%s_table STYLE=\"display:none;\">", a1);
  printf("<tr><td height=20 valign=center style=\"padding:3px;\">&nbsp; %s</td></tr>", v5);
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td></td></tr>");
  printf("<tr><td valign=top style=\"padding:5px\" >");
  sub_26B98(v4, v6, v7);
  return printf((const char *)&unk_5C75F);
}

//----- (00026DC8) --------------------------------------------------------
int __fastcall sub_26DC8(int a1, int a2, int a3)
{
  int v3; // r6@1
  int v4; // r4@1
  int v5; // r0@3
  int v6; // r0@6
  int v7; // r7@6
  int v8; // r3@6
  int v9; // r0@8
  const char *v10; // r0@9
  char v12; // [sp+4h] [bp-694h]@3
  int v13; // [sp+574h] [bp-124h]@6
  int v14; // [sp+674h] [bp-24h]@1
  int v15; // [sp+67Ch] [bp-1Ch]@1

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  if ( !get_active_wl(v4, &v14, &v15) )
    printf("Debug it..!!");
  v5 = read_wireless_conf(&v12, &v14);
  if ( sysget_ui_version(v5) == 1 )
    printf("<table width=100%% cellspacing=0px cellpadding=0px>\n");
  else
    puts("<table style=\"border-collapse:collapse; border-style:none solid solid solid; border-width:0px 1px 1px 1px; border-color:#eeeeee; width:642;\" cellspacing=0px cellpadding=0px>");
  printf("<form method=get action=\"timepro.cgi\" name=\"wireless_params_fm\">");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=\"smenu\" value=\"advancesetup\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  v6 = printf("<input type=hidden name=wl_mode value=%d>", v4);
  str(v6);
  printf("<td width=100%% height=300>");
  v7 = snprintf((char *)&v13, 0x80u, "timepro.cgi?tmenu=iframe&smenu=wl_advanced&ifname=%s", &v14);
  v8 = get_pvalue(v3, "act");
  if ( v8 )
    snprintf((char *)&v13 + v7, 0x40u, "&act=%s", v8);
  printf(
    "<iframe name=\"wl_iframe\" src=\"%s\" frameborder=no width=100%% height=100%% align=left scrolling=yes></iframe>",
    &v13);
  v9 = printf("</td></tr>");
  if ( sysget_ui_version(v9) == 1 )
    v10 = (const char *)&unk_62D12;
  else
    v10 = "<tr height=205 style=\"background-Color:#eeeeee\"><td valign=top>";
  puts(v10);
  sub_26D5C("mode", (int)"모드", v4, (int)&v12);
  sub_26D5C("country", (int)"지역 ", v4, (int)&v12);
  sub_26D5C((const char *)&unk_61F57, (int)"동적 채널 변경", v4, (int)&v12);
  sub_26D5C("channel_width", (int)"채널 크기", v4, (int)&v12);
  sub_26D5C("ldpc", (int)"LDPC", v4, (int)&v12);
  sub_26D5C("tx_power", (int)"송신 파워", v4, (int)&v12);
  sub_26D5C("wmm", (int)"WMM 기능", v4, (int)&v12);
  sub_26D5C("rts", (int)"RTS Threshold", v4, (int)&v12);
  sub_26D5C("frag", (int)"Fragmentation Threshold", v4, (int)&v12);
  sub_26D5C("beacon_interval", (int)"Beacon주기", v4, (int)&v12);
  printf("</tr>");
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td></td></tr>");
  printf("<tr align=right valign=middle height=28 style=\"background-Color:#eeeeee\"><td>");
  printf("<input type=button name=params_bt value=\"%s\" onclick=\"ApplyWirelessParams2();\">", "적용");
  printf("</td></tr></form>");
  printf("</table>");
  return printf("<script> ChangeWLParams2();</script>");
}
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 11198: using guessed type int __fastcall sysget_ui_version(_DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00027104) --------------------------------------------------------
int __fastcall sub_27104(int a1)
{
  int v1; // r4@1
  int v2; // r1@1
  int v3; // r2@1
  int v4; // r6@1
  const char *v5; // r1@2
  const char *v6; // r1@5
  int v7; // r0@7
  char *v8; // r1@11
  char *v9; // r1@16
  void *v10; // r0@20
  int v11; // r0@20
  char *v12; // r2@21
  char *v13; // r2@24
  char *v14; // r2@29
  char *v15; // r2@33
  char *v16; // r2@37
  char *v17; // r2@41
  char *v18; // r2@45
  char *v19; // r2@49
  char *v20; // r2@53
  char *v21; // r2@57
  char *v22; // r2@61
  char *v23; // r2@66
  char *v24; // r2@71
  int v25; // r0@75
  char *v26; // r1@76
  char *v27; // r1@79
  char *v28; // r1@82
  char *v29; // r1@85
  char *v30; // r1@88
  int v31; // r5@90
  int v32; // r4@90
  int v33; // r0@91
  int v34; // r0@92
  int v36; // [sp+0h] [bp-C28h]@7
  char v37[132]; // [sp+570h] [bp-6B8h]@4
  int v38; // [sp+5F4h] [bp-634h]@4
  int v39; // [sp+740h] [bp-4E8h]@10
  int v40; // [sp+744h] [bp-4E4h]@20
  int v41; // [sp+7C4h] [bp-464h]@20
  int v42; // [sp+7D8h] [bp-450h]@23
  int v43; // [sp+7DCh] [bp-44Ch]@20
  unsigned int v44; // [sp+7E0h] [bp-448h]@78
  int v45; // [sp+854h] [bp-3D4h]@75
  int v46; // [sp+8C0h] [bp-368h]@12
  int v47; // [sp+90Ch] [bp-31Ch]@4
  int v48; // [sp+93Ch] [bp-2ECh]@4
  char v49; // [sp+AE0h] [bp-148h]@7
  char v50; // [sp+BE0h] [bp-48h]@7
  char v51; // [sp+C00h] [bp-28h]@4

  v1 = a1;
  print_file("/home/httpd/js/wirelessconf2.js");
  v4 = sub_14FF4(v1, v2, v3);
  if ( v4 == 1 )
    v5 = "eth1";
  else
    v5 = "eth2";
  sf_strncpy(&v51, v5, 16);
  read_wireless_conf(v37, &v51);
  sub_14B34(&v51);
  printf("<form method=get action=timepro.cgi name=mbridge_fm>");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=smenu value=multibridge>");
  printf("<input type=hidden name=act value=>");
  printf("<input type=hidden name=wl_mode value=%d>", v4);
  printf("<input type=hidden name=mode value=%d>", v38);
  printf("<input type=hidden name=country value=%s>", &v48);
  printf("<input type=hidden name=channel_width value=%d>", v47);
  if ( !strcmp(&v51, "eth1") )
    v6 = "eth2";
  else
    v6 = "eth1";
  sf_strncpy(&v50, v6, 32);
  read_wireless_conf(&v36, &v50);
  printf("<input type=hidden name=other_wwan_enable value=%d>");
  puts("<table class=v3_table>");
  printf("<tr><td style=\"background-color:#ffffff;\" height=225>");
  v7 = snprintf(&v49, 0x80u, "timepro.cgi?tmenu=iframe&smenu=ap_list&ifname=%s", &v51);
  if ( is_mobile_agent(v7) )
  {
    printf("<div style=\"height:225px; width:100%%; -webkit-overflow-scrolling: touch; overflow-y:scroll; overflow-x:hidden; display:inline-block;\">");
    printf(
      "<iframe name=\"iframe_aplist\" src=\"%s\" frameborder=no width=100%% height=225 align=left scrolling=yes></iframe>",
      &v49);
    printf("</div>");
  }
  else
  {
    printf(
      "<iframe name=\"iframe_aplist\" src=\"%s\" frameborder=no width=100%% height=225 align=left scrolling=yes></iframe>",
      &v49);
  }
  printf("</td></tr>");
  printf("<tr height=20px style=\"background-color:#eeeeee\"><td align=left style=\"padding:0 0 0 5;\"><b><span id=ssid_title></span></b></td></tr>");
  printf("<tr height=1px style=\"background-color:#dddddd\"><td></td></tr>");
  printf("<tr height=231 valign=top><td>");
  printf("<table width=100%% style=\"background-color:#eeeeee; border-collapse:collapse;\">\n");
  printf("<COL width=25%%><COL width=27%%><COL width=48%%>");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "동작 설정");
  printf("<td colspan=2>");
  if ( v39 )
  {
    if ( v46 )
      v8 = "";
    else
      v8 = "checked";
  }
  else
  {
    v8 = "";
  }
  printf(
    "<input type=radio name=run value=bridge onclick=\"SetWirelessForm(document,document.mbridge_fm);\" %s>%s ",
    v8,
    "무선 브리지");
  if ( v39 )
  {
    if ( v46 )
      v9 = "checked";
    else
      v9 = "";
  }
  else
  {
    v9 = "";
  }
  printf(
    "<input type=radio name=run value=wan onclick=\"SetWirelessForm(document,document.mbridge_fm);\" style=\"margin-left:50px;\" %s>%s",
    v9,
    "무선 WAN");
  printf("<input style=\"margin-left:50px;\" type=radio name=run value=0 onclick=\"SetWirelessForm(document,document.mbridge_fm);\" %s > %s");
  printf("</td>");
  printf("</tr>");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "네트워크이름(SSID)");
  printf("<td colspan=2>");
  v10 = sub_15F34((const char *)&v40);
  printf("<input type=text name=ssid maxlength=32 size=32 value='%s'>\n", v10);
  printf("<input type=hidden name=bssid value=\"%s\">\n", &v41);
  v11 = printf("</td>");
  etr(v11);
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "인증 및 암호화");
  printf("<td>");
  puts("<select name=personal_list style=\"width:205px;\" onchange=\"SetWirelessForm(document,document.mbridge_fm);\">");
  if ( v43 )
    v12 = "";
  else
    v12 = "selected";
  printf("<option value=\"%s\" %s>%s \n", "nouse", v12, "암호화 사용하지 않음");
  if ( v42 == 9 )
  {
    if ( v43 == 4 )
      v13 = "selected";
    else
      v13 = "";
  }
  else
  {
    v13 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", "wpa2psk_aes", v13, "WPA2PSK + AES");
  if ( v42 == 10 )
  {
    v14 = "selected";
    if ( v43 != 4 )
      v14 = "";
  }
  else
  {
    v14 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5E950, v14, &unk_5E962);
  if ( v42 == 5 )
  {
    v15 = "selected";
    if ( v43 != 4 )
      v15 = "";
  }
  else
  {
    v15 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_aes", v15, "WPAPSK + AES");
  if ( v42 == 9 )
  {
    v16 = "selected";
    if ( v43 != 5 )
      v16 = "";
  }
  else
  {
    v16 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", "wpa2psk_tkipaes", v16, "WPA2PSK + TKIP/AES");
  if ( v42 == 10 )
  {
    v17 = "selected";
    if ( v43 != 5 )
      v17 = "";
  }
  else
  {
    v17 = "";
  }
  printf("<option value=\"%s\" %s>%s \n", &unk_5E98F, v17, &unk_5E9A5);
  if ( v42 == 5 )
  {
    v18 = "selected";
    if ( v43 != 5 )
      v18 = "";
  }
  else
  {
    v18 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_tkipaes", v18, "WPAPSK + TKIP/AES");
  if ( v42 == 5 )
  {
    v19 = "selected";
    if ( v43 != 3 )
      v19 = "";
  }
  else
  {
    v19 = "";
  }
  printf("<option value=\"%s\" %s>%s", "wpapsk_tkip", v19, "WPAPSK + TKIP");
  if ( v42 == 9 )
  {
    v20 = "selected";
    if ( v43 != 3 )
      v20 = "";
  }
  else
  {
    v20 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5EA00, v20, &unk_5EA14);
  if ( v42 == 10 )
  {
    v21 = "selected";
    if ( v43 != 3 )
      v21 = "";
  }
  else
  {
    v21 = "";
  }
  printf("<option value=\"%s\" %s>%s", &unk_5E9FA, v21, &unk_5EA0D);
  if ( v42 == 3 )
  {
    if ( (unsigned int)(v43 - 1) > 1 )
      v22 = "";
    else
      v22 = "selected";
  }
  else
  {
    v22 = "";
  }
  printf("<option value=\"%s\" %s>%s", "auto_wep", v22, "자동 + WEP");
  if ( v42 == 1 )
  {
    if ( (unsigned int)(v43 - 1) > 1 )
      v23 = "";
    else
      v23 = "selected";
  }
  else
  {
    v23 = "";
  }
  printf("<option value=\"%s\" %s>%s", "open_wep", v23, "개방 모드 + WEP");
  if ( v42 == 2 )
  {
    if ( (unsigned int)(v43 - 1) > 1 )
      v24 = "";
    else
      v24 = "selected";
  }
  else
  {
    v24 = "";
  }
  printf("<option value=\"%s\" %s>%s", "key_wep", v24, "공유 모드 + WEP");
  puts("</select>");
  printf("</td><td>");
  v25 = printf("</td>");
  etr(v25);
  printf("<tr height=130 id=no_key><td></td></tr>");
  printf("<tr valign=top height=130 id=wpapsk_key><td style=\"padding-left:5px;\">%s</td>", "네트워크 암호");
  printf("<td>");
  printf(
    "<input type=password size=60 maxlength=64 name=wpapsk_key value='%s' style=\"width:205px;height:20px;ime-mode:disabled\">",
    &v45);
  printf(
    "<input type=text size=60 maxlength=64 name=wpapsk_key_text style=\"width:205px;height:20px;display:none;ime-mode:dis"
    "abled;\" value='%s'>",
    &v45);
  printf("</td><td>");
  printf(
    "<INPUT TYPE=checkbox NAME=wpapsk_password_view value=1 onclick=\"PasswordView(wpapsk_key,wpapsk_key_text,wpapsk_pass"
    "word_view);\" > %s",
    "암호보기");
  printf("</td>");
  printf("</tr>");
  printf(
    "<tr height=130 id=wep_key><td valign=top style=\"padding-left:5px; padding-top:40px;\">%s</td>",
    "네트워크 암호");
  printf("<td valign=top colspan=2>");
  printf("<table class=menu_content_list_noline_table>");
  printf("<COL width=\"30%%\"><COL width=\"70%%\">");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "WEP 암호 방식");
  printf("<td>");
  printf("<input type=radio name=wepkey_length value=5 %s onclick=\"SetWirelessForm(document,document.mbridge_fm);\"> %s");
  print_nbsp(5);
  if ( v43 == 2 )
    v26 = "checked";
  else
    v26 = "";
  printf(
    "<input type=radio name=wepkey_length value=13 %s onclick=\"SetWirelessForm(document,document.mbridge_fm);\"> %s",
    v26,
    "WEP128");
  printf("</td></tr>");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "암호 입력 방법");
  printf("<td>");
  printf("<input type=radio name=key_input value=%d %s onclick=\"SetWirelessForm(document,document.mbridge_fm);\"> %s");
  print_nbsp(5);
  printf("<input type=radio name=key_input value=%d %s onclick=\"SetWirelessForm(document,document.mbridge_fm);\"> %s");
  printf("</td></tr>");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "기본 암호 선택");
  printf("<td>");
  if ( v44 <= 1 )
    v27 = "checked";
  else
    v27 = "";
  printf("<input type=radio name=default_key value=1 %s> 1", v27);
  print_nbsp(5);
  if ( v44 == 2 )
    v28 = "checked";
  else
    v28 = "";
  printf("<input type=radio name=default_key value=2 %s> 2", v28);
  print_nbsp(5);
  if ( v44 == 3 )
    v29 = "checked";
  else
    v29 = "";
  printf("<input type=radio name=default_key value=3 %s> 3", v29);
  print_nbsp(5);
  if ( v44 == 4 )
    v30 = "checked";
  else
    v30 = "";
  printf("<input type=radio name=default_key value=4 %s> 4", v30);
  v31 = 0;
  printf("</td></tr>");
  v32 = 0;
  printf((const char *)&unk_63754, "암호 값을 입력하십시오");
  printf("</td>");
  printf("<td>");
  do
  {
    ++v32;
    v33 = printf(
            "%d : <input type=text name=wep_key%d value='%s' style=\"ime-mode:disabled\">",
            v32,
            v32,
            &v37[v31 + 632]);
    br(v33);
    v31 += 27;
  }
  while ( v32 != 4 );
  v34 = printf("</td>");
  etr(v34);
  printf("</table>");
  printf("</td>");
  printf("</tr>");
  printf("</table></td></tr>");
  printf(
    "<tr><td height=20 align=left style=\"padding-left:5px;\"><span class=gray_text>%s</span></td></tr>",
    "* 무선 WAN기능 사용 시, 유선WAN포트를 사용할 수 없습니다.");
  printf("<tr height=1px style=\"background-color:#dddddd\"><td></td></tr>");
  printf("<tr><td height=33px align=right>");
  printf("<input type=button class=navi_bt name=apply_bt value=\"적용\" onclick=\"ApplyMBridge(document.mbridge_fm,'apply')\">");
  printf("</td></tr>");
  puts("</form>");
  printf("</table>");
  puts("<script>");
  puts("SetWirelessForm(document,document.mbridge_fm);");
  return printf("</script>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 27104: using guessed type char var_6B8[132];

//----- (00027B0C) --------------------------------------------------------
int __fastcall sub_27B0C(int a1, int a2)
{
  int v2; // r6@1
  int v4; // [sp+0h] [bp-410h]@1
  char v5; // [sp+200h] [bp-210h]@1

  v2 = a2;
  sf_strncpy(&v5, a1, 512);
  sf_strncpy(&v4, v2, 512);
  strtoupper(&v5);
  strtoupper(&v4);
  return strcmp(&v5, (const char *)&v4);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);

//----- (00027B68) --------------------------------------------------------
int __fastcall sub_27B68(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r5@1
  const char *v5; // r1@1
  const char *v6; // r0@3
  const char *v7; // r6@3
  int v8; // r0@6
  int v9; // r6@12
  const char *v10; // r6@15
  int v11; // r1@17
  char *v12; // r0@18
  signed int v13; // r2@18
  int v14; // r1@21
  int v15; // r1@23
  int v16; // r1@25
  int v17; // r0@31
  int v18; // r0@31
  char v20; // [sp+4h] [bp-5A4h]@3
  int v21; // [sp+1D4h] [bp-3D4h]@5
  char v22; // [sp+1D8h] [bp-3D0h]@14
  char v23; // [sp+26Ch] [bp-33Ch]@16
  int v24; // [sp+270h] [bp-338h]@16
  char v25; // [sp+274h] [bp-334h]@21
  char v26; // [sp+278h] [bp-330h]@21
  char v27; // [sp+27Ch] [bp-32Ch]@22
  char v28; // [sp+297h] [bp-311h]@24
  __int16 v29; // [sp+2B2h] [bp-2F6h]@26
  _BYTE v30[3]; // [sp+2CDh] [bp-2DBh]@28
  char v31; // [sp+2E8h] [bp-2C0h]@18
  int v32; // [sp+354h] [bp-254h]@5
  int v33; // [sp+378h] [bp-230h]@30
  int v34; // [sp+574h] [bp-34h]@3
  int v35; // [sp+594h] [bp-14h]@12

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  v5 = "eth2";
  if ( v4 == 1 )
    v5 = "eth1";
  sf_strncpy(&v34, v5, 32);
  read_wireless_conf(&v20, &v34);
  v6 = (const char *)get_pvalue(v3, "run");
  v7 = v6;
  if ( !v6 )
    return 0;
  if ( strcmp(v6, "wan") )
  {
    v8 = strcmp(v7, "bridge");
    if ( v8 )
    {
      v8 = strcmp(v7, "0");
      if ( v8 )
        goto LABEL_11;
      v21 = 0;
    }
    else
    {
      v21 = 1;
    }
    v32 = v8;
    goto LABEL_11;
  }
  v21 = 1;
  v32 = 1;
  system((const char *)&unk_63959);
LABEL_11:
  if ( !v21 )
  {
LABEL_31:
    write_wireless_conf(&v20, &v34);
    wireless_api_apply_mbssid(v4);
    v17 = signal_start("fwsched");
    v18 = signal_update(v17);
    signal_save(v18);
    return 0;
  }
  v35 = 0;
  v9 = get_pvalue(v3, "ssid");
  if ( v9 )
  {
    if ( check_unpermitted_ssid_chars() )
      return 0;
    sf_strncpy(&v22, v9, 33);
  }
  v10 = (const char *)get_pvalue(v3, "personal_list");
  if ( v10 )
  {
    get_intvalue(v3, "wepkey_length", &v35);
    sub_159DC(v10, v35, (signed int *)&v23, &v24);
    if ( (unsigned int)(v24 - 3) > 2 )
    {
      if ( (unsigned int)(v24 - 1) > 1 )
        goto LABEL_30;
      get_intvalue(v3, "default_key", &v25);
      get_intvalue(v3, "key_input", &v26);
      v14 = get_pvalue(v3, "wep_key1");
      if ( v14 )
        sf_strncpy(&v27, v14, 27);
      v15 = get_pvalue(v3, "wep_key2");
      if ( v15 )
        sf_strncpy(&v28, v15, 27);
      v16 = get_pvalue(v3, "wep_key3");
      if ( v16 )
        sf_strncpy(&v29, v16, 27);
      v11 = get_pvalue(v3, "wep_key4");
      if ( !v11 )
        goto LABEL_30;
      v13 = 27;
      v12 = v30;
    }
    else
    {
      v11 = get_pvalue(v3, "wpapsk_key");
      if ( !v11 )
        return 0;
      v12 = &v31;
      v13 = 65;
    }
    sf_strncpy(v12, v11, v13);
LABEL_30:
    v33 = 1;
    goto LABEL_31;
  }
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11654: using guessed type int check_unpermitted_ssid_chars(void);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11A98: using guessed type int __fastcall wireless_api_apply_mbssid(_DWORD);
// 11ABC: using guessed type int __fastcall write_wireless_conf(_DWORD, _DWORD);

//----- (00027E14) --------------------------------------------------------
const char *__fastcall sub_27E14(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  int v3; // r1@2
  int v4; // r2@2

  v1 = a1;
  result = (const char *)get_pvalue(a1, "act");
  if ( result )
  {
    if ( !strcmp(result, "apply") )
      result = (const char *)sub_27B68(v1, v3, v4);
    else
      result = 0;
  }
  return result;
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00027E5C) --------------------------------------------------------
const char *__fastcall sub_27E5C(int a1)
{
  int v1; // r6@1
  int v2; // r1@1
  const char *result; // r0@2
  const char *v4; // r8@4
  int v5; // r5@4
  signed int v6; // r1@7
  const char *v7; // r6@10
  signed int v8; // r5@12
  signed int v9; // r4@14
  void *v10; // r0@20
  const char *v11; // r0@20
  const char *v12; // r0@21
  int v13; // r6@21
  void *v14; // r4@23
  int v15; // r5@27
  signed int v16; // r11@27
  int *v17; // r6@29
  int i; // r5@31
  int v19; // r5@36
  signed int v20; // r3@39
  signed int v21; // r10@43
  signed int v22; // r7@45
  char *v23; // r0@51
  const char *v24; // r1@51
  int v25; // r2@53
  void *v26; // r0@61
  void *v27; // r0@61
  char *v28; // r0@63
  int v29; // r1@63
  int v30; // r9@70
  int v31; // r8@73
  void *v32; // r0@76
  void *v33; // r0@77
  const char *v34; // r0@78
  bool v35; // zf@84
  const char *v36; // r0@92
  const char *v37; // r1@92
  const char *v38; // r1@95
  int v39; // r2@102
  void *v40; // r0@104
  void *v41; // r5@105
  int v42; // r7@105
  signed int v43; // r3@108
  char *v44; // r0@109
  const char *v45; // r1@109
  void *v46; // r0@113
  const char *v47; // r1@114
  void *v48; // r0@119
  void *v49; // r0@120
  int v50; // r3@120
  const char *v51; // r0@121
  bool v52; // zf@125
  int v53; // r2@135
  void *v54; // r0@137
  int v55; // r5@140
  const char *v56; // r1@142
  int v57; // [sp+14h] [bp-804h]@4
  int v58; // [sp+1E4h] [bp-634h]@14
  unsigned __int8 v59; // [sp+1E8h] [bp-630h]@27
  int v60; // [sp+27Ch] [bp-59Ch]@74
  int v61; // [sp+280h] [bp-598h]@71
  int v62; // [sp+284h] [bp-594h]@104
  int v63; // [sp+288h] [bp-590h]@104
  int v64; // [sp+28Ch] [bp-58Ch]@104
  char v65; // [sp+2A7h] [bp-571h]@104
  __int16 v66; // [sp+2C2h] [bp-556h]@104
  _BYTE v67[3]; // [sp+2DDh] [bp-53Bh]@104
  int v68; // [sp+2F8h] [bp-520h]@104
  int v69; // [sp+364h] [bp-4B4h]@94
  int v70; // [sp+368h] [bp-4B0h]@15
  char v71; // [sp+3E0h] [bp-438h]@23
  int v72; // [sp+584h] [bp-294h]@29
  int v73; // [sp+658h] [bp-1C0h]@15
  char v74; // [sp+72Ch] [bp-ECh]@61
  int v75; // [sp+76Ch] [bp-ACh]@146
  int v76; // [sp+770h] [bp-A8h]@146
  int v77; // [sp+774h] [bp-A4h]@146
  int v78; // [sp+778h] [bp-A0h]@146
  int v79; // [sp+77Ch] [bp-9Ch]@146
  int v80; // [sp+79Ch] [bp-7Ch]@146
  char v81; // [sp+7A0h] [bp-78h]@3
  char v82; // [sp+7C0h] [bp-58h]@3
  char dest; // [sp+7E0h] [bp-38h]@51

  v1 = a1;
  v2 = get_pvalue(a1, "ifname");
  if ( !v2 )
    return (const char *)printf((const char *)&unk_639AE, 0);
  sf_strncpy(&v82, v2, 32);
  sf_strncpy(&v81, &v82, 32);
  result = sub_27E14(v1);
  if ( !result )
  {
    v4 = (const char *)get_pvalue(v1, "act");
    v5 = strcmp(&v82, "eth1");
    read_wireless_conf(&v57, &v82);
    print_file("/home/httpd/js/wirelessconf2.js");
    printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
    if ( v4 )
    {
      if ( !strcmp(v4, "apply") )
      {
        if ( !strcmp(&v82, "eth1") )
          v6 = 25;
        else
          v6 = 20;
        result = (const char *)printf(
                                 "<meta http-equiv=refresh content=\"%d; URL=timepro.cgi?tmenu=iframe&smenu=ap_list&ifnam"
                                 "e=%s&act=scan\">",
                                 v6,
                                 &v82);
      }
      else
      {
        result = (const char *)strcmp(v4, "scan");
        v7 = result;
        if ( !result )
        {
          if ( !strcmp(&v82, "eth1") )
            v8 = 15;
          else
            v8 = 6;
          printf("<table class=\"v3_iframe_table\">");
          v9 = v58;
          if ( v58 )
          {
            if ( wireless_api_get_mbridge_status(&v70, &v73) )
            {
              v9 = (signed int)v7;
            }
            else
            {
              v9 = 1;
              wireless_api_enable_bss(&v81, 0);
            }
          }
          if ( get_ifstatus(&v81) )
            wireless_api_start_ap_scan(&v81);
          v10 = sub_16094();
          printf(
            "<tr height=224><td width=230 align=right valign=center><img src=\"/%s/apply_ani.gif\"></td><td style=\"paddi"
            "ng:3 0 0 2;\" align=left>%s</td></tr>",
            v10,
            "주변의 무선 네트워크를 검색중입니다.");
          printf("</table>");
          printf(
            "<meta http-equiv=refresh content=\"%d; URL=timepro.cgi?tmenu=iframe&smenu=ap_list&ifname=%s&apply_bss=%d\">",
            v8,
            &v82,
            v9);
          puts("<script>");
          puts("DisableAllObj(parent.document.mbridge_fm);");
          v11 = "UnMaskIt(parent.document,'apply_mask');";
          goto LABEL_151;
        }
      }
      return result;
    }
    v12 = (const char *)get_pvalue(v1, "apply_bss");
    v13 = (int)v12;
    if ( v12 )
      v13 = atoi(v12);
    v14 = malloc(0x3530u);
    memset(v14, 0, 0x3530u);
    sf_strncpy((char *)v14 + 8, &v81, 32);
    sf_strncpy((char *)v14 + 40, &v71, 8);
    if ( get_ifstatus(&v81) )
      wireless_api_get_ap_list(v14);
    wireless_api_stop_ap_scan(&v81);
    if ( v13 )
      wireless_api_enable_bss(&v81, 1);
    qsort((char *)v14 + 48, *(_DWORD *)v14, 0xD4u, (__compar_fn_t)sub_27B0C);
    printf("<table class=\"v3_iframe_table\">");
    v15 = v5 == 0;
    printf("<COL WIDTH=7%%><COL WIDTH=53%%><COL WIDTH=25%%><COL WIDTH=15%%>");
    printf("<form method=get action=timepro.cgi name=mbridge_apply_fm>");
    printf("<input type=hidden name=tmenu value=iframe>");
    printf("<input type=hidden name=smenu value=ap_list>");
    printf("<input type=hidden name=ifname value=\"%s\">", &v82);
    printf("<input type=hidden name=act value=>");
    printf("<input type=hidden name=wl_mode value=%d>", v15);
    printf("<input type=hidden name=run>");
    printf("<input type=hidden name=ssid>");
    printf("<input type=hidden name=personal_list>");
    printf("<input type=hidden name=wep_key1>");
    printf("<input type=hidden name=wep_key2>");
    printf("<input type=hidden name=wep_key3>");
    printf("<input type=hidden name=wep_key4>");
    printf("<input type=hidden name=wepkey_length>");
    printf("<input type=hidden name=wpapsk_key>");
    printf("<input type=hidden name=default_key>");
    printf("<input type=hidden name=key_input>");
    printf("</form>");
    printf("<form method=get action=timepro.cgi name=ap_list_fm>");
    printf("<input type=hidden name=tmenu value=iframe>");
    printf("<input type=hidden name=smenu value=ap_list>");
    printf("<input type=hidden name=ifname value=\"%s\">", &v82);
    printf("<input type=hidden name=act value=>");
    printf("<input type=hidden name=wl_mode value=%d>", v15);
    v16 = v59;
    if ( !v59 )
      goto LABEL_105;
    if ( !get_ifstatus(&v70) || (v17 = &v72, !wireless_api_get_mbridge_status(&v70, &v72)) )
      v17 = 0;
    for ( i = 0; i < *(_DWORD *)v14; ++i )
    {
      if ( !strcmp((const char *)v14 + 212 * i + 48, (const char *)&v59) )
        goto LABEL_37;
    }
    if ( i == *(_DWORD *)v14 )
      v19 = 0;
    else
LABEL_37:
      v19 = (int)v14 + 212 * i + 48;
    printf("<TR height=%d ID=ap_row_%d STYLE=\"cursor:pointer; background-color:#%s\" ONCLICK=\"ClickAP(%d,0);\">", 45);
    if ( v17 )
    {
      v20 = v17[47];
    }
    else if ( v19 )
    {
      v20 = *(_DWORD *)(v19 + 188);
    }
    else
    {
      v20 = 0;
    }
    v21 = (signed int)v17;
    if ( v17 )
      v21 = 1;
    v22 = v19;
    if ( v19 )
      v22 = 1;
    if ( v22 & v21 && !v17[47] )
    {
      v20 = *(_DWORD *)(v19 + 188);
      v17[47] = v20;
    }
    if ( v22 | v21 )
    {
      if ( v20 )
        v25 = 0;
      else
        v25 = v21 & 1;
      if ( v25 || v20 > 75 )
      {
        v23 = &dest;
        v24 = "on";
      }
      else
      {
        v23 = &dest;
        if ( v20 <= 50 )
          v24 = "on_1";
        else
          v24 = "on_2";
      }
    }
    else
    {
      v23 = &dest;
      v24 = "off";
    }
    strcpy(v23, v24);
    v26 = sub_16094();
    printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_%s.png\"></TD>", v26, &dest);
    printf("<TD valign=top style=\"padding-top:5px;\">");
    v27 = sub_15F34((const char *)&v59);
    printf("<b>%s</b>", v27);
    strcpy(&v74, "");
    if ( v21 && v58 )
    {
      v28 = &v74;
      v29 = (int)(v17 + 32);
    }
    else
    {
      if ( !v22 )
        goto LABEL_67;
      v29 = v19 + 128;
      v28 = &v74;
    }
    sf_strncpy(v28, v29, 32);
LABEL_67:
    print_nbsp(3);
    if ( v74 )
    {
      convert_mac(&v74);
      printf("<span class=gray_text>(%s)</span>", &v74);
    }
    if ( v22 )
      v30 = *(_DWORD *)(v19 + 204);
    else
      v30 = v61;
    if ( v22 )
      v31 = *(_DWORD *)(v19 + 208);
    else
      v31 = v60;
    if ( !v30 )
    {
      printf("<span style=\"line-height:200%%\" class=gray_text>");
      v32 = sub_160D0();
      printf("<br><img src=\"%s\"> %s", v32, "보안 사용하지 않음");
      goto LABEL_91;
    }
    printf("<br><span class=gray_text>");
    v33 = sub_160D0();
    printf("<img style=\"margin-top:5px;\" src=\"%s\" border=0> %s ", v33, "보안 사용");
    if ( (unsigned int)(v31 - 9) > 1 )
    {
      if ( v31 == 5 )
      {
        v34 = "(WPA)";
      }
      else if ( (unsigned int)(v30 - 1) > 1 )
      {
        v35 = v31 == 8;
        if ( v31 != 8 )
          v35 = v31 == 11;
        if ( v35 )
        {
          v34 = "(WPA2-Enterprise)";
        }
        else
        {
          if ( v31 != 4 )
          {
            printf("(%s)", "Unknown");
LABEL_91:
            printf("</span>");
            printf("</TD>");
            if ( v58 )
            {
              if ( v21 )
              {
                if ( v69 )
                  v38 = "무선 WAN으로 연결됨";
                else
                  v38 = (const char *)&unk_63990;
                printf((const char *)&unk_63EBA, v38, &unk_63990);
                printf("<TD align=right style=\"padding-right:5px;\">");
                printf("<span class=gray_text>");
                printf("채널%2d<br>", v17[42]);
                if ( v17[47] )
                  printf("%d %%");
                goto LABEL_104;
              }
              v36 = "<TD><span class=gray_text>%s</span>";
              v37 = "무선 연결 실패";
            }
            else
            {
              v36 = "<TD><span class=gray_text>%s</span>";
              v37 = "중단됨";
            }
            printf(v36, v37);
            printf("</TD>");
            printf("<TD align=right style=\"padding-right:5px;\">");
            printf("<span class=gray_text>");
            if ( v22 && *(_DWORD *)(v19 + 168) )
            {
              v39 = *(_DWORD *)(v19 + 188);
              printf((const char *)&unk_63EA7);
            }
            else
            {
              printf("검색되지않음");
            }
LABEL_104:
            printf("</span>");
            printf("</TD></TR>");
            v40 = sub_15F34((const char *)&v59);
            printf("<input type=hidden name=m_ssid value='%s'>", v40);
            v16 = 1;
            sub_15C10(v60, v61, &v74);
            printf("<input type=hidden name=m_personal_list value='%s'>", &v74);
            printf("<input type=hidden name=m_wepkey1 value='%s'>", &v64);
            printf("<input type=hidden name=m_wepkey2 value='%s'>", &v65);
            printf("<input type=hidden name=m_wepkey3 value='%s'>", &v66);
            printf("<input type=hidden name=m_wepkey4 value='%s'>", v67);
            printf("<input type=hidden name=m_wpapsk value='%s'>", &v68);
            printf("<input type=hidden name=m_default_key value=%d>", v62);
            printf("<input type=hidden name=m_key_type value=%d>", v63);
LABEL_105:
            v41 = v14;
            v42 = 0;
            while ( 1 )
            {
              if ( v42 >= *(_DWORD *)v14 )
              {
                v55 = 0;
                while ( v55 < 4 - v16 )
                {
                  if ( ((_BYTE)v55 + (_BYTE)v16) & 1 )
                    v56 = "f7f7f7";
                  else
                    v56 = "ffffff";
                  ++v55;
                  printf("<TR height=45 STYLE=\"cursor:pointer; background-color:#%s\">", v56);
                  printf("<TD colspan=%d></TD></TR>", 4);
                }
                printf("</TABLE>");
                printf("</form>");
                memset(&v75, 0, 0x34u);
                v75 = 65;
                v76 = 93;
                v77 = 500;
                v78 = 40;
                strcpy((char *)&v79, (const char *)&unk_640C8);
                v80 = 100;
                sub_15E70(
                  (int)"apscan_guide_mask",
                  (int)"<span class=\"gray_text\">우측 상단의 [AP 검색] 버튼을 누르면, 연결할 AP를 검"
                       "할 수 있습니다.</span>",
                  (int)&v75);
                puts("<script>");
                if ( v59 )
                {
                  printf("ClickAP(0,0);");
                }
                else
                {
                  puts("InitMBridge();");
                  if ( !*(_DWORD *)v14 )
                    puts("MaskIt(document,'apscan_guide_mask');");
                }
                v11 = "SetWirelessForm(parent.document, parent.document.mbridge_fm);";
LABEL_151:
                printf(v11);
                return (const char *)puts("</script>");
              }
              if ( *((_BYTE *)v41 + 48) && strcmp((const char *)v14 + 212 * v42 + 48, (const char *)&v59) )
                break;
LABEL_138:
              ++v42;
              v41 = (char *)v41 + 212;
            }
            printf(
              "<TR height=%d ID=ap_row_%d STYLE=\"cursor:pointer; background-color:#%s\" ONCLICK=\"ClickAP(%d,0);\">",
              45,
              v16);
            v43 = *((_DWORD *)v41 + 59);
            if ( v43 <= 75 )
            {
              if ( v43 <= 50 )
              {
                v45 = "on_1";
                v44 = &dest;
              }
              else
              {
                v45 = "on_2";
                v44 = &dest;
              }
            }
            else
            {
              v44 = &dest;
              v45 = "on";
            }
            strcpy(v44, v45);
            v46 = sub_16094();
            printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_%s.png\"></TD>", v46, &dest);
            printf("<TD valign=top style=\"padding-top:5px;\">");
            if ( *((_BYTE *)v41 + 48) )
              v47 = (const char *)sub_15F34((const char *)v14 + 212 * v42 + 48);
            else
              v47 = "공개되지않은 무선 네트워크";
            printf("%s", v47);
            sf_strncpy(&v74, (char *)v14 + 212 * v42 + 176, 32);
            convert_mac(&v74);
            print_nbsp(3);
            if ( v74 )
              printf("<span class=gray_text>(%s)</span>", &v74);
            if ( *((_DWORD *)v41 + 63) )
            {
              printf("<br><span class=gray_text>");
              v49 = sub_160D0();
              printf("<img style=\"margin-top:5px;\" src=\"%s\" border=0> %s ", v49, "보안 사용");
              v50 = *((_DWORD *)v41 + 64);
              if ( (unsigned int)(v50 - 9) > 1 )
              {
                if ( v50 == 5 )
                {
                  v51 = "(WPA)";
                }
                else
                {
                  v52 = v50 == 8;
                  if ( v50 != 8 )
                    v52 = v50 == 11;
                  if ( v52 )
                  {
                    v51 = "(WPA2-Enterprise)";
                  }
                  else if ( v50 == 4 )
                  {
                    v51 = "(WPA-Enterprise)";
                  }
                  else
                  {
                    if ( (unsigned int)(*((_DWORD *)v41 + 63) - 1) > 1 )
                    {
                      printf("(%s)", "Unknown");
                      goto LABEL_134;
                    }
                    v51 = "(WEP)";
                  }
                }
              }
              else
              {
                v51 = "(WPA2)";
              }
              printf(v51);
            }
            else
            {
              printf("<span style=\"line-height:200%%\" class=gray_text>");
              v48 = sub_160D0();
              printf("<br><img src=\"%s\"> %s", v48, "보안 사용하지 않음");
            }
LABEL_134:
            printf("</span>");
            printf("</TD>");
            printf("<TD></TD>");
            printf("<TD align=right style=\"padding-right:5px;\">");
            printf("<span class=gray_text>");
            if ( *((_DWORD *)v41 + 54) )
            {
              v53 = *((_DWORD *)v41 + 59);
              printf((const char *)&unk_63EA7);
            }
            else
            {
              printf("검색되지않음");
            }
            printf("</span>");
            printf("</TD></TR>");
            v54 = sub_15F34((const char *)v14 + 212 * v42 + 48);
            printf("<input type=hidden name=m_ssid value='%s'>", v54);
            sub_15C10(*((_DWORD *)v41 + 64), *((_DWORD *)v41 + 63), &v74);
            printf("<input type=hidden name=m_personal_list value='%s'>", &v74);
            ++v16;
            goto LABEL_138;
          }
          v34 = "(WPA-Enterprise)";
        }
      }
      else
      {
        v34 = "(WEP)";
      }
    }
    else
    {
      v34 = "(WPA2)";
    }
    printf(v34);
    goto LABEL_91;
  }
  return result;
}
// 10214: using guessed type int __fastcall wireless_api_start_ap_scan(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 104C0: using guessed type int __fastcall wireless_api_get_ap_list(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11318: using guessed type int __fastcall wireless_api_enable_bss(_DWORD, _DWORD);
// 11420: using guessed type int __fastcall wireless_api_stop_ap_scan(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 117D4: using guessed type int __fastcall wireless_api_get_mbridge_status(_DWORD, _DWORD);
// 11B70: using guessed type int __fastcall get_ifstatus(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00028BA8) --------------------------------------------------------
int __fastcall sub_28BA8(int a1)
{
  int v1; // r4@1
  const char *v2; // r6@1
  int v3; // r0@4
  int v4; // r5@4
  int v5; // r6@7
  int v6; // r0@8
  const char *v7; // r0@9
  int v8; // r3@11
  const char *v9; // r0@13
  const char *v10; // r0@15
  const char *v11; // r1@16
  const char *v12; // r1@17
  size_t v13; // r2@18
  char *v14; // r0@18
  const char *v15; // r7@20
  const char *v16; // r1@26
  const char *v17; // r1@28
  const char *v18; // r1@30
  int v20; // [sp+0h] [bp-590h]@1
  char dest; // [sp+4h] [bp-58Ch]@3
  int v22; // [sp+9Ch] [bp-4F4h]@13
  int v23; // [sp+A0h] [bp-4F0h]@16
  int v24; // [sp+A4h] [bp-4ECh]@16
  int v25; // [sp+BCh] [bp-4D4h]@26
  int v26; // [sp+C0h] [bp-4D0h]@26
  int v27; // [sp+C4h] [bp-4CCh]@27
  char v28; // [sp+DFh] [bp-4B1h]@29
  __int16 v29; // [sp+FAh] [bp-496h]@31
  _BYTE v30[3]; // [sp+115h] [bp-47Bh]@33
  int v31; // [sp+130h] [bp-460h]@23
  char v32; // [sp+3A4h] [bp-1ECh]@9
  int v33; // [sp+3A8h] [bp-1E8h]@35
  int v34; // [sp+3ACh] [bp-1E4h]@37
  int v35; // [sp+4B0h] [bp-E0h]@4
  int v36; // [sp+4C8h] [bp-C8h]@17
  int v37; // [sp+4E8h] [bp-A8h]@18
  int v38; // [sp+568h] [bp-28h]@17
  int v39; // [sp+570h] [bp-20h]@20
  int v40; // [sp+574h] [bp-1Ch]@4

  v1 = a1;
  memset(&v20, 0, 0x570u);
  get_intvalue(v1, "run", &v20);
  v2 = (const char *)get_pvalue(v1, "ssid");
  if ( v2 )
  {
    if ( check_unpermitted_ssid_chars() )
      return 0;
    strncpy(&dest, v2, 0x20u);
  }
  v3 = get_intvalue(v1, "wl_mode", &v35);
  v4 = wireless_api_get_max_mbss(v3);
  if ( !get_intvalue(v1, "ssid_idx", &v40) )
    v40 = wireless_api_get_current_mbss_num(v35) + 1;
  if ( v40 < v4 )
  {
    v5 = v40 + (v35 << 16);
    if ( !v20 )
    {
      wireless_api_run_mbss(v40 + (v35 << 16));
      v6 = signal_start("fwsched");
      signal_save(v6);
      return 0;
    }
    get_intvalue(v1, &unk_642D0, &v32);
    v7 = (const char *)get_pvalue(v1, &unk_5F528);
    v8 = v7 && !strcmp(v7, "1");
    v22 = v8;
    v9 = (const char *)get_pvalue(v1, "use_enterprise");
    if ( v9 && !strcmp(v9, "on") )
    {
      v10 = (const char *)get_pvalue(v1, "enterprise_list");
      if ( !v10 )
        return 0;
      sub_159DC(v10, 0, &v23, &v24);
      v11 = (const char *)get_pvalue(v1, "radius_server");
      if ( !v11 )
        return 0;
      strncpy((char *)&v36, v11, 0x20u);
      get_intvalue(v1, "radius_port", &v38);
      v12 = (const char *)get_pvalue(v1, "radius_secret");
      if ( !v12 )
        return 0;
      v13 = 128;
      v14 = (char *)&v37;
    }
    else
    {
      v39 = 0;
      v15 = (const char *)get_pvalue(v1, "personal_list");
      if ( !v15 )
        return 0;
      get_intvalue(v1, "wepkey_length", &v39);
      sub_159DC(v15, v39, &v23, &v24);
      if ( (unsigned int)(v24 - 3) > 2 )
      {
        if ( (unsigned int)(v24 - 1) > 1 )
          goto LABEL_35;
        get_intvalue(v1, "default_key", &v25);
        get_intvalue(v1, "key_input", &v26);
        v16 = (const char *)get_pvalue(v1, "wep_key1");
        if ( v16 )
          strncpy((char *)&v27, v16, 0x1Au);
        v17 = (const char *)get_pvalue(v1, "wep_key2");
        if ( v17 )
          strncpy(&v28, v17, 0x1Au);
        v18 = (const char *)get_pvalue(v1, "wep_key3");
        if ( v18 )
          strncpy((char *)&v29, v18, 0x1Au);
        v12 = (const char *)get_pvalue(v1, "wep_key4");
        if ( !v12 )
          goto LABEL_35;
        v13 = 26;
        v14 = v30;
      }
      else
      {
        v12 = (const char *)get_pvalue(v1, "wpapsk_key");
        if ( !v12 )
          return 0;
        v14 = (char *)&v31;
        v13 = 64;
      }
    }
    strncpy(v14, v12, v13);
LABEL_35:
    if ( !get_intvalue(v1, "tx_rate", &v33) )
      v33 = 0;
    if ( !get_intvalue(v1, "rx_rate", &v34) )
      v34 = 0;
    v33 *= 1000;
    v34 *= 1000;
    wireless_api_add_mbss(v5, &v20, 1);
    signal_start("fwsched");
  }
  return 0;
}
// 1007C: using guessed type int __fastcall wireless_api_get_max_mbss(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 105EC: using guessed type int __fastcall wireless_api_get_current_mbss_num(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11150: using guessed type int __fastcall wireless_api_run_mbss(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11654: using guessed type int check_unpermitted_ssid_chars(void);
// 1181C: using guessed type int __fastcall wireless_api_add_mbss(_DWORD, _DWORD, _DWORD);

//----- (00028F7C) --------------------------------------------------------
int __fastcall sub_28F7C(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  int v3; // r0@2
  int v5; // [sp+4h] [bp-Ch]@1

  v1 = a1;
  v5 = 0;
  get_intvalue(a1, "wl_mode", &v5);
  v2 = (const char *)get_pvalue(v1, "ssid_idx");
  if ( v2 )
  {
    v3 = atoi(v2);
    wireless_api_del_mbss(v3 + (v5 << 16), 1);
    signal_start("fwsched");
  }
  return 0;
}
// 10130: using guessed type int __fastcall wireless_api_del_mbss(_DWORD, _DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00028FDC) --------------------------------------------------------
const char *__fastcall sub_28FDC(int a1)
{
  int v1; // r5@1
  const char *result; // r0@1
  const char *v3; // r4@1
  int v4; // r0@3

  v1 = a1;
  result = (const char *)get_pvalue(a1, "act");
  v3 = result;
  if ( result )
  {
    if ( !strcmp(result, "add") )
    {
      v4 = sub_28BA8(v1);
    }
    else
    {
      v4 = strcmp(v3, "del");
      if ( !v4 )
        v4 = sub_28F7C(v1);
    }
    signal_save(v4);
    result = (const char *)1;
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (0002904C) --------------------------------------------------------
int __fastcall sub_2904C(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r5@1
  int v5; // r7@3
  bool v6; // zf@3
  int v7; // r0@3
  signed int v8; // r8@4
  int v9; // r4@6
  int v10; // r9@10
  int v11; // r7@10
  int v12; // r4@10
  const char *v13; // r2@15
  void *v14; // r1@17
  void *v15; // r2@17
  char *v16; // r3@17
  void *v17; // ST20_4@19
  char *v18; // ST1C_4@19
  void *v19; // r11@19
  void *v20; // r0@19
  const char *v21; // r0@20
  int v22; // r0@29
  int v23; // r0@29
  int v24; // r0@32
  void *v25; // r11@34
  int v26; // r0@34
  signed int v27; // r1@35
  int v28; // r0@37
  int v29; // r0@37
  int v30; // r5@39
  void *v31; // r0@40
  void *v32; // r0@40
  int v33; // r4@41
  const char *v34; // r1@43
  void *v35; // [sp+18h] [bp-600h]@17
  int v36; // [sp+24h] [bp-5F4h]@1
  int v37; // [sp+3Ch] [bp-5DCh]@11
  char v38; // [sp+40h] [bp-5D8h]@17
  int v39; // [sp+D8h] [bp-540h]@37
  int v40; // [sp+DCh] [bp-53Ch]@19
  int v41; // [sp+E0h] [bp-538h]@17
  int v42; // [sp+F8h] [bp-520h]@34
  int v43; // [sp+FCh] [bp-51Ch]@37
  char v44; // [sp+100h] [bp-518h]@34
  char v45; // [sp+11Bh] [bp-4FDh]@34
  __int16 v46; // [sp+136h] [bp-4E2h]@34
  _BYTE v47[3]; // [sp+151h] [bp-4C7h]@34
  int v48; // [sp+16Ch] [bp-4ACh]@34
  int v49; // [sp+3E0h] [bp-238h]@19
  int v50; // [sp+3E4h] [bp-234h]@27
  int v51; // [sp+3E8h] [bp-230h]@26
  int v52; // [sp+504h] [bp-114h]@34
  int v53; // [sp+524h] [bp-F4h]@34
  int v54; // [sp+5ACh] [bp-6Ch]@17
  int v55; // [sp+5ECh] [bp-2Ch]@3

  v1 = a1;
  v36 = wireless_api_get_max_mbss(a1);
  v2 = (const char *)get_pvalue(v1, "ifname");
  v3 = v2;
  if ( !v2 )
    return printf("Error");
  v5 = strcmp(v2, "eth1") == 0;
  v6 = get_intvalue(v1, "ssid_idx", &v55) == 0;
  v7 = v1;
  if ( v6 )
    v8 = -1;
  else
    v8 = v55;
  v9 = 0;
  if ( !v6 )
    v8 += v5 << 16;
  sub_28FDC(v7);
  wireless_api_get_run(v3);
  print_file("/home/httpd/js/wirelessconf2.js");
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  printf("<table class=v3_iframe_table>");
  printf("<form method=get action=timepro.cgi name=submit_fm>");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=bss_list>");
  printf("<input type=hidden name=ifname value=\"%s\">", v3);
  printf("<input type=hidden name=\"click_id\" value='-1'>");
  printf("<input type=hidden name=\"click_bg\" value=>");
  printf("<input type=hidden name=act value=>");
  printf("<input type=hidden name=wl_mode value=%d>", v5);
  printf("<input type=hidden name=run>");
  printf("<input type=hidden name=ssid>");
  printf("<input type=hidden name=ssid_idx>");
  printf("<input type=hidden name=old_ssid>");
  printf("<input type=hidden name=broadcast_ssid>");
  printf("<input type=hidden name=mbss_policy>");
  printf("<input type=hidden name=personal_list>");
  printf("<input type=hidden name=enterprise_list>");
  printf("<input type=hidden name=use_enterprise>");
  printf("<input type=hidden name=radius_server>");
  printf("<input type=hidden name=radius_secret>");
  printf("<input type=hidden name=radius_port>");
  printf("<input type=hidden name=wpapsk_key>");
  printf("<input type=hidden name=wepkey_length>");
  printf("<input type=hidden name=key_input>");
  printf("<input type=hidden name=default_key>");
  do
    printf("<input type=hidden name=wep_key%d>", ++v9);
  while ( v9 != 4 );
  printf(" <input type=hidden name=rx_rate>");
  printf(" <input type=hidden name=tx_rate>");
  v10 = 0;
  puts("</form>");
  v11 = v5 << 16;
  v12 = 0;
  printf("<form method=get action=timepro.cgi name=mbssid_list_fm>");
  printf("<COL WIDTH=7%%><COL WIDTH=35%%><COL WIDTH=33%%><COL WIDTH=15%%><COL WIDTH=10%%>");
  while ( 1 )
  {
    memset(&v37, 0, 0x570u);
    if ( v8 != -1 && v8 == v11 )
      v10 = v12;
    if ( !read_mbssid_conf(v11, &v37) )
      break;
    v13 = "";
    if ( !v37 )
      v13 = (const char *)&unk_6058E;
    strcpy((char *)&v54, v13);
    printf("<TR height=40 ID=bss_row_%d STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickBss(%d);\">", v12);
    v14 = sub_16094();
    printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_%s.png\"></TD>", v14);
    v35 = sub_15F34(&v38);
    v15 = sub_16094();
    v16 = "lock_brown";
    if ( !v41 )
      v16 = "nolock_brown";
    v17 = v15;
    v18 = v16;
    v19 = sub_13300(v40);
    v20 = sub_133EC(v41);
    printf((const char *)&unk_644C9, &v54, v35, &v54, v12, v17, v18, v19, v20);
    printf("<br>");
    if ( !v49 )
    {
      v21 = "모든 통신 허용";
LABEL_25:
      printf(v21);
      goto LABEL_26;
    }
    if ( v49 == 1 )
    {
      v21 = "WAN포트를 통한 인터넷 통신만 허용";
      goto LABEL_25;
    }
    if ( v49 == 2 )
    {
      v21 = "내부 통신만 허용(이 공유기로부터 IP할당불가)";
      goto LABEL_25;
    }
LABEL_26:
    printf("</TD>");
    printf("<TD align=right style=\"padding-right:5px;\" %s>", &v54);
    if ( v51 || v50 )
    {
      printf("다운:");
      if ( v51 )
      {
        v22 = sub_4EC48(v51, 1000);
        v23 = printf("%d Mbps", v22);
      }
      else
      {
        v23 = printf("---");
      }
      br(v23);
      printf("업:");
      if ( v50 )
      {
        v24 = sub_4EC48(v50, 1000);
        printf("%d Mbps", v24);
      }
      else
      {
        printf("---");
      }
    }
    printf("</TD>");
    ++v11;
    printf("<TD %s>%s</TD>", &v54);
    printf("</TR>");
    v25 = sub_15F34(&v38);
    printf("<input type=hidden name=m_run value='%d'>", v37);
    printf("<input type=hidden name=m_ssid value='%s'>", v25);
    printf("<input type=hidden name=m_ssid_idx value='%d'>", v12++);
    printf("<input type=hidden name=m_mbss_policy value=%d>", v49);
    v26 = wireless_check_8021x_enabled(&v37);
    printf("<input type=hidden name=m_use_enterprise value=%d>", v26);
    printf("<input type=hidden name=m_radius_server value='%s'>", &v52);
    printf("<input type=hidden name=m_radius_secret value='%s'>", &v53);
    printf("<input type=hidden name=m_radius_port value='%d'>");
    sub_15C10(v40, v41, (char *)&v54);
    printf("<input type=hidden name=m_enterprise_list value='%s'>", &v54);
    printf("<input type=hidden name=m_personal_list value='%s'>", &v54);
    printf("<input type=hidden name=m_wepkey1 value='%s'>", &v44);
    printf("<input type=hidden name=m_wepkey2 value='%s'>", &v45);
    printf("<input type=hidden name=m_wepkey3 value='%s'>", &v46);
    printf("<input type=hidden name=m_wepkey4 value='%s'>", v47);
    printf("<input type=hidden name=m_wpapsk value='%s'>", &v48);
    printf("<input type=hidden name=m_default_key value=%d>", v42);
    if ( v41 == 1 )
      v27 = 5;
    else
      v27 = 13;
    printf("<input type=hidden name=m_wepkey_length value=%d>", v27);
    printf("<input type=hidden name=m_key_type value=%d>", v43);
    printf("<input type=hidden name=m_broadcast_ssid value=%d>", v39);
    v28 = sub_4EC48(v51, 1000);
    printf("<input type=hidden name=m_rx_rate value=%d>", v28);
    v29 = sub_4EC48(v50, 1000);
    printf("<input type=hidden name=m_tx_rate value=%d>", v29);
  }
  if ( v36 > v12 )
  {
    v30 = v12 + 1;
    printf("<TR height=40 ID=bss_row_%d STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickBss(%d);\">", v12);
    v31 = sub_16094();
    printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_on.png\"></TD>", v31);
    v32 = sub_16094();
    printf("<TD><img src=\"/%s/plus_icon.gif\">&nbsp; %s</TD><TD ID=bssidx_%d_value></TD>", v32, &unk_648CE, v12);
    printf("<TD></TD>");
    printf("<TD></TD>");
    printf("</TR>");
  }
  else
  {
    v30 = v12;
  }
  printf("<input type=hidden name=max_bss value=%d>", v36);
  printf("<input type=hidden name=mbss_num value=%d>", v12);
  v33 = 0;
  while ( v33 < 5 - v30 )
  {
    if ( ((_BYTE)v33 + (_BYTE)v30) & 1 )
      v34 = "f7f7f7";
    else
      v34 = "ffffff";
    ++v33;
    printf("<TR height=40 STYLE=\"cursor:pointer; background-Color:#%s\">", v34);
    printf("<TD colspan=%d></TD></TR>", 5);
  }
  printf("</TABLE>");
  printf("</form>");
  puts("<script>");
  puts("InitBss(parent.document,document.mbssid_list_fm);");
  if ( v8 == -1 )
    printf("ClickBss(0);");
  else
    printf("ClickBss(%d);", v10);
  return puts("</script>");
}
// 1007C: using guessed type int __fastcall wireless_api_get_max_mbss(_DWORD);
// 10808: using guessed type int __fastcall wireless_api_get_run(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 112F4: using guessed type int __fastcall wireless_check_8021x_enabled(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 1151C: using guessed type int __fastcall read_mbssid_conf(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (0002AB48) --------------------------------------------------------
int __fastcall sub_2AB48(const char *a1, int a2, int a3)
{
  char v3; // r5@1
  const char *v4; // r4@1
  int v5; // r6@1
  const char *v6; // r2@2
  int result; // r0@6

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( a3 == -1 )
  {
    v6 = "cccccc";
  }
  else
  {
    v6 = "f7f7f7";
    if ( v3 & 1 )
      v6 = "ffffff";
  }
  printf(
    "<TR height=30 ID=%s STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickWifiSched('%s');\">",
    a1,
    v6,
    a1);
  printf("<TD style=\"padding:0px 0px 0px 5px;\" ID=%s_value><a name=\"sched_%s\">%s</a></TD>", v4, v4, v5);
  printf("<TD></TD>");
  printf("<TD>%s</TD>");
  if ( !strcmp(v4, "new_sched") )
    result = puts("<TD style=\"padding-right:21;\" align=right></TD></TR>");
  else
    result = printf(
               "<TD style=\"padding-right:21;\" align=right><input type=checkbox name=rmcheck value='%s' onclick=\"ClickR"
               "m();\"></TD></TR>\n",
               v4);
  return result;
}

//----- (0002AC18) --------------------------------------------------------
int __fastcall sub_2AC18(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r6@1
  const char *v5; // r1@1
  char *v6; // r1@4
  char *v7; // r1@7
  int v8; // r7@11
  int v9; // r0@11
  int v10; // r6@11
  const char *v11; // r1@19
  char v13; // [sp+8h] [bp-6A0h]@3
  int v14; // [sp+578h] [bp-130h]@11
  int v15; // [sp+678h] [bp-30h]@3
  int v16; // [sp+688h] [bp-20h]@3
  int v17; // [sp+68Ch] [bp-1Ch]@8

  v3 = a1;
  v4 = sub_14FF4(a1, a2, a3);
  v5 = "eth2";
  if ( v4 == 1 )
    v5 = "eth1";
  sf_strncpy(&v15, v5, 16);
  read_wireless_conf(&v13, &v15);
  read_wifi_sched_config(&v15, &v16);
  printf("<table class=v3_table>");
  printf("<form method=get action=\"timepro.cgi\" name=\"wireless_sched_fm\">");
  printf("<input type=hidden name=tmenu value=wirelessconf%s>");
  printf("<input type=hidden name=\"smenu\" value=\"sched\">");
  printf("<input type=hidden name=\"act\" value=\"wifi_sched_config\">");
  printf("<input type=hidden name=\"ifname\" value=\"%s\">", &v15);
  printf("<input type=hidden name=wl_mode value=%d>", v4);
  printf("<COL width=\"20%%\"><COL width=\"60%%\"><COL width=\"20%%\">");
  printf(
    "<tr height=30px style=\"background-color:#ffffff\"><td style=\"padding-left:5px;\">%s</td>",
    "무선 스케쥴러");
  printf("<td>");
  if ( v16 )
    v6 = "";
  else
    v6 = "checked";
  printf((const char *)&unk_66A98, v6);
  print_nbsp(5);
  if ( v16 )
  {
    if ( v17 == 2 )
      v7 = "checked";
    else
      v7 = "";
  }
  else
  {
    v7 = "";
  }
  printf(
    "<input type=radio name=wifi_sched_flag value=deny onclick=\"ClickSchedFlag();\" %s> 설정된 시간에 무선 사용 금지",
    v7);
  printf("</td>");
  printf("<td align=right style=\"padding:3px;\">");
  printf("<input type=button name=params_bt value=\"%s\" onclick=\"document.wireless_sched_fm.submit();\">", "적용");
  printf("</td></tr>");
  printf("<tr><td colspan=3 valign=top width=100%% height=315>");
  printf("<TABLE width=100%% border=0 style=\"border-collapse:collapse;\">");
  printf("<TR style=\"background-Color:#eeeeee\">");
  printf("<TD style=\"padding:0px 0px 0px 5px;\" width=85%%>%s</TD>", "설정 시간");
  printf("<TD style=\"padding:0px 3px 0px 0px;\" align=right>");
  printf("<input type=checkbox name=checkall  onclick=\"CheckAllSchedule(document.wireless_sched_fm);\">");
  printf("<input type=button name=remove value=\"%s\" onclick=\"RemoveWifiSchedule();\">", "삭제");
  printf("</TD></TR>");
  printf("<TR><TD colspan=3 width=100%% height=332>");
  v8 = snprintf((char *)&v14, 0x80u, "timepro.cgi?tmenu=iframe&smenu=wifi_sched&ifname=%s", &v15);
  v9 = get_pvalue(v3, "act");
  v10 = v9;
  if ( v9 )
  {
    v9 = get_pvalue(v3, "sched_id");
    if ( v9 )
      v9 = snprintf((char *)&v14 + v8, 0x80u, "&act=%s&sched_id=%s", v10, v9);
  }
  if ( is_mobile_agent(v9) )
  {
    printf("<div style=\"height:100%%; width:100%%; -webkit-overflow-scrolling: touch; overflow-y:scroll; overflow-x:hidden; display:inline-block;\">");
    printf(
      "<iframe name=\"sched_frame\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrolling=yes></iframe>",
      &v14);
    printf("</div>");
  }
  else
  {
    printf(
      "<iframe name=\"sched_frame\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrolling=yes></iframe>",
      &v14);
  }
  printf("</TD></TR>");
  printf("</TABLE>");
  printf("</td></tr>");
  puts("<tr style=\"padding:0px;\" height=118 style=\"background-Color:#eeeeee\"><td colspan=3 valign=top>");
  printf("<table border=0 width=100%% style=\"background-Color:#eeeeee; border-collapse:collapse;\">");
  printf((const char *)&unk_66FE1);
  printf(
    "<input type=checkbox name=everyday value=1 onclick=\"ClickEveryDay(document.wireless_sched_fm);\">%s",
    "매일");
  print_nbsp(7);
  printf(" <input type=checkbox name=sun value=1>%s", "일");
  printf(" <input type=checkbox name=mon value=1>%s", "월");
  printf(" <input type=checkbox name=tue value=1>%s", "화");
  printf(" <input type=checkbox name=wed value=1>%s", "수");
  printf(" <input type=checkbox name=thu value=1>%s", "목");
  printf(" <input type=checkbox name=fri value=1>%s", "금");
  printf(" <input type=checkbox name=sat value=1>%s", "토");
  printf(" <span class=gray_text>%s</span>", "[요일 - 시작시간 기준]");
  printf("</td></tr>");
  printf("<tr><td>");
  printf(
    "<input type=checkbox name=always24 value=1 onclick=\"ClickAllTime(document.wireless_sched_fm);\">%s",
    "24시간");
  print_nbsp(5);
  printf("<input style=\"width:25px; ime-mode:disabled;\" class=\"navi_text\" type=text name=\"shour\" size=2 maxlength=2 value=> : ");
  printf("<input style=\"width:25px; ime-mode:disabled;\" class=\"navi_text\" type=text name=\"smin\" size=2 maxlength=2 value=>");
  printf(" - ");
  printf("<input style=\"width:25px; ime-mode:disabled;\" class=\"navi_text\" type=text name=\"ehour\" size=2 maxlength=2 value=> : ");
  printf("<input style=\"width:25px; ime-mode:disabled;\" class=\"navi_text\" type=text name=\"emin\" size=2 maxlength=2 value=>");
  printf("</td><td style=\"padding:0px 0px 0px 0px;\" align=left>");
  printf("</td></tr>");
  if ( v16 )
  {
    if ( v17 == 1 )
      v11 = "위의 설정된 시간에 무선 사용을 허용함";
    else
      v11 = "위의 설정된 시간에 무선 사용을 금지함";
    printf("<tr><td>&nbsp;%s</td></tr>", v11, "위의 설정된 시간에 무선 사용을 금지함");
  }
  printf("</table>");
  printf("</td></tr>");
  printf("<tr><td colspan=3 align=right height=30px>");
  printf("<input type=button name=add_bt value=\"%s\" onclick=\"ApplyWifiSched('add');\">", "추가");
  printf(
    "<input type=button name=modify_bt value=\"%s\" onclick=\"ApplyWifiSched('modify');\" style=\"display:none\">",
    "수정");
  printf("</td></tr>");
  printf("</form></table>");
  sub_15D88((int)"apply_mask", 2, 83, 620, 302);
  return printf("<script> ClickSchedFlag(); </script>");
}
// 10064: using guessed type int __fastcall read_wifi_sched_config(_DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (0002B12C) --------------------------------------------------------
const char *__fastcall sub_2B12C(int a1, int a2)
{
  int v2; // r7@1
  int v3; // r5@1
  const char *result; // r0@1
  const char *v5; // r4@1
  int v6; // r3@7
  int v7; // r0@9
  int v8; // r4@10
  int v9; // r0@13
  char v10; // [sp+Ch] [bp-DCh]@5
  char v11; // [sp+8Ch] [bp-5Ch]@5

  v2 = a2;
  v3 = a1;
  result = (const char *)get_pvalue(a1, "act");
  v5 = result;
  if ( result )
  {
    if ( strcmp(result, "add") && strcmp(v5, "modify") )
    {
      v7 = strcmp(v5, "remove");
      v8 = v7;
      if ( !v7 )
      {
        while ( 1 )
        {
          v7 = get_value_array(v3, "rmcheck", v8, &v11);
          if ( !v7 )
            break;
          remove_gen_schedule(v2, &v11);
          ++v8;
        }
      }
      goto LABEL_13;
    }
    result = (const char *)get_pvalue(v3, "add_val");
    if ( result )
    {
      sf_strncpy(&v10, result, 128);
      memset(&v11, 0, 0x44u);
      result = (const char *)parse_sched_value(&v10, &v11);
      if ( result )
      {
        if ( !strcmp(v5, "modify") )
        {
          v6 = get_pvalue(v3, "sched_id");
          if ( v6 )
            snprintf(&v11, 0x20u, "%s", v6);
        }
        v7 = add_gen_schedule(v2, &v11);
LABEL_13:
        v9 = signal_update(v7);
        signal_save(v9);
        sleep(1u);
        return (const char *)1;
      }
    }
  }
  return result;
}
// 10100: using guessed type int __fastcall parse_sched_value(_DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11798: using guessed type int __fastcall add_gen_schedule(_DWORD, _DWORD);
// 11840: using guessed type int __fastcall remove_gen_schedule(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (0002B298) --------------------------------------------------------
void __fastcall sub_2B298(int a1)
{
  const char *v1; // r4@1
  int v2; // r0@3
  const char *v3; // r1@3
  int v4; // r11@7
  void *v5; // r8@7
  int v6; // r5@7
  void *v7; // r4@7
  signed int v8; // r6@7
  signed int v9; // r8@7
  char *v10; // r12@8
  int v11; // r10@8
  int v12; // r7@10
  void **v13; // r2@10
  char *v14; // r5@10
  int v15; // t1@11
  bool v16; // zf@11
  void *v17; // r3@14
  char *v18; // r5@16
  char *v19; // r5@16
  int v20; // r10@18
  int v21; // ST30_4@18
  int v22; // ST38_4@18
  char *v23; // r5@18
  void *v24; // r1@23
  void *v25; // r1@25
  int v26; // ST00_4@25
  int v27; // ST04_4@25
  int v28; // ST08_4@25
  int v29; // ST0C_4@25
  int v30; // ST10_4@25
  int v31; // ST14_4@25
  int v32; // ST18_4@25
  int v33; // ST1C_4@25
  int v34; // ST20_4@25
  int v35; // ST24_4@25
  int v36; // ST28_4@25
  int v37; // ST2C_4@25
  int v38; // r2@25
  int v39; // r3@25
  void *v40; // r0@27
  int v41; // r4@29
  const char *v42; // r1@31
  const char *v43; // r4@35
  int v44; // r6@36
  const char *v45; // r0@38
  const char *v46; // r1@38
  int v47; // [sp+34h] [bp-9ECh]@1
  char *v48; // [sp+3Ch] [bp-9E4h]@7
  char v49; // [sp+40h] [bp-9E0h]@7
  char s[1024]; // [sp+5B0h] [bp-470h]@10
  char s1; // [sp+9B0h] [bp-70h]@7
  char v52; // [sp+9D0h] [bp-50h]@7
  int v53; // [sp+9F0h] [bp-30h]@3

  v47 = a1;
  v1 = (const char *)get_pvalue(a1, "ifname");
  if ( !v1 )
  {
    printf("Error");
    return;
  }
  print_file("/home/httpd/js/wirelessconf2.js");
  read_wifi_sched_config(v1, &v53);
  v2 = strcmp(v1, "eth1");
  if ( !v2 )
    v3 = "wifi_sched_5g";
  if ( v2 )
    v3 = "wifi_sched_2g";
  v4 = 1;
  sf_strncpy(&v52, v3, 32);
  sub_2B12C(v47, (int)&v52);
  read_wireless_conf(&v49, v1);
  v5 = malloc(0x4400u);
  v6 = read_sched_array(&v52, v5, 256);
  printf("<form method=get action=\"timepro.cgi\" name=\"main_form\">");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=\"smenu\" value=\"wifi_sched\">");
  printf("<input type=hidden name=\"ifname\" value=\"%s\">", v1);
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"click_id\" value=>");
  printf("<input type=hidden name=\"click_bg\" value=>");
  printf("<input type=hidden name=\"add_val\" value=>");
  printf("<input type=hidden name=sched_id value=>");
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  puts("<table class=v3_iframe_table>");
  printf("<COL WIDTH=50%%><COL WIDTH=5%%><COL WIDTH=30%%><COL=15%%>\n");
  strcpy(&s1, "");
  gen_sched_get_active_id(&v52, &s1);
  v7 = v5;
  v48 = (char *)v5;
  v8 = 0;
  v9 = v6;
  while ( v8 < v9 )
  {
    v10 = "";
    v11 = (int)v7 + 39;
    if ( *((_DWORD *)v7 + 9) )
      v10 = "매일";
    v12 = 0;
    v14 = &s[snprintf(s, 0x400u, "%s ", v10)];
    do
    {
      v15 = *(_BYTE *)(v11++ + 1);
      v16 = v15 == 0;
      if ( v15 )
        v13 = &off_8FB84;
      if ( !v16 )
        v17 = v13[v12];
      ++v12;
      v14 += snprintf(v14, 0x400u, "%s ");
    }
    while ( v12 != 7 );
    v18 = &v14[snprintf(v14, 0x400u, "/")];
    v19 = &v18[snprintf(v18, 0x400u, "&nbsp;&nbsp;&nbsp;")];
    if ( *((_DWORD *)v7 + 12) )
    {
      snprintf(v19, 0x400u, "%s ", "24시간");
    }
    else
    {
      v20 = *((_DWORD *)v7 + 13);
      v21 = *((_DWORD *)v7 + 14);
      v22 = *((_DWORD *)v7 + 16) + 60 * *((_DWORD *)v7 + 15);
      v23 = &v19[snprintf(v19, 0x400u, "%02d:%02d %s ", *((_DWORD *)v7 + 13), *((_DWORD *)v7 + 14), "부터")];
      if ( v21 + 60 * v20 > v22 )
        v23 += snprintf(v23, 0x400u, "%s ", "다음날");
      snprintf(v23, 0x400u, "%02d:%02d %s", *((_DWORD *)v7 + 15), *((_DWORD *)v7 + 16), "까지");
    }
    if ( v53 && !strcmp(&s1, (const char *)v7) )
    {
      printf(
        "<TR height=30 ID=%s STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickWifiSched('%s');\">",
        v7);
      printf("<TD style=\"padding:0px 0px 0px 10px;\" ID=%s_value><a name=\"sched_%s\">%s</a></TD>", v7, v7, s);
      v24 = sub_16094();
      printf("<TD><img src=\"/%s/wifi_%s.png\"></TD>", v24);
      printf("<TD style=\"padding:0px 0px 0px 0px;\">%s</TD>");
      printf(
        "<TD style=\"padding-right:21;\" align=right><input type=checkbox name=rmcheck value='%s' onclick=\"ClickRm();\"></TD></TR>\n",
        v7);
    }
    else
    {
      sub_2AB48((const char *)v7, (int)s, v4);
    }
    v25 = v7;
    ++v8;
    ++v4;
    v26 = *((_BYTE *)v7 + 40);
    v27 = *((_BYTE *)v7 + 41);
    v28 = *((_BYTE *)v7 + 42);
    v29 = *((_BYTE *)v7 + 43);
    v30 = *((_BYTE *)v7 + 44);
    v31 = *((_BYTE *)v7 + 45);
    v32 = *((_BYTE *)v7 + 46);
    v33 = *((_DWORD *)v7 + 12);
    v34 = *((_DWORD *)v7 + 13);
    v35 = *((_DWORD *)v7 + 14);
    v36 = *((_DWORD *)v7 + 15);
    v37 = *((_DWORD *)v7 + 16);
    v38 = *((_DWORD *)v7 + 8);
    v39 = *((_DWORD *)v7 + 9);
    v7 = (char *)v7 + 68;
    printf(
      "<input type=hidden id=%s_v value=\"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%02d,%02d,%02d,%02d\">\n",
      v25,
      v38,
      v39,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37);
  }
  v40 = sub_16094();
  snprintf(s, 0x400u, "<img src=\"/%s/plus_icon.gif\"> %s", v40, "설정 시간 추가하기");
  if ( v9 <= 29 )
    sub_2AB48("new_sched", (int)s, ++v8);
  v41 = 0;
  while ( v41 < 9 - v9 )
  {
    ++v8;
    ++v41;
    if ( v8 & 1 )
      v42 = "ffffff";
    else
      v42 = "f7f7f7";
    printf("<TR height=30 STYLE=\"cursor:pointer; background-Color:#%s\">", v42);
    puts("<TD CLASS=text_gray></TD><TD></TD><TD></TD><TD></TD></TR>");
  }
  printf("</table>");
  printf("</BODY>");
  puts("<script>");
  v43 = (const char *)get_pvalue(v47, "act");
  if ( !v43 || (v44 = get_pvalue(v47, "sched_id")) == 0 )
  {
    v45 = "ClickWifiSched('%s');\n";
    v46 = "new_sched";
    if ( v9 )
      v46 = v48;
    goto LABEL_45;
  }
  if ( !strcmp(v43, "modify") )
  {
    printf("ClickWifiSched('%s');\n", v44);
    v45 = "document.location.href='#sched_%s';";
    v46 = (const char *)v44;
LABEL_45:
    printf(v45, v46);
    goto LABEL_46;
  }
  if ( !strcmp(v43, "add") )
  {
    printf("ClickWifiSched('%s');\n", &v48[68 * (v9 - 1)]);
    v45 = "document.location.href='#sched_%s';";
    v46 = &v48[68 * (v9 - 1)];
    goto LABEL_45;
  }
  if ( !strcmp(v43, "remove") )
  {
    printf("ClickWifiSched('%s');\n", "new_sched");
    v45 = "document.location.href='#sched_%s';";
    v46 = "new_sched";
    goto LABEL_45;
  }
LABEL_46:
  puts("</script>");
  free(v48);
}
// 10064: using guessed type int __fastcall read_wifi_sched_config(_DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 1073C: using guessed type int __fastcall read_sched_array(_DWORD, _DWORD, _DWORD);
// 110D8: using guessed type int __fastcall gen_sched_get_active_id(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 8FB84: using guessed type void *off_8FB84;
// 2B298: using guessed type char s[1024];

//----- (0002B9D4) --------------------------------------------------------
int __fastcall sub_2B9D4(int a1, int a2)
{
  int v2; // r6@1
  int v4; // [sp+0h] [bp-410h]@1
  char v5; // [sp+200h] [bp-210h]@1

  v2 = a2;
  sf_strncpy(&v5, a1, 512);
  sf_strncpy(&v4, v2, 512);
  strtoupper(&v5);
  strtoupper(&v4);
  return strcmp(&v5, (const char *)&v4);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);

//----- (0002BA30) --------------------------------------------------------
int __fastcall sub_2BA30(int a1, int a2, int a3, int a4, signed int a5)
{
  int v5; // r4@1
  int v6; // r7@1
  int v7; // r6@1
  char *v8; // r0@2
  const char *v9; // r1@2
  signed int v10; // r3@3
  void *v11; // r0@8
  signed int v12; // r8@10
  int v13; // r3@13
  const char *v14; // r1@20
  char *v15; // r0@25
  int v16; // r1@25
  int v17; // r10@34
  int v18; // r7@34
  void *v19; // r0@38
  void *v20; // r0@39
  const char *v21; // r0@40
  int v22; // r3@49
  int v23; // r0@49
  int v24; // r2@51
  int v25; // r1@51
  bool v26; // zf@52
  const char *v27; // r0@58
  int v28; // r1@58
  void *v29; // r0@64
  char *v30; // r1@65
  int v31; // r1@68
  int v32; // r3@69
  int v33; // r4@69
  int v34; // r2@72
  int v35; // r1@72
  const char *v36; // r0@80
  char *v37; // r1@80
  int v38; // r5@81
  void *v39; // r0@82
  int v41; // [sp+0h] [bp-198h]@1
  char s[256]; // [sp+8h] [bp-190h]@81
  char v43; // [sp+108h] [bp-90h]@8
  char v44; // [sp+148h] [bp-50h]@25
  char dest; // [sp+168h] [bp-30h]@2

  v5 = a4;
  v6 = a1;
  v7 = a2;
  v41 = a3;
  printf("<TR height=%d ID=ap_row_%d STYLE=\"cursor:pointer; background-color:#%s\" ONCLICK=\"ClickAP(%d,1);\">", 60);
  if ( v5 )
  {
    v10 = *(_DWORD *)(v5 + 188);
    if ( v10 <= 75 )
    {
      v8 = &dest;
      if ( v10 <= 50 )
        v9 = "on_1";
      else
        v9 = "on_2";
    }
    else
    {
      v8 = &dest;
      v9 = "on";
    }
  }
  else
  {
    v8 = &dest;
    v9 = "off";
  }
  strcpy(v8, v9);
  v11 = sub_16094();
  printf("<TD style=\"padding-left:5px;\"><img name=wifi_icon src=\"/%s/wifi_%s.png\"></TD>", v11, &dest);
  strcpy(&v43, "");
  if ( v5 )
    sf_strncpy(&v43, v5, 64);
  v12 = a5;
  if ( a5 )
    v12 = 1;
  if ( v43 )
    v13 = 0;
  else
    v13 = v12 & 1;
  if ( v13 )
    sf_strncpy(&v43, a5 + 64, 64);
  printf("<TD valign=top style=\"padding-top:5px;\">");
  if ( v12 )
    printf("<b>");
  if ( v43 )
    v14 = (const char *)sub_15F34(&v43);
  else
    v14 = "공개되지않은 무선 네트워크";
  printf("%s", v14);
  if ( v12 )
    printf("</b>");
  printf("<br>");
  if ( v5 )
  {
    v15 = &v44;
    v16 = v5 + 128;
LABEL_28:
    sf_strncpy(v15, v16, 32);
    goto LABEL_29;
  }
  if ( v12 )
  {
    v15 = &v44;
    v16 = a5 + 44;
    goto LABEL_28;
  }
LABEL_29:
  convert_mac(&v44);
  printf("<span class=gray_text>(%s", &v44);
  if ( v12 && *(_BYTE *)(a5 + 8) )
    printf("/%s)</span>", a5 + 8);
  else
    printf(")</span>");
  if ( v5 )
  {
    v17 = *(_DWORD *)(v5 + 204);
    v18 = *(_DWORD *)(v5 + 208);
  }
  else
  {
    if ( !v12 )
    {
LABEL_38:
      printf("<span style=\"line-height:200%%\" class=gray_text>");
      v19 = sub_160D0();
      printf("<br><img style=\"margin-top:5px;\" src=\"%s\" border=0> %s", v19, "보안 사용하지 않음");
      goto LABEL_47;
    }
    v17 = *(_DWORD *)(v6 + 164);
    v18 = *(_DWORD *)(v6 + 160);
  }
  if ( !v17 )
    goto LABEL_38;
  printf("<br><span class=gray_text>");
  v20 = sub_160D0();
  printf("<img style=\"margin-top:5px;\" src=\"%s\" border=0> %s ", v20, "보안 사용");
  if ( (unsigned int)(v18 - 8) <= 3 )
  {
    v21 = "(WPA2)";
LABEL_43:
    printf(v21);
    goto LABEL_47;
  }
  if ( (unsigned int)(v18 - 4) <= 1 )
  {
    v21 = "(WPA)";
    goto LABEL_43;
  }
  if ( (unsigned int)(v17 - 1) <= 1 )
  {
    v21 = "(WEP)";
    goto LABEL_43;
  }
  printf("(%s)", "Unknown");
LABEL_47:
  printf("</span>");
  printf("</TD>");
  if ( !v12 )
  {
    printf("<TD></TD>");
    printf("<TD align=right style=\"padding-right:5px;\">");
    printf("<span class=gray_text>");
    if ( !v5 )
      goto LABEL_64;
    v28 = *(_DWORD *)(v5 + 168);
    if ( !v28 )
      goto LABEL_64;
    v27 = (const char *)&unk_63EA7;
    goto LABEL_63;
  }
  printf((const char *)&unk_63EBA, "설정됨");
  printf("<span class=gray_text>");
  if ( v5 )
  {
    v22 = *(_DWORD *)(v5 + 168);
    v23 = *(_DWORD *)(v5 + 172);
    if ( v22 != v23 || v22 != *(_DWORD *)v7 )
    {
      v24 = *(_DWORD *)v7;
      v25 = *(_DWORD *)(v7 + 4);
      if ( *(_DWORD *)v7 == v25 )
      {
        v26 = v22 == v24;
      }
      else
      {
        if ( v22 != v24 )
        {
LABEL_85:
          printf("(채널오류)");
          goto LABEL_57;
        }
        v26 = v23 == v25;
      }
      if ( v26 )
        goto LABEL_57;
      goto LABEL_85;
    }
  }
LABEL_57:
  printf("</span>");
  printf("</TD>");
  printf("<TD align=right style=\"padding-right:5px;\">");
  printf("<span class=gray_text>");
  if ( v5 )
  {
    v27 = (const char *)&unk_63EA7;
    v28 = *(_DWORD *)(v5 + 168);
LABEL_63:
    printf(v27, v28, *(_DWORD *)(v5 + 188));
  }
LABEL_64:
  printf("</span>");
  printf("</TD></TR>");
  printf("<input type=hidden name=m_configured value=\"%d\">");
  v29 = sub_15F34(&v43);
  printf("<input type=hidden name=m_ssid value='%s'>", v29);
  printf("<input type=hidden name=m_bssid value='%s'>", &v44);
  if ( v12 )
    v30 = (char *)(a5 + 8);
  else
    v30 = "";
  printf("<input type=hidden name=m_wdsname value='%s'>", v30);
  if ( v5 )
  {
    v32 = *(_DWORD *)(v5 + 168);
    v33 = *(_DWORD *)(v5 + 172);
    if ( v32 != v33 || v32 != *(_DWORD *)v7 )
    {
      v34 = *(_DWORD *)v7;
      v35 = *(_DWORD *)(v7 + 4);
      if ( *(_DWORD *)v7 == v35 )
      {
        v31 = v32 - v34;
        if ( v32 != v34 )
          v31 = 1;
      }
      else if ( v32 == v34 )
      {
        v31 = v33 != v35;
      }
      else
      {
        v31 = 1;
      }
    }
    else
    {
      v31 = 0;
    }
  }
  else
  {
    v31 = 0;
  }
  printf("<input type=hidden name=m_channel_warn value='%d'>", v31);
  if ( a5 )
  {
    v38 = snprintf(s, 0x80u, "%s", &v44, v41);
    if ( v43 )
    {
      v39 = sub_15F34(&v43);
      snprintf(&s[v38], 0x80u, "(%s)", v39);
    }
    v36 = "<input type=hidden name=m_wds_title value='%s'>";
    v37 = s;
  }
  else
  {
    v36 = "<input type=hidden name=m_wds_title value='%s'>";
    v37 = "새로운 WDS연결 추가";
  }
  return printf(v36, v37);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 2BA30: using guessed type char s[256];

//----- (0002BF4C) --------------------------------------------------------
const char *__fastcall sub_2BF4C(int a1, int a2, int a3)
{
  int v3; // r8@1
  int v4; // r4@1
  int v5; // r7@1
  const char *result; // r0@1
  const char *v7; // r5@1
  int v8; // r6@5
  int v9; // r0@10
  char *v10; // r5@10
  char *v11; // r5@14
  int v12; // r4@20
  int v13; // r0@22
  char s; // [sp+4h] [bp-DCh]@9
  char v15; // [sp+Ch] [bp-D4h]@14
  int v16; // [sp+30h] [bp-B0h]@10
  int v17; // [sp+44h] [bp-9Ch]@18
  int v18; // [sp+B0h] [bp-30h]@18
  int v19; // [sp+C4h] [bp-1Ch]@3

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = (const char *)get_pvalue(a1, "act");
  v7 = result;
  if ( result )
  {
    result = (const char *)strcmp(result, "scan");
    if ( result )
    {
      result = (const char *)get_intvalue(v4, "wl_mode", &v19);
      if ( result )
      {
        if ( !strcmp(v7, "modify") )
        {
          v8 = get_pvalue(v4, "wds_remove_bssid");
          ((void (*)(void))convert_mac2)();
          if ( v8 )
            wds_remove(v19, v8);
        }
        if ( !strcmp(v7, "add") || !strcmp(v7, "modify") )
        {
          memset(&s, 0, 0xC0u);
          result = (const char *)get_pvalue(v4, "wdshw");
          if ( !result )
            return result;
          sf_strncpy(&v16, result, 20);
          convert_mac2(&v16);
          sf_strncpy(v3, &v16, v5);
          v9 = get_pvalue(v4, "wdsname");
          v10 = (char *)v9;
          if ( v9 )
          {
            if ( check_unpermitted_chars(v9) )
              return 0;
          }
          else
          {
            v10 = " ";
          }
          sf_strncpy(&v15, v10, 32);
          v11 = (char *)get_pvalue(v4, "ssid");
          if ( v11 )
          {
            if ( check_unpermitted_ssid_chars() )
              return 0;
          }
          else
          {
            v11 = "";
          }
          sf_strncpy(&v17, v11, 64);
          v18 = v19;
          wds_add(&s);
        }
        else if ( !strcmp(v7, "remove") )
        {
          v12 = get_pvalue(v4, "wds_remove_bssid");
          ((void (*)(void))convert_mac2)();
          if ( v12 )
            wds_remove(v19, v12);
        }
        v13 = signal_start("fwsched");
        signal_save(v13);
        return (const char *)1;
      }
    }
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 107FC: using guessed type int __fastcall wds_remove(_DWORD, _DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10A30: using guessed type int __fastcall convert_mac2(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11654: using guessed type int check_unpermitted_ssid_chars(void);
// 11C30: using guessed type int __fastcall wds_add(_DWORD);

//----- (0002C16C) --------------------------------------------------------
int __fastcall sub_2C16C(const char *a1, void *a2)
{
  void *v2; // r5@1
  int v3; // r4@1
  int v4; // r7@1
  bool v5; // zf@2
  int result; // r0@2

  v2 = a2;
  v3 = 0;
  v4 = strcmp(a1, "eth1") == 0;
  memset(v2, 0, 0x784u);
  while ( 1 )
  {
    v5 = wds_get_config(v4, v3, (char *)v2 + 192 * v3 + 4) == 0;
    result = *(_DWORD *)v2;
    if ( v5 )
      break;
    ++v3;
    *(_DWORD *)v2 = result + 1;
  }
  return result;
}
// 1157C: using guessed type int __fastcall wds_get_config(_DWORD, _DWORD, _DWORD);

//----- (0002C1D0) --------------------------------------------------------
int __fastcall sub_2C1D0(int a1)
{
  int v1; // r8@1
  int v2; // r1@1
  const char *v3; // r0@2
  const char *v4; // r5@3
  int v5; // r7@3
  char *v6; // r7@4
  int v7; // r10@4
  signed int v8; // r4@8
  int result; // r0@13
  signed int v10; // r4@16
  void *v11; // r0@20
  int v12; // r3@20
  void *v13; // r4@24
  signed int v14; // r8@26
  signed int v15; // r6@26
  int v16; // r11@26
  signed int v17; // r5@26
  int v18; // r0@26
  int v19; // r0@26
  int i; // r8@28
  int j; // r7@29
  int v22; // r7@31
  int v23; // r2@38
  int k; // r9@39
  int v25; // r2@43
  int v26; // r7@46
  bool v27; // zf@47
  const char *v28; // r1@48
  const char *v29; // r0@53
  signed int v30; // r1@53
  char *s2; // [sp+Ch] [bp-108Ch]@24
  char v32[1916]; // [sp+14h] [bp-1084h]@24
  int v33; // [sp+798h] [bp-900h]@24
  int v34; // [sp+B64h] [bp-534h]@24
  int v35; // [sp+D08h] [bp-390h]@4
  int v36; // [sp+F08h] [bp-190h]@27
  int v37; // [sp+F34h] [bp-164h]@30
  int v38; // [sp+FC8h] [bp-D0h]@52
  int v39; // [sp+FCCh] [bp-CCh]@52
  int v40; // [sp+FD0h] [bp-C8h]@52
  int v41; // [sp+FD4h] [bp-C4h]@52
  int v42; // [sp+FD8h] [bp-C0h]@52
  int v43; // [sp+FF8h] [bp-A0h]@52
  int v44; // [sp+FFCh] [bp-9Ch]@3
  int v45; // [sp+101Ch] [bp-7Ch]@3
  int v46; // [sp+103Ch] [bp-5Ch]@3
  int v47; // [sp+105Ch] [bp-3Ch]@24

  v1 = a1;
  v2 = get_pvalue(a1, "ifname");
  if ( !v2 )
  {
    v3 = (const char *)&unk_639AE;
    return printf(v3, v2);
  }
  sf_strncpy(&v46, v2, 32);
  sf_strncpy(&v45, &v46, 32);
  v4 = (const char *)get_pvalue(v1, "act");
  strcpy((char *)&v44, "");
  sub_2BF4C(v1, (int)&v44, 32);
  v5 = strcmp((const char *)&v46, "eth1");
  print_file("/home/httpd/js/wirelessconf2.js");
  printf("<BODY style=\"padding:0 0 0 0; margin:0 0 0 0;\">");
  if ( !v4 )
  {
    s2 = (char *)get_pvalue(v1, "init_mac");
    wireless_api_get_current_channelspec(&v46, &v47);
    sub_2C16C((const char *)&v46, v32);
    read_wireless_conf(&v33, &v46);
    v13 = malloc(0x3530u);
    memset(v13, 0, 0x3530u);
    sf_strncpy((char *)v13 + 8, &v45, 32);
    sf_strncpy((char *)v13 + 40, &v34, 8);
    if ( get_ifstatus(&v45) )
      wireless_api_get_ap_list(v13);
    v14 = 0;
    wireless_api_stop_ap_scan(&v46);
    qsort((char *)v13 + 48, *(_DWORD *)v13, 0xD4u, (__compar_fn_t)sub_2B9D4);
    printf("<table class=v3_iframe_table>");
    v15 = -1;
    printf("<form method=get action=timepro.cgi name=wds_apply_fm>");
    printf("<input type=hidden name=tmenu value=iframe>");
    printf("<input type=hidden name=smenu value=ap_list_wds>");
    printf("<input type=hidden name=ifname value=\"%s\">", &v46);
    v16 = v5 == 0;
    printf("<input type=hidden name=act value=>");
    printf("<input type=hidden name=wl_mode value=%d>", v16);
    printf("<input type=hidden name=wds_remove_bssid>");
    printf("<input type=hidden name=wdshw>");
    printf("<input type=hidden name=wdsname>");
    printf("<input type=hidden name=ssid>");
    printf("</form>");
    printf("<form method=get action=timepro.cgi name=ap_list_fm>");
    printf("<input type=hidden name=ifname value=\"%s\">", &v46);
    v17 = 0;
    printf("<input type=hidden name=act value=>");
    v18 = printf("<input type=hidden name=wl_mode value=%d>", v16);
    v19 = hwinfo_get_max_wds(v18);
    printf("<input type=hidden name=max_wds value=%d>", v19);
    printf("<input type=hidden name=wds_num value=%d>", *(_DWORD *)v32);
    printf("<COL WIDTH=7%%><COL WIDTH=58%%><COL WIDTH=20%%><COL WIDTH=15%%>");
    while ( wds_get_config(v16, v17, &v36) )
    {
      for ( i = 0; i < *(_DWORD *)v13; ++i )
      {
        if ( !maccmp((char *)v13 + 212 * i + 176, &v37) )
        {
          v22 = (int)v13 + 212 * i + 48;
          goto LABEL_35;
        }
      }
      v22 = 0;
LABEL_35:
      if ( s2 && !strcmp((const char *)&v37, s2) )
        v15 = v17;
      v23 = v17++;
      sub_2BA30((int)&v33, (int)&v47, v23, v22, (signed int)&v36);
      v14 = 1;
    }
    for ( j = 0; j < *(_DWORD *)v13; ++j )
    {
      for ( k = 0; k < *(_DWORD *)v32; ++k )
      {
        if ( !maccmp(&v32[192 * k + 48], (char *)v13 + 212 * j + 176) )
          goto LABEL_44;
      }
      v25 = v17++;
      sub_2BA30((int)&v33, (int)&v47, v25, (int)v13 + 212 * j + 48, 0);
LABEL_44:
      ;
    }
    v26 = 0;
    while ( v26 < 8 - v17 )
    {
      v27 = ((v26++ + v17) & 1) == 0;
      if ( v27 )
        v28 = "ffffff";
      else
        v28 = "f7f7f7";
      printf("<TR height=40 STYLE=\"cursor:pointer; background-color:#%s\">", v28);
      printf("<TD colspan=%d></TD></TR>", 4);
    }
    printf("</TABLE>");
    printf("</form>");
    memset(&v38, 0, 0x34u);
    v38 = 65;
    v39 = 159;
    v40 = 500;
    v41 = 40;
    strcpy((char *)&v42, (const char *)&unk_640C8);
    v43 = 100;
    sub_15E70(
      (int)"apscan_guide_mask",
      (int)"<span class=\"gray_text\">우측 상단의 [AP 검색] 버튼을 누르면, 연결할 AP를 검색할 수 있"
           "습니다.</span>",
      (int)&v38);
    puts("<script>");
    puts("InitWds(parent.document,document.ap_list_fm);");
    if ( v15 == -1 )
    {
      if ( !v14 )
      {
        if ( !*(_DWORD *)v13 )
          puts("MaskIt(document,'apscan_guide_mask');");
        return puts("</script>");
      }
      v29 = "ClickAP(%d,1);\n";
      v30 = 0;
    }
    else
    {
      v29 = "ClickAP(%d,1);\n";
      v30 = v15;
    }
    printf(v29, v30);
    return puts("</script>");
  }
  v6 = (char *)&v35 + snprintf((char *)&v35, 0x80u, "timepro.cgi?tmenu=iframe&smenu=ap_list_wds&ifname=%s", &v46);
  v7 = strcmp(v4, "add");
  if ( v7 && strcmp(v4, "modify") && strcmp(v4, "remove") )
  {
    result = strcmp(v4, "scan");
    if ( result )
      return result;
    if ( !strcmp((const char *)&v46, "eth1") )
      v10 = 15;
    else
      v10 = 6;
    printf("<table class=v3_iframe_table>");
    if ( get_ifstatus(&v45) )
      wireless_api_start_ap_scan(&v45);
    v11 = sub_16094();
    printf(
      "<tr height=345px><td width=230 align=right valign=center><img src=\"/%s/apply_ani.gif\"></td><td style=\"padding:3"
      " 0 0 2;\" align=left>%s<span id=progress></span></td></tr>",
      v11,
      "주변의 무선 네트워크를 검색중입니다.");
    printf("</table>");
    v12 = get_pvalue(v1, "init_mac");
    if ( v12 )
      snprintf(v6, 0x80u, "&init_mac=%s", v12);
    printf("<meta http-equiv=refresh content=\"%d; URL=%s\">", v10, &v35, v12);
    puts("<script>DisableAllObj(parent.document.wds_fm);");
    v3 = "UnMaskIt(parent.document,'apply_mask');</script>";
    return printf(v3, v2);
  }
  if ( !strcmp((const char *)&v46, "eth1") )
    v8 = 25;
  else
    v8 = 15;
  if ( !v7 || !strcmp(v4, "modify") )
    snprintf(v6, 0x80u, "&init_mac=%s", &v44);
  return printf("<meta http-equiv=refresh content=\"%d; URL=%s&act=scan\">", v8, &v35);
}
// 10214: using guessed type int __fastcall wireless_api_start_ap_scan(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 104C0: using guessed type int __fastcall wireless_api_get_ap_list(_DWORD);
// 11204: using guessed type int __fastcall hwinfo_get_max_wds(_DWORD);
// 11420: using guessed type int __fastcall wireless_api_stop_ap_scan(_DWORD);
// 11450: using guessed type int __fastcall wireless_api_get_current_channelspec(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 1157C: using guessed type int __fastcall wds_get_config(_DWORD, _DWORD, _DWORD);
// 1184C: using guessed type int __fastcall maccmp(_DWORD, _DWORD);
// 11B70: using guessed type int __fastcall get_ifstatus(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 2C1D0: using guessed type char var_1084[1916];

//----- (0002CCBC) --------------------------------------------------------
int __fastcall sub_2CCBC(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r5@1
  int v6; // r4@1
  int v7; // r6@1
  int v8; // r8@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  puts("<form method=get action=timepro.cgi name=wizard>");
  puts("<input type=hidden name=tmenu value=wirelesswizard>");
  printf("<input type=hidden name=step value=%d>\n", v5);
  if ( v6 )
    printf("<input type=hidden name=ifname value=%s>\n", v6);
  if ( v7 )
    printf("<input type=hidden name=country value=%s>\n", v7);
  if ( v8 )
    printf("<input type=hidden name=ssid value=\"%s\">\n", v8);
  if ( a5 )
    printf("<input type=hidden name=channel value=%s>\n", a5);
  puts("<input type=hidden name=commit value=>");
  return puts("<input type=hidden name=nextstep value=>");
}

//----- (0002CD78) --------------------------------------------------------
int __fastcall sub_2CD78(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  const char *v4; // r0@3
  bool v5; // zf@3
  int v6; // r0@11
  int v7; // r7@13
  void *v8; // r5@14
  signed int v9; // r6@18
  const char *v10; // r0@22
  int v11; // r0@23
  const char *v12; // r0@29
  char v14; // [sp+8h] [bp-E8h]@1
  char v15; // [sp+88h] [bp-68h]@1
  char s1; // [sp+A8h] [bp-48h]@1
  char v17; // [sp+C8h] [bp-28h]@1

  v2 = a2;
  v3 = a1;
  get_value(a1, "country", &v17, 16);
  strcpy(&s1, "");
  get_value(v3, "stage", &s1, 32);
  strcpy(&v14, "");
  get_value(v3, "ssid", &v14, 128);
  if ( !get_value(v3, "ifname", &v15, 32) )
    strcpy(&v15, "eth2");
  v4 = (const char *)strcmp(&s1, "init");
  v5 = v4 == 0;
  if ( !v4 )
    v4 = "<body class=check_ssid_body>";
  if ( !v5 )
    v4 = "<body class=gray_body>";
  puts(v4);
  puts("<form method=get action=timepro.cgi name=check_fm>");
  puts("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=smenu value=%s>\n");
  printf("<input type=hidden name=country value=%s>\n", &v17);
  puts("<input type=hidden name=ssid value=>");
  printf("<input type=hidden name=ifname value=%s>\n", &v15);
  if ( !strcmp(&s1, "init") )
  {
    puts("<input type=hidden name=stage value=start>");
  }
  else if ( !strcmp(&s1, "start") )
  {
    if ( v2 )
    {
      printf("<script>");
      printf("DisableObj(parent.document.wizard.ovtest_bt);");
      printf("DisableObj(parent.document.wizard.ssid);");
      printf("DisableObj(parent.document.wizard.prev_bt);");
      printf("DisableObj(parent.document.wizard.next_bt);");
      printf("</script>");
      v6 = printf("주변의 무선 네트워크를 검색중입니다.");
      br(v6);
      printf("잠시만 기다리십시오.");
    }
    ifup(&v15);
    wireless_api_start_ap_scan(&v15);
    printf("<meta http-equiv=refresh content=\"5; URL=timepro.cgi?tmenu=iframe&smenu=%s&stage=end&country=%s&ssid=%s&ifname=%s\">");
  }
  else
  {
    v7 = strcmp(&s1, "end");
    if ( !v7 )
    {
      puts("<input type=hidden name=stage value=start>");
      v8 = malloc(0x3530u);
      memset(v8, 0, 0x3530u);
      sf_strncpy((char *)v8 + 8, &v15, 32);
      sf_strncpy((char *)v8 + 40, &v17, 8);
      wireless_api_get_ap_list(v8);
      wireless_api_stop_ap_scan(&v15);
      while ( 1 )
      {
        if ( v7 >= *(_DWORD *)v8 )
        {
          v9 = 0;
          goto LABEL_20;
        }
        if ( !strcmp(&v14, (const char *)v8 + 212 * v7 + 48) )
          break;
        ++v7;
      }
      v9 = 1;
LABEL_20:
      if ( v2 )
      {
        if ( v9 )
        {
          v11 = printf("동일한 네트워크이름을 가진 무선 네트워크가 검색되었습니다.");
          br(v11);
          v10 = "네트워크이름(SSID)를 변경할 것을 권장합니다.";
        }
        else
        {
          v10 = "사용가능한 네트워크 이름(SSID)입니다. <br>(주변에 중복된 네트워크이름(SSID)이 없습니다.)";
        }
        printf(v10);
        printf("<script>");
        printf("EnableObj(parent.document.wizard.ovtest_bt);");
        printf("EnableObj(parent.document.wizard.ssid);");
        printf("EnableObj(parent.document.wizard.prev_bt);");
        printf("EnableObj(parent.document.wizard.next_bt);");
      }
      else
      {
        printf("<script>");
        if ( v9 )
          puts("alert('동일한 네트워크이름을 가진 무선 네트워크가 검색되었습니다.\\n네트워크이름(SSID)를 변경할 것을 권장합니다.');");
        else
          printf("alert('사용가능한 네트워크 이름(SSID)입니다. \\n(주변에 중복된 네트워크이름(SSID)이 없습니다.)');");
        puts("parent.document.getElementById('ssidcheck_msg').style.display = \"none\";");
        puts("parent.document.getElementById('maintable').style.display = \"block\";");
        if ( v9 )
        {
          puts("parent.document.basicsetup_fm.ssid.focus();");
          v12 = "parent.document.basicsetup_fm.ssid.select();";
        }
        else
        {
          v12 = "parent.document.basicsetup_fm.apply_bt.focus();";
        }
        puts(v12);
      }
      printf("</script>");
      free(v8);
    }
  }
  printf("</form>");
  return printf("</body>");
}
// 10214: using guessed type int __fastcall wireless_api_start_ap_scan(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102E0: using guessed type int __fastcall ifup(_DWORD);
// 104C0: using guessed type int __fastcall wireless_api_get_ap_list(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11420: using guessed type int __fastcall wireless_api_stop_ap_scan(_DWORD);

//----- (0002D160) --------------------------------------------------------
char *__fastcall sub_2D160(int a1, char *a2, int a3, int a4, char *a5)
{
  char *v5; // r4@1
  int v6; // r7@1
  int v7; // r6@1
  int v8; // r5@1
  char *result; // r0@7
  int v10; // [sp+0h] [bp-590h]@4
  char v11; // [sp+4h] [bp-58Ch]@6
  char v12; // [sp+3CCh] [bp-1C4h]@4

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = a1;
  if ( !get_value(a1, "ifname", a2, 32) )
    strcpy(v5, "eth2");
  if ( !get_value(v8, "country", v6, 16) )
  {
    memset(&v10, 0, 0x570u);
    read_wireless_conf(&v10, v5);
    sf_strncpy(v6, &v12, 16);
  }
  if ( !get_value(v8, "ssid", v7, 128) )
  {
    memset(&v10, 0, 0x570u);
    read_wireless_conf(&v10, v5);
    sf_strncpy(v7, &v11, 128);
  }
  result = (char *)get_value(v8, "channel", a5, 16);
  if ( !result )
    result = strcpy(a5, "11.9");
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002D280) --------------------------------------------------------
int __fastcall sub_2D280(const char *a1, const char *a2, int a3)
{
  const char *v3; // r4@1
  const char *v4; // r5@1
  int v5; // r6@1
  char *v6; // r7@1
  int v7; // r0@2
  int v8; // r5@4
  signed int v9; // r3@6
  int v10; // r0@9
  signed int v11; // r3@9
  int result; // r0@11

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = strchr(a2, 46);
  if ( v6 )
  {
    *v6 = 0;
    v8 = atoi(v4);
    *(_DWORD *)v5 = v8;
    if ( !strcmp(v3, "eth1") )
    {
      *(_DWORD *)(v5 + 4) = v8;
LABEL_6:
      v9 = 80;
      goto LABEL_9;
    }
    *(_DWORD *)(v5 + 4) = atoi(v6 + 1);
  }
  else
  {
    v7 = atoi(v4);
    *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v5 = v7;
    if ( !strcmp(v3, "eth1") )
      goto LABEL_6;
  }
  v9 = 40;
LABEL_9:
  *(_DWORD *)(v5 + 16) = v9;
  v10 = strcmp(v3, "eth1");
  v11 = 5000;
  if ( v10 )
    v11 = 2412;
  result = 0;
  *(_DWORD *)(v5 + 8) = v11 + 5 * (*(_DWORD *)v5 - 1);
  return result;
}

//----- (0002D354) --------------------------------------------------------
int sub_2D354()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1

  puts("<form method=get action=timepro.cgi name=wizard>");
  puts("<input type=hidden name=tmenu value=wirelesswizard>");
  puts("<input type=hidden name=step>");
  printf("<input type=hidden name=ifname value=%s>\n", "eth2");
  v0 = sub_1466C((int)"무선 설정 마법사 시작합니다.", 0);
  str(v0);
  puts("<td height=190 class=wizardbody_td>");
  v1 = printf("무선 설정 마법사를 실행하여 무선관련 설정을 손쉽게 할 수 있습니다.");
  br(v1);
  v2 = printf("%s", "무선 마법사를 계속 진행하려면 '다음' 버튼을 클릭합니다.");
  v3 = br(v2);
  br(v3);
  printf("<span class=gray_text>");
  v4 = printf("주의] 무선으로 연결된 PC에서 마법사 실행 시 마법사의 진행이 원활하지 않을 수 있습니다.");
  v5 = br(v4);
  br(v5);
  printf("</span>");
  v6 = printf("</td>");
  etr(v6);
  v7 = print_blank_line(1, 2);
  str(v7);
  printf("<td class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=next value='%s' onclick=\"WirelessWizardGotoPage(2);\">",
    "  다 음 >  ");
  v8 = printf("</td>");
  etr(v8);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002D46C) --------------------------------------------------------
int __fastcall sub_2D46C(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  char v9; // [sp+8h] [bp-D0h]@1
  char v10; // [sp+88h] [bp-50h]@1
  char v11; // [sp+A8h] [bp-30h]@1
  char v12; // [sp+B8h] [bp-20h]@1

  sub_2D160(a1, &v10, (int)&v12, (int)&v9, &v11);
  sub_2CCBC(2, (int)&v10, 0, 0, 0);
  v1 = sub_145E0((int)"사용 국가 설정", (int)"장비를 사용할 국가를 선택합니다.", &v10);
  str(v1);
  puts("<td height=190 class=wizardbody_td>");
  v2 = printf("무선랜 신호는 국가별로 사용할 수 있는 채널이 제한되어 있습니다.");
  br(v2);
  v3 = printf("사용하고자 하는 국가를 선택한 후 '다음' 버튼을 클릭합니다.");
  v4 = br(v3);
  br(v4);
  puts("<select name=country>");
  sub_149CC((int)&v12);
  printf("</select><br><br>");
  v5 = printf("</td>");
  etr(v5);
  v6 = print_blank_line(1, 2);
  str(v6);
  printf("<td class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=next value='%s' onclick=\"WirelessWizardGotoPage(0);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next value='%s' onclick=\"WirelessWizardGotoPage(3);\">",
    "  다 음 >  ");
  v7 = printf("</td>");
  etr(v7);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002D590) --------------------------------------------------------
int __fastcall sub_2D590(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  int v13; // r0@1
  int v14; // r0@1
  int v16; // [sp+8h] [bp+0h]@1
  char v17; // [sp+88h] [bp+80h]@1
  char v18; // [sp+A8h] [bp+A0h]@1
  char v19; // [sp+B8h] [bp+B0h]@1

  sub_2D160(a1, &v17, (int)&v19, (int)&v16, &v18);
  sub_2CCBC(3, (int)&v17, (int)&v19, 0, 0);
  puts("<input type=hidden name=dupcheck value=0>");
  v1 = sub_145E0((int)"네트워크 이름(SSID) 입력", 0, &v17);
  str(v1);
  puts("<td height=190 class=wizardbody_td>");
  v2 = printf("네트워크 이름(SSID)은 무선 네트워크를 식별하기 위해 사용됩니다.");
  br(v2);
  v3 = printf("따라서, 주변의 다른 무선 네트워크 이름과 중복되지 않도록 설정할 것을 권장합니다.");
  v4 = br(v3);
  br(v4);
  v5 = printf("'중복검사' 버튼을 를 눌러 네트워크이름을 확인하십시오");
  br(v5);
  v6 = printf("중복 검사가 완료되면 '다음' 버튼을 눌러 계속 진행합니다.");
  br(v6);
  v7 = printf("* 일부 특수한 경우에 동일한 네트워크 이름(SSID)을 사용할 수도 있습니다.");
  v8 = br(v7);
  br(v8);
  printf("네트워크 이름(SSID) 입력");
  print_nbsp(3);
  printf("<input type=text name=ssid size=24 maxlength=32 value=\"%s\">", &v16);
  v9 = printf(
         "<input type=button name=ovtest_bt value=\"%s\" onclick=\"document.wizard.dupcheck.value=1; CheckSSIDOverlap();\">",
         "중복검사");
  br(v9);
  v10 = printf("<table height=35 class=wizard_outline_table>");
  str(v10);
  printf("<td>");
  printf(
    "<iframe name=check_ssid src=\"timepro.cgi?tmenu=iframe&smenu=checkssid&stage=init&country=%s&ifname=%s\" width=400 h"
    "eight=35 frameborder=no scrolling=no>",
    &v19,
    &v17);
  printf("</iframe>");
  v11 = printf("</td>");
  etr(v11);
  printf("</table>");
  v12 = puts("</td>");
  etr(v12);
  v13 = print_blank_line(1, 2);
  str(v13);
  printf("<td class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(2);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"if(document.wizard.dupcheck.value==0) alert('%s')"
    "; else WirelessWizardGotoPage(4);\">",
    "  다 음 >  ",
    "중복 검사를 실행하여야 계속 진행할 수 있습니다.");
  v14 = printf("</td>");
  etr(v14);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002D770) --------------------------------------------------------
int __fastcall sub_2D770(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  char v8; // [sp+8h] [bp-A0h]@1
  char v9; // [sp+88h] [bp-20h]@1
  int v10; // [sp+A8h] [bp+0h]@1
  char v11; // [sp+B8h] [bp+10h]@1

  sub_2D160(a1, &v9, (int)&v11, (int)&v8, (char *)&v10);
  sub_2CCBC(4, (int)&v9, (int)&v11, (int)&v8, (int)&v10);
  v1 = sub_145E0((int)"무선 채널 설정", (int)"최적의 채널을 탐색한 후 선택합니다.", &v9);
  str(v1);
  puts("<td height=190 class=wizardbody_td>");
  v2 = printf("'최적의 채널 검색이 끝나면, '다음' 버튼을 눌러 계속 진행합니다.");
  br(v2);
  printf((const char *)&unk_6922F);
  printf("<span class=gray_text>");
  v3 = printf("* 다른 채널도 수동으로 설정할 수 있습니다.");
  br(v3);
  printf("</span>");
  printf("</td><td align=right>");
  printf(
    "<input type=button name=search_bt value=\"%s\" onclick=\"parent.iframe_scan.document.scan_fm.submit();\" disabled>",
    &unk_5F59E);
  printf("</td></tr>");
  printf("</table>");
  printf("<table height=150 class=wizard_outline_table><tr><td>");
  printf(
    "<iframe name=iframe_scan src=\"timepro.cgi?tmenu=iframe&smenu=channelscan&wizard=1&stage=start&country=%s&ifname=%s&"
    "bw=%d\" width=520 height=150 frameborder=no scrolling=auto name=wizardscan >",
    &v11,
    &v9,
    40);
  printf("</iframe>");
  printf("</td></tr></table>");
  v4 = printf("</td>");
  etr(v4);
  v5 = print_blank_line(1, 2);
  str(v5);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(3);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage(5);\">",
    "  다 음 >  ");
  v6 = printf("</td>");
  etr(v6);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002D90C) --------------------------------------------------------
int __fastcall sub_2D90C(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  const char *v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  void *v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  int v13; // r0@1
  int v14; // r0@1
  int v15; // r0@1
  char v17; // [sp+Ch] [bp-C4h]@1
  char v18; // [sp+8Ch] [bp-44h]@1
  int v19; // [sp+ACh] [bp-24h]@1
  char v20; // [sp+C0h] [bp-10h]@1
  int v21; // [sp+D0h] [bp+0h]@1

  sub_2D160(a1, &v18, (int)&v21, (int)&v17, &v20);
  sub_2CCBC(5, (int)&v18, (int)&v21, (int)&v17, (int)&v20);
  v1 = sub_145E0((int)"설정 내용 확인", 0, &v18);
  str(v1);
  puts("<td height=190 class=wizardbody_td>");
  v2 = printf("아래의 설정내용을 확인합니다.");
  br(v2);
  v3 = printf("<table width=450 class=wizard_outline_table>");
  str(v3);
  printf("<td width=180>%s</td>", "사용국가");
  v4 = sub_1497C((char *)&v21);
  v5 = printf("<td>%s</td>", v4);
  etr(v5);
  v6 = sub_2D280(&v18, &v20, (int)&v19);
  str(v6);
  v7 = sub_14A54((int)&v19);
  v8 = printf((const char *)&unk_694FB, &unk_69512, v7);
  v9 = etr(v8);
  str(v9);
  v10 = printf((const char *)&unk_694FB, "네트워크이름(SSID)", &v17);
  etr(v10);
  v11 = printf("</table>");
  br(v11);
  v12 = printf("설정 내용을 확인 후, '다음' 버튼을 클릭하여 무선 보안 설정을 진행합니다.");
  br(v12);
  v13 = printf("</td>");
  etr(v13);
  v14 = print_blank_line(1, 2);
  str(v14);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(4);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage(6);\">",
    "  다 음 >  ");
  v15 = printf("</td>");
  etr(v15);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002DAB8) --------------------------------------------------------
int __fastcall sub_2DAB8(int a1)
{
  int v1; // r7@1
  int v2; // r0@1
  signed int v3; // r3@1
  int v4; // r0@5
  int v5; // r0@5
  int v6; // r0@5
  int v7; // r0@5
  int v8; // r0@5
  char v10; // [sp+Ch] [bp-DCh]@1
  char v11; // [sp+8Ch] [bp-5Ch]@1
  char v12; // [sp+ACh] [bp-3Ch]@1
  char v13; // [sp+BCh] [bp-2Ch]@1
  int v14; // [sp+CCh] [bp-1Ch]@1

  v1 = a1;
  sub_2D160(a1, &v11, (int)&v13, (int)&v10, &v12);
  v2 = get_intvalue(v1, "auth_type", &v14);
  if ( !v2 )
    v3 = 10;
  if ( !v2 )
    v14 = v3;
  sub_2D160(v1, &v11, (int)&v13, (int)&v10, &v12);
  sub_2CCBC(6, (int)&v11, (int)&v13, (int)&v10, (int)&v12);
  v4 = sub_145E0((int)"무선 보안 설정", (int)"무선 보안 방식을 선택합니다.", &v11);
  str(v4);
  puts("<td height=190 class=wizardbody_td>");
  printf("<input type=radio name=auth_type value=%d %s> %s<br>");
  print_nbsp(7);
  v5 = printf("802.11i에 정의된 표준 방식으로, WEP 보다 더욱 향상된 보안 방식입니다.<br>");
  br(v5);
  printf("<input type=radio name=auth_type value=%d %s> %s<br>");
  print_nbsp(7);
  printf("고전적인 암호화 방식으로 WPA 방식을 지원하지 않는 무선랜카드와 연결할 수 있습니다.<br>");
  print_nbsp(7);
  printf("11n 사용 시 최대 속도 54Mbps로 속도 저하가 발생할 수 있습니다<br>");
  printf("<input type=radio name=auth_type value=%d %s> %s<br>");
  print_nbsp(7);
  printf("외부에서 이 네트워크로의 침입을 막을 수 없고, 통신 중인 데이터가 쉽게 노출될 수 있습니다.<br>");
  printf("<input type=radio name=auth_type value=%d %s> %s<br>");
  v6 = printf("</td>");
  etr(v6);
  v7 = print_blank_line(1, 2);
  str(v7);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(5);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage(7);\">",
    "  다 음 >  ");
  v8 = printf("</td>");
  etr(v8);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002DCD0) --------------------------------------------------------
int __fastcall sub_2DCD0(int a1)
{
  int v1; // r8@1
  int v2; // r0@1
  signed int v3; // r3@1
  signed int v4; // r3@7
  int v5; // r0@11
  int v6; // r0@11
  int v7; // r0@11
  const char *v8; // r0@11
  int v9; // r0@12
  int v10; // r0@12
  int v11; // r0@13
  int v12; // r0@13
  int v13; // r0@13
  char v15; // [sp+8h] [bp-A0h]@1
  char v16; // [sp+88h] [bp-20h]@1
  int v17; // [sp+A8h] [bp+0h]@1
  char v18; // [sp+B8h] [bp+10h]@1
  int v19; // [sp+C8h] [bp+20h]@5
  int v20; // [sp+CCh] [bp+24h]@1

  v1 = a1;
  sub_2D160(a1, &v16, (int)&v18, (int)&v15, (char *)&v17);
  sub_2CCBC(7, (int)&v16, (int)&v18, (int)&v15, (int)&v17);
  v2 = get_intvalue(v1, "auth_type", &v20);
  if ( !v2 )
    v3 = 10;
  if ( !v2 )
    v20 = v3;
  if ( !get_intvalue(v1, "encrypt_type", &v19) )
  {
    if ( v20 == 10 )
      v4 = 4;
    else
      v4 = 1;
    v19 = v4;
  }
  printf("<input type=hidden name=auth_type value=%d>\n", v20);
  if ( v20 == 10 )
  {
    v5 = sub_145E0((int)"WPA기반의 보안(WPAPSK)", (int)"암호화 방식을 선택합니다.", &v16);
    str(v5);
    puts("<td height=190 class=wizardbody_td>");
    printf((const char *)&unk_69AA7);
    print_nbsp(7);
    printf("TKIP보다 강력한 새로운 암호화 방식입니다.<br>");
    print_nbsp(7);
    v6 = printf("일부 구형 무선랜카드에서 지원되지 않을 수 있습니다.<br>");
    br(v6);
    printf((const char *)&unk_69AA7);
    print_nbsp(7);
    printf("WEP 보안 방식을 응용한 암호화 방식입니다.<br>");
    print_nbsp(7);
    printf("11g를 지원하는 대부분의 무선랜카드에서 지원됩니다.<br>");
    print_nbsp(7);
    v7 = printf("11n 사용 시 최대 속도 54Mbps로 속도 저하가 발생할 수 있습니다<br>");
    br(v7);
    v8 = "암호화 방식을 선택 후, '다음' 버튼을 클릭하여 계속 진행합니다.";
  }
  else
  {
    v9 = sub_145E0(
           (int)"네트워크 암호 공유 방식",
           (int)"네트워크 암호의 길이를 선택합니다.",
           &v16);
    str(v9);
    puts("<td height=190 class=wizardbody_td>");
    printf("<input type=radio name=encrypt_type value=%d %s> <b>%d bit 길이의 네트워크 암호</b>를 사용하여 암호화 합니다.<br><br>");
    v10 = printf("<input type=radio name=encrypt_type value=%d %s> <b>%d bit 길이의 네트워크 암호</b>를 사용하여 암호화 합니다.<br>");
    br(v10);
    v8 = "네트워크 암호의 길이를 선택 후, '다음' 버튼을 클릭하여 계속 진행합니다.";
  }
  printf(v8);
  v11 = printf("</td>");
  etr(v11);
  v12 = print_blank_line(1, 2);
  str(v12);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(6);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage(8);\">",
    "  다 음 >  ");
  v13 = printf("</td>");
  etr(v13);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002DF74) --------------------------------------------------------
int __fastcall sub_2DF74(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  signed int v3; // r3@1
  signed int v4; // r3@7
  signed int v5; // r4@13
  int v6; // r0@19
  int v7; // r0@20
  signed int v8; // r1@22
  int v9; // r0@25
  int v10; // r0@25
  int v11; // r0@25
  int v12; // r0@25
  char dest; // [sp+8h] [bp-1A0h]@1
  char v15; // [sp+108h] [bp-A0h]@1
  char v16; // [sp+188h] [bp-20h]@1
  int v17; // [sp+1A8h] [bp+0h]@1
  char v18; // [sp+1B8h] [bp+10h]@1
  int v19; // [sp+1C8h] [bp+20h]@5
  int v20; // [sp+1CCh] [bp+24h]@1

  v1 = a1;
  sub_2D160(a1, &v16, (int)&v18, (int)&v15, (char *)&v17);
  sub_2CCBC(8, (int)&v16, (int)&v18, (int)&v15, (int)&v17);
  strcpy(&dest, "");
  v2 = get_intvalue(v1, "auth_type", &v20);
  if ( !v2 )
    v3 = 5;
  if ( !v2 )
    v20 = v3;
  if ( !get_intvalue(v1, "encrypt_type", &v19) )
  {
    if ( v20 == 10 )
      v4 = 3;
    else
      v4 = 2;
    v19 = v4;
  }
  if ( !get_value(v1, "key", &dest, 256) )
    strcpy(&dest, "");
  if ( (unsigned int)(v19 - 3) > 1 )
  {
    if ( v19 == 1 )
    {
      v5 = 5;
    }
    else if ( v19 == 2 )
    {
      v5 = 13;
    }
    else
    {
      v5 = 64;
    }
  }
  else
  {
    v5 = 64;
  }
  printf("<input type=hidden name=auth_type value=%d>\n", v20);
  printf("<input type=hidden name=encrypt_type value=%d>\n", v19);
  v6 = sub_145E0((int)"네트워크 암호 입력", 0, &v16);
  str(v6);
  puts("<td height=190 class=wizardbody_td>");
  printf("<table class=blank_table>");
  printf("<tr><td width=100>");
  printf("네트워크 암호");
  printf("</td><td>");
  printf("<input type=password name=key value='%s' size=%d maxlength=%d><br>", &dest, v5 + 3, v5);
  printf("</td></tr>");
  printf("<tr><td>");
  printf("네트워크 암호 확인");
  printf("</td><td>");
  printf("<input type=password name=confirm_key value='%s' size=%d maxlength=%d><br>", &dest, v5 + 3, v5);
  printf("</td></tr>");
  printf("</table>");
  if ( (unsigned int)(v19 - 3) > 1 )
  {
    if ( v19 == 1 )
      v8 = 5;
    else
      v8 = 13;
    v7 = printf("네트워크 암호는 정확히 %d글자를 입력하여야 합니다.<br>", v8);
  }
  else
  {
    v7 = printf("네트워크 암호는 8글자 이상 입력하여야 합니다.<br>");
  }
  br(v7);
  v9 = printf("네트워크 암호를 입력 후,'다음' 버튼을 클릭하여 계속 진행합니다.");
  br(v9);
  v10 = printf("</td>");
  etr(v10);
  v11 = print_blank_line(1, 2);
  str(v11);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(7);\">",
    "  < 이 전   ");
  printf(
    "<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage(9);\">",
    "  다 음 >  ");
  v12 = printf("</td>");
  etr(v12);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002E224) --------------------------------------------------------
int __fastcall sub_2E224(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  signed int v3; // r3@1
  int v4; // r0@9
  int v5; // r0@9
  int v6; // r0@9
  const char *v7; // r0@9
  int v8; // r0@9
  int v9; // r0@9
  void *v10; // r0@9
  int v11; // r0@9
  int v12; // r0@9
  int v13; // r0@9
  int v14; // r0@9
  int v15; // r0@11
  void *v16; // r0@13
  int v17; // r0@13
  int v18; // r0@13
  void *v19; // r0@15
  int v20; // r0@15
  int v21; // r0@15
  int v22; // r0@15
  int v23; // r0@15
  int v24; // r0@15
  bool v25; // zf@15
  int v26; // r0@15
  char v28; // [sp+8h] [bp-718h]@1
  int v29; // [sp+A8h] [bp-678h]@12
  int v30; // [sp+ACh] [bp-674h]@14
  int v31; // [sp+578h] [bp-1A8h]@1
  int v32; // [sp+678h] [bp-A8h]@1
  int v33; // [sp+6F8h] [bp-28h]@1
  int v34; // [sp+718h] [bp-8h]@9
  int v35; // [sp+72Ch] [bp+Ch]@1
  int v36; // [sp+73Ch] [bp+1Ch]@1
  int v37; // [sp+74Ch] [bp+2Ch]@5
  int v38; // [sp+750h] [bp+30h]@1
  int v39; // [sp+754h] [bp+34h]@9

  v1 = a1;
  sub_2D160(a1, (char *)&v33, (int)&v36, (int)&v32, (char *)&v35);
  sub_2CCBC(8, (int)&v33, (int)&v36, (int)&v32, (int)&v35);
  memset(&v28, 0, 0x570u);
  read_wireless_conf(&v28, &v33);
  strcpy((char *)&v31, "");
  v2 = get_intvalue(v1, "auth_type", &v38);
  if ( !v2 )
    v3 = 3;
  if ( !v2 )
    v38 = v3;
  if ( !get_intvalue(v1, "encrypt_type", &v37) )
    v37 = 0;
  if ( !get_value(v1, "key", &v31, 256) )
    strcpy((char *)&v31, "");
  printf("<input type=hidden name=key value=%s>\n", &v31);
  printf("<input type=hidden name=encrypt_type value=%d>\n", v37);
  printf("<input type=hidden name=auth_type value=%d>\n", v38);
  get_active_wl(0, 0, &v39);
  printf("<input type=hidden name=modechange value=%d>\n");
  v4 = sub_145E0((int)&unk_6A267, 0, (const char *)&v33);
  str(v4);
  puts("<td height=190 class=wizardbody_td>");
  v5 = printf("아래의 설정내용을 확인합니다.");
  br(v5);
  v6 = printf("<table width=450 class=wizard_outline_table>");
  str(v6);
  printf("<td width=180>%s</td>", "사용국가");
  v7 = sub_1497C((char *)&v36);
  v8 = printf("<td>%s</td>", v7);
  etr(v8);
  v9 = sub_2D280((const char *)&v33, (const char *)&v35, (int)&v34);
  str(v9);
  v10 = sub_14A54((int)&v34);
  v11 = printf((const char *)&unk_694FB, &unk_69512, v10);
  v12 = etr(v11);
  str(v12);
  v13 = printf((const char *)&unk_694FB, "네트워크이름(SSID)", &v32);
  v14 = etr(v13);
  str(v14);
  printf("<td>%s</td>\n", "무선보안");
  printf("<td>");
  if ( v38 == 1 )
    v38 = 3;
  v15 = v38;
  if ( v38 == 100 )
    v15 = v29;
  v16 = sub_13300(v15);
  printf("%s", v16);
  v17 = printf("</td>");
  v18 = etr(v17);
  str(v18);
  printf("<td>%s</td>\n", "암호화 방식");
  printf("<td>");
  if ( v38 == 100 )
    v37 = v30;
  v19 = sub_133EC(v37);
  printf("%s", v19);
  v20 = printf("</td>");
  etr(v20);
  v21 = printf("</table>");
  br(v21);
  v22 = printf("설정 내용을 확인 후, '설정 적용 후 마법사 마침' 버튼을 클릭하면<br>모든 설정이 적용된 후 마법사가 자동으로 종료됩니다.");
  br(v22);
  v23 = printf("</td>");
  etr(v23);
  v24 = print_blank_line(1, 2);
  str(v24);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  printf(
    "<input type=button class=navi_bt name=prev_bt value='%s' onclick=\"WirelessWizardGotoPage(8);\">",
    "  < 이 전   ");
  v25 = strcmp((const char *)&v33, "eth1") == 0;
  printf("<input type=button class=navi_bt name=next_bt value='%s' onclick=\"WirelessWizardGotoPage('%s');\">");
  v26 = printf("</td>");
  etr(v26);
  return puts("</form>");
}
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11390: using guessed type int __fastcall get_active_wl(_DWORD, _DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002E5E8) --------------------------------------------------------
int __fastcall sub_2E5E8(int a1)
{
  int v1; // r4@1
  char *v2; // r0@1
  signed int v3; // r3@3
  int v5; // [sp+0h] [bp-5D0h]@3
  char v6; // [sp+4h] [bp-5CCh]@3
  int v7; // [sp+88h] [bp-548h]@3
  int v8; // [sp+8Ch] [bp-544h]@3
  int v9; // [sp+90h] [bp-540h]@3
  int v10; // [sp+94h] [bp-53Ch]@3
  int v11; // [sp+98h] [bp-538h]@3
  int v12; // [sp+A0h] [bp-530h]@8
  int v13; // [sp+A4h] [bp-52Ch]@8
  int v14; // [sp+BCh] [bp-514h]@11
  int v15; // [sp+C0h] [bp-510h]@11
  int v16; // [sp+C4h] [bp-50Ch]@11
  int v17; // [sp+130h] [bp-4A0h]@9
  char v18; // [sp+3CCh] [bp-204h]@3
  char v19; // [sp+570h] [bp-60h]@1
  char v20; // [sp+590h] [bp-40h]@3
  int v21; // [sp+594h] [bp-3Ch]@3
  int v22; // [sp+598h] [bp-38h]@3
  int v23; // [sp+59Ch] [bp-34h]@3
  int v24; // [sp+5A0h] [bp-30h]@3
  int v25; // [sp+5A4h] [bp-2Ch]@3
  int v26; // [sp+5B4h] [bp-1Ch]@3

  v1 = a1;
  v2 = (char *)get_value(a1, "ifname", &v19, 32);
  if ( !v2 )
    v2 = strcpy(&v19, "eth2");
  clear_active_wl(v2);
  set_active_wl(&v19, 0);
  memset(&v5, 0, 0x570u);
  read_wireless_conf(&v5, &v19);
  get_value(v1, "country", &v18, 8);
  get_value(v1, "ssid", &v6, 128);
  get_value(v1, "channel", &v25, 16);
  sub_2D280(&v19, (const char *)&v25, (int)&v20);
  v7 = *(_DWORD *)&v20;
  v8 = v21;
  v9 = v22;
  v10 = v23;
  v11 = v24;
  get_intvalue(v1, "auth_type", &v26);
  v3 = v26;
  if ( v26 != 100 )
  {
    if ( v26 == 1 )
      v3 = 3;
    if ( v26 == 1 )
      v26 = v3;
    v12 = v26;
    get_intvalue(v1, "encrypt_type", &v13);
    if ( (unsigned int)(v13 - 3) > 1 )
    {
      if ( v13 )
      {
        get_value(v1, "key", &v16, 27);
        v14 = 1;
        v15 = 0;
      }
    }
    else
    {
      get_value(v1, "key", &v17, 108);
    }
  }
  v5 = 1;
  return write_wireless_conf(&v5, &v19);
}
// 1010C: using guessed type int __fastcall clear_active_wl(_DWORD);
// 10424: using guessed type int __fastcall read_wireless_conf(_DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 110C0: using guessed type int __fastcall set_active_wl(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11ABC: using guessed type int __fastcall write_wireless_conf(_DWORD, _DWORD);

//----- (0002E798) --------------------------------------------------------
int sub_2E798()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r5@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1

  v0 = sub_1466C((int)"공유기 다시 시작", 0);
  str(v0);
  puts("<td height=190 class=wizardbody_td>");
  printf("<table><tr><td>");
  v1 = printf("무선 설정을 저장한 후, 공유기가 다시 시작 됩니다.");
  br(v1);
  v2 = printf("아래의 진행상태가 완료되면 자동으로 마법사가 종료됩니다.");
  br(v2);
  printf("</td></tr>");
  print_blank_line(1, 5);
  v3 = printf("<tr><td>");
  v4 = hwinfo_get_reboot_duration(v3);
  print_html_progress_bar(v4);
  printf("</td></tr>");
  printf("</table>");
  v5 = puts("</td>");
  etr(v5);
  v6 = print_blank_line(1, 2);
  str(v6);
  printf("<td colspan=2 class=wizardbottom_td align=right>");
  v7 = printf("</td>");
  etr(v7);
  puts("</form>");
  v8 = printf("<meta http-equiv=refresh content=\"%d; URL=timepro.cgi?tmenu=wirelesswizard&step=finish\">", v4);
  return send_system_reboot_signal(v8);
}
// 10598: using guessed type int __fastcall hwinfo_get_reboot_duration(_DWORD);
// 10688: using guessed type int __fastcall send_system_reboot_signal(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 110A8: using guessed type int __fastcall print_html_progress_bar(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);

//----- (0002E89C) --------------------------------------------------------
int __fastcall sub_2E89C(int a1)
{
  int v1; // r4@1
  int v3; // [sp+0h] [bp-30h]@1

  v1 = a1;
  puts("<body bgcolor=#dedede style=\"margin-left:0; margin-right:0; margin-top:0px; margin-bottom:0;\">");
  puts("<table width=550 height=293 class=wizardtable_td bgcolor=#ffffff >");
  if ( get_value(v1, "step", &v3, 32) && strcmp((const char *)&v3, "0") )
  {
    if ( !strcmp((const char *)&v3, "2") )
    {
      sub_2D46C(v1);
    }
    else
    {
      if ( !strcmp((const char *)&v3, "save") )
        goto LABEL_32;
      if ( !strcmp((const char *)&v3, "finish") )
      {
        sub_146D0(v1);
        goto LABEL_29;
      }
      if ( !strcmp((const char *)&v3, "finish5g") )
      {
        sub_1478C(v1);
        goto LABEL_29;
      }
      if ( !strcmp((const char *)&v3, "save5g") )
      {
LABEL_32:
        sub_147EC(v1);
        goto LABEL_29;
      }
      if ( !strcmp((const char *)&v3, "reboot") )
      {
        sub_2E798();
      }
      else if ( !strcmp((const char *)&v3, "3") )
      {
        sub_2D590(v1);
      }
      else if ( !strcmp((const char *)&v3, "4") )
      {
        sub_2D770(v1);
      }
      else if ( !strcmp((const char *)&v3, "5") )
      {
        sub_2D90C(v1);
      }
      else if ( !strcmp((const char *)&v3, "6") )
      {
        sub_2DAB8(v1);
      }
      else if ( !strcmp((const char *)&v3, "7") )
      {
        sub_2DCD0(v1);
      }
      else if ( !strcmp((const char *)&v3, "8") )
      {
        sub_2DF74(v1);
      }
      else if ( !strcmp((const char *)&v3, "9") )
      {
        sub_2E224(v1);
      }
    }
  }
  else
  {
    sub_2D354();
  }
LABEL_29:
  printf("</table>");
  return printf("</body>");
}
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002EAF0) --------------------------------------------------------
int __fastcall sub_2EAF0(int a1)
{
  return sub_2CD78(a1, 1);
}

//----- (0002EAF8) --------------------------------------------------------
int __fastcall sub_2EAF8(int a1)
{
  return sub_2CD78(a1, 0);
}

//----- (0002EB00) --------------------------------------------------------
int __fastcall sub_2EB00(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  int v4; // r0@4
  char *v5; // r1@4
  int v6; // r2@4
  int v7; // r0@9
  int v8; // r3@10
  char *v9; // r0@13
  const char *v10; // r2@13
  int v11; // r3@13
  int v12; // r0@22
  int v14; // [sp+0h] [bp-320h]@13
  int v15; // [sp+4h] [bp-31Ch]@13
  char s; // [sp+10h] [bp-310h]@11
  char s1; // [sp+210h] [bp-110h]@1

  v2 = a2;
  v3 = a1;
  if ( get_value(a1, "act", &s1, 256) )
  {
    get_intvalue(v3, "sel", v2);
    if ( *(_DWORD *)v2 )
    {
      if ( *(_DWORD *)v2 != 1 )
        goto LABEL_8;
      get_ip_value(v3, "pip", v2 + 40);
      get_intvalue(v3, "start", v2 + 116);
      v5 = "end";
      v4 = v3;
      v6 = v2 + 120;
    }
    else
    {
      get_ip_value(v3, "ip", v2 + 8);
      get_intvalue(v3, "ping_type", v2 + 4);
      get_intvalue(v3, "count", v2 + 104);
      get_intvalue(v3, "timeout", v2 + 112);
      if ( *(_DWORD *)(v2 + 4) )
        goto LABEL_8;
      v4 = v3;
      v5 = "datasize";
      v6 = v2 + 108;
    }
    get_intvalue(v4, v5, v6);
LABEL_8:
    if ( strcmp(&s1, "start") )
    {
      if ( !strcmp(&s1, "stop") )
      {
        strcpy((char *)(v2 + 72), "stop");
        stop_hostscan(1);
      }
      else if ( !strcmp(&s1, "clear") )
      {
        ((void (*)(void))clear_hostscan_log)();
      }
      goto LABEL_22;
    }
    strcpy((char *)(v2 + 72), "start");
    v7 = stop_hostscan(1);
    if ( *(_DWORD *)v2 )
    {
      if ( *(_DWORD *)v2 != 1 )
        goto LABEL_17;
      v9 = &s;
      v10 = "tcp %s %d %d";
      v14 = *(_DWORD *)(v2 + 116);
      v15 = *(_DWORD *)(v2 + 120);
      v11 = v2 + 40;
    }
    else
    {
      v8 = *(_DWORD *)(v2 + 4);
      if ( !v8 )
      {
        v7 = snprintf(
               &s,
               0x200u,
               "icmp %s %d %d %d",
               v2 + 8,
               *(_DWORD *)(v2 + 104),
               1000 * *(_DWORD *)(v2 + 112),
               *(_DWORD *)(v2 + 108));
LABEL_17:
        clear_hostscan_log(v7);
        start_hostscan(&s);
LABEL_22:
        istatus_set_intvalue_direct("scan_type", *(_DWORD *)v2);
        istatus_set_intvalue_direct("ping_type", *(_DWORD *)(v2 + 4));
        istatus_set_value_direct("ping_addr", v2 + 8);
        istatus_set_value_direct("tcp_addr", v2 + 40);
        istatus_set_value_direct("text_color", v2 + 72);
        istatus_set_intvalue_direct(&unk_6A627, *(_DWORD *)(v2 + 104));
        istatus_set_intvalue_direct(&unk_6A632, *(_DWORD *)(v2 + 108));
        istatus_set_intvalue_direct("tcp_scan_start_port", *(_DWORD *)(v2 + 116));
        v12 = istatus_set_intvalue_direct("tcp_scan_end_port", *(_DWORD *)(v2 + 120));
        signal_update(v12);
        return 0;
      }
      if ( v8 != 1 )
        goto LABEL_17;
      v9 = &s;
      v14 = *(_DWORD *)(v2 + 104);
      v10 = "arp %s %d %d";
      v15 = 1000 * *(_DWORD *)(v2 + 112);
      v11 = v2 + 8;
    }
    v7 = snprintf(v9, 0x200u, v10, v11, v14, v15);
    goto LABEL_17;
  }
  return 0;
}
// 10184: using guessed type int __fastcall istatus_set_intvalue_direct(_DWORD, _DWORD);
// 10370: using guessed type int __fastcall clear_hostscan_log(_DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 107B4: using guessed type int __fastcall stop_hostscan(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 114E0: using guessed type int __fastcall start_hostscan(_DWORD);
// 115D0: using guessed type int __fastcall istatus_set_value_direct(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (0002EDE0) --------------------------------------------------------
int __fastcall sub_2EDE0(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r0@1
  char *v4; // r1@2
  int v5; // r0@4
  int v6; // r0@4
  int v7; // r0@4
  int v8; // r0@4
  int v9; // r0@4
  int v10; // r0@4
  int v11; // r0@4
  int v12; // r0@4
  int v13; // r0@4
  int v14; // r0@4
  int result; // r0@4
  const char *v16; // r0@5

  v2 = a2;
  print_start_content_table(a1);
  puts("<form method=get action=\"timepro.cgi\" name=\"hostscan_fm\">");
  puts("<input type=hidden name=\"tmenu\" value=\"expertconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"hostscan\">");
  v3 = printf("<input type=\"hidden\" name=act value\"\">");
  str(v3);
  puts("<td rowspan=2 class=itemdesc_td>");
  *(_DWORD *)v2;
  printf("<input type=radio name=sel value=%d onclick=\"hostscanRadio_disableForm(0)\" %s>\n");
  printf("Ping Test");
  puts("</td>");
  puts("<td class=item_td>");
  if ( *(_DWORD *)v2 )
    v4 = "disabled";
  else
    v4 = "";
  printf("<select class=navi_select name=ping_type onchange=\"hostscanSel_disableForm()\" %s>\n", v4);
  *(_DWORD *)(v2 + 4);
  printf("<option value=%d %s>ICMP\n");
  *(_DWORD *)(v2 + 4);
  printf("<option value=%d %s>ARP\n");
  puts("</select>");
  print_nbsp(5);
  printf("IP 주소");
  print_nbsp(2);
  sub_157CC((int)"ip", (_BYTE *)(v2 + 8), 1);
  v5 = puts("</td>");
  v6 = etr(v5);
  str(v6);
  printf("<td>");
  printf(
    "횟수 : <input type=text class=navi_text class=navimenu_text name=count maxlength=3 size=3 value=%d>\n",
    *(_DWORD *)(v2 + 104));
  printf("번");
  print_nbsp(5);
  printf(
    "시간 제한 : <input type=text class=navi_text name=timeout maxlength=2 size=2 value=%d>\n",
    *(_DWORD *)(v2 + 112));
  printf("초");
  print_nbsp(5);
  printf(
    "크기 : <input type=text class=navi_text name=datasize maxlength=5 size=5 value=%d>\n",
    *(_DWORD *)(v2 + 108));
  printf("bytes");
  v7 = puts("</td>");
  v8 = etr(v7);
  str(v8);
  puts("<td class=itemdesc_td>");
  *(_DWORD *)v2;
  printf("<input type=radio name=\"sel\" value=%d onclick=\"hostscanRadio_disableForm(1)\" %s>\n");
  puts("TCP포트스캔</td>");
  puts("<td class=item_td>");
  printf("IP 주소");
  print_nbsp(2);
  sub_157CC((int)"pip", (_BYTE *)(v2 + 40), 1);
  printf(
    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;포트범위: <input type=text class=navi_text name=start maxlength=5 size=5 value=%d>\n",
    *(_DWORD *)(v2 + 116));
  printf("~<input type=text class=navi_text name=end maxlength=5 size=5 value=%d>\n", *(_DWORD *)(v2 + 120));
  puts("</td></tr>");
  printf("<tr><td class=item_td colspan=2 align=right>");
  puts("<input class=navi_bt type=button name=start_bt value=\"시작\" onclick=\"hostscanStart()\">");
  puts("<input class=navi_bt type=button name=stop_bt value=\"중지\" onclick=\"hostscanStop()\">");
  v9 = printf("</td>");
  v10 = etr(v9);
  print_end_content_table(v10);
  print_blank_line(1, 10);
  v11 = printf("<tr><td><table style=\"border:1px solid #cccccc;\">");
  str(v11);
  printf("<td>");
  printf(
    "<iframe src=\"timepro.cgi?tmenu=iframe&smenu=hostscan&stat=%s\" align=center width=590 height=300 frameborder=no scr"
    "olling=\"auto\" name=\"scan\"></iframe>",
    v2 + 72);
  v12 = printf("</td>");
  etr(v12);
  v13 = printf("</table></td></tr>");
  str(v13);
  printf("<td colspan=2 align=right>");
  printf("<br>");
  puts("<input class=navi_bt type=button name=clear_bt value=\"로그 지우기\" onclick=\"hostscanClear()\">");
  v14 = printf("</td>");
  etr(v14);
  result = printf("</form>");
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)v2 != 1 )
      return result;
    puts("<script language=JavaScript>");
    puts("<!--");
    v16 = "hostscanRadio_disableForm(1);";
  }
  else
  {
    puts("<script language=JavaScript>");
    puts("<!--");
    puts("hostscanRadio_disableForm(0);");
    v16 = "hostscanSel_disableForm();";
  }
  puts(v16);
  puts("-->");
  return puts("</script>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0002F188) --------------------------------------------------------
int __fastcall sub_2F188(const char *a1)
{
  const char *v1; // r4@1
  char *v2; // r5@8
  char *v3; // r5@9
  char *v4; // r5@9
  char *v5; // r5@9
  int v6; // r0@9
  int v7; // r0@9
  char *v8; // r4@9
  const char *v9; // r0@9
  char *v10; // r2@9
  char *v11; // r1@9
  char *v12; // r3@9
  char *v13; // r5@11
  char *v14; // r5@11
  char *v15; // r4@11
  int v16; // r0@11
  int v17; // r0@11
  char *v18; // r5@14
  char *v19; // r5@14
  char *v20; // r0@14
  FILE *v21; // r5@15
  const char *v22; // r0@16
  char v24; // [sp+0h] [bp-90h]@5

  v1 = a1;
  if ( a1 && !strcmp(a1, "stop") )
  {
    puts("<body bgcolor=\"eeeeee\">");
  }
  else
  {
    puts("<body bgcolor=\"ffffff\">");
    if ( !v1 )
      goto LABEL_7;
  }
  if ( get_hostscan(&v24) )
    printf("<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=iframe&smenu=hostscan&stat=%s\">", v1);
LABEL_7:
  if ( !v24 )
    goto LABEL_15;
  v2 = strtok(&v24, " ");
  if ( !strcmp(v2, "icmp") )
  {
    printf("%s PING\t", "ICMP");
    v3 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s\t", "IP 주소", v3);
    v4 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s%s\t", "횟수", v4, "번");
    v5 = strtok(0, " ");
    print_nbsp(4);
    v6 = atoi(v5);
    v7 = sub_4EC48(v6, 1000);
    printf("%s:%d%s\t", "시간 제한", v7, "초");
    v8 = strtok(0, " ");
    print_nbsp(4);
    v9 = "%s:%s%s\t";
    v10 = v8;
    v11 = "크기";
    v12 = "bytes";
LABEL_12:
    printf(v9, v11, v10, v12);
    goto LABEL_15;
  }
  if ( !strcmp(v2, "arp") )
  {
    printf("%s PING\t", "ARP");
    v13 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s\t", "IP 주소", v13);
    v14 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s%s\t", "횟수", v14, "번");
    v15 = strtok(0, " ");
    print_nbsp(4);
    v16 = atoi(v15);
    v17 = sub_4EC48(v16, 1000);
    v11 = "시간 제한";
    v10 = (char *)v17;
    v12 = "초";
    v9 = "%s:%d%s\t";
    goto LABEL_12;
  }
  if ( !strcmp(v2, "tcp") )
  {
    printf("%s\t", "TCP포트스캔");
    v18 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s\t", "IP 주소", v18);
    v19 = strtok(0, " ");
    print_nbsp(4);
    printf("%s:%s~", "포트범위", v19);
    v20 = strtok(0, " ");
    printf("%s\t", v20);
  }
LABEL_15:
  v21 = fopen("/var/log/hostscan.log", "rb");
  if ( v21 )
  {
    printf("<pre><span class=item_text>");
    while ( fgets(&v24, 128, v21) )
    {
      if ( strcmp(&v24, "\n") )
        printf("%s", &v24);
    }
    printf("</span></pre>");
    printf("<a name=last></a>");
    printf("</body>");
    printf("<script>");
    printf("document.location.href='#last';");
    v22 = "</script>";
  }
  else
  {
    v22 = "</body>";
  }
  return printf(v22);
}
// 11060: using guessed type int __fastcall get_hostscan(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);

//----- (0002F698) --------------------------------------------------------
_BYTE *__fastcall sub_2F698(_BYTE *result)
{
  char v1; // r3@4
  int v2; // t1@4

  while ( 1 )
  {
    v2 = *result++;
    v1 = v2;
    if ( !v2 )
      break;
    if ( (unsigned __int8)(v1 - 97) <= 0x19u )
      *(result - 1) = v1 - 32;
  }
  return result;
}

//----- (0002F6C0) --------------------------------------------------------
int sub_2F6C0()
{
  printf("<TR height=24 STYLE=\"cursor:pointer; background-Color:#%s\">");
  return printf("<TD width=100%% colspan=6 CLASS=text_gray></TD></TR>");
}

//----- (0002F6F8) --------------------------------------------------------
int sub_2F6F8()
{
  printf("<TR height=\"0\" id=\"_-guard_line\" class=\"pf_tr\" style=\"display:none;\">");
  return printf("<TD colspan=\"6\"></TD></TR>");
}

//----- (0002F718) --------------------------------------------------------
int sub_2F718()
{
  void *v0; // r0@1

  printf("<TR height=\"24\" ID=\"_-new_line\" class=\"pf_tr\" style=\"cursor:pointer; background-color:#%s;\">\n");
  puts("<TD align=\"left\" width=\"30\" class=\"pf_td\">");
  puts("<SPAN id=\"_-new_line_span_1\" class=\"pf_span\" style=\"padding-left:5px;\"                 onclick=\"onClickedPFRule('user','','','','','','','','','','','','','','','','','');\">");
  v0 = sub_16094();
  printf("<img src=\"/%s/pf_new_rule.gif\">\n", v0);
  puts("</SPAN></TD>");
  puts("<TD align=\"left\" colspan=\"5\" class=\"pf_td\">");
  puts("<a name=\"_-new_line\" class=\"pf_a\">");
  printf("<SPAN ID=\"_-new_line_span_2\" class=\"pf_span\" style=\"color:#4789FF;\"                onclick=\"onClickedPFRule('user','','','','','','','','','','','','','','','','','');\">");
  return printf("%s</SPAN></A></TD></TR>", &unk_6B198);
}

//----- (0002F7B4) --------------------------------------------------------
int sub_2F7B4()
{
  puts("<style type=\"text/css\">");
  puts(".pf_table {");
  puts("\tborder-collapse:collapse; padding:0 0 0 0; margin:0 0 0 0;");
  puts("\ttable-layout:fixed;");
  puts("}");
  puts(".pf_tr {");
  puts("\tborder:0 0 0 0; padding:0 0 0 0;");
  puts("}");
  puts(".pf_td {");
  puts("\tpadding:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".left_padding_td {");
  puts("\tpadding:0 0 0 5; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_p {");
  puts("\tpadding:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_span {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_select {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_textbox {");
  puts("\tpadding:1 0 1 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_button {");
  puts("\tpadding:0 1 0 1; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_checkbox {");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".pf_a {");
  puts("\tvertical-align:middle; text-decoration:none;");
  puts("\tdisplay:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;");
  puts("}");
  puts(".pf_overflowable {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; border:none none none none; vertical-align:middle; text-decoration:none;");
  puts("\tdisplay:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;");
  puts("}");
  puts(".pf_opacity_30 {");
  puts("\topacity:0.3;");
  puts("\t-moz-opacity:0.3;");
  puts("\t-khtml-opacity:0.3;");
  puts("\tfilter:alpha(opacity=30);");
  puts("}");
  printf("::-webkit-input-placeholder {");
  printf("\tcolor:#B4B4B4;");
  putchar(125);
  printf(":-moz-placeholder {");
  printf("\tcolor:#B4B4B4;");
  printf("\topacity:1;");
  putchar(125);
  printf((const char *)&unk_6B545);
  printf("\tcolor:#B4B4B4;");
  printf("\topacity:1;");
  putchar(125);
  printf(":-ms-input-placeholder {");
  printf("\tcolor:#B4B4B4;");
  putchar(125);
  return printf("</style>");
}

//----- (0002FA90) --------------------------------------------------------
int __fastcall sub_2FA90(int result, int a2)
{
  int v2; // r7@1
  int v3; // r4@1
  int v4; // r9@1
  int v5; // r6@2
  int v6; // r8@2
  signed int v7; // r10@2
  int v8; // r3@3
  int v9; // t1@3
  int v10; // r5@6
  const char *v11; // r2@6
  const char *v12; // r2@8
  bool v13; // zf@8
  int v14; // r5@16
  char *v15; // r0@19
  const char *v16; // r2@19
  int v17; // r3@22
  int v18; // t1@22
  int v19; // [sp+0h] [bp-378h]@8
  int v20; // [sp+0h] [bp-378h]@19
  int v21; // [sp+4h] [bp-374h]@8
  char s; // [sp+1Ch] [bp-35Ch]@2
  char v23; // [sp+21Ch] [bp-15Ch]@8
  char v24; // [sp+31Ch] [bp-5Ch]@8
  char v25; // [sp+33Ch] [bp-3Ch]@8

  v2 = result;
  v3 = *(_DWORD *)(result + 536);
  v4 = a2;
  if ( v3 )
  {
    v5 = v3 + 20;
    v6 = v3 + 20;
    v7 = 10;
    memset(&s, 0, 0x200u);
    do
    {
      v9 = *(_DWORD *)(v6 + 4);
      v6 += 4;
      v8 = v9;
      if ( v9 )
        snprintf(&s, 0x200u, "%s%d ", &s, v8);
      --v7;
    }
    while ( v7 );
    v10 = v2 + 4;
    printf("<TR height=\"24\" id=\"%s\" class=\"pf_tr\" style=\"cursor:pointer; background-color:#%s;\" ", v2 + 4);
    v11 = "true";
    if ( *(_BYTE *)(v2 + 516) )
      v11 = "false";
    printf(
      "onclick=\"onClickedPFRule('trigger_status','%s','','','%s','','','','','%d','%d','%s','%s',%s,'%d','')\">\n",
      v10,
      v3,
      *(_DWORD *)(v3 + 8),
      *(_DWORD *)(v3 + 12),
      v3 + 16,
      &s,
      v11,
      v4);
    printf(
      "<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"30\" style=\"color:%s; padding-left:5px;\">%d</TD>\n",
      &v25,
      v4);
    puts("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"100\">");
    printf("<a name=\"%s\" title=\"%s\" class=\"pf_a\" style=\"width:80px; color:%s;\">%s</a>\n", v10, v10, &v25, v10);
    puts("</TD>");
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v25);
    memset(&v23, 0, 0x100u);
    memset(&v24, 0, 0x20u);
    snprintf(&v23, 0x100u, "%s", v3 + 64);
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v23, &v23);
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v25);
    sf_strncpy(&v24, v3, 32);
    sub_2F698(&v24);
    snprintf(&v23, 0x100u, "%s", &v24);
    v12 = *(const char **)(v3 + 12);
    v13 = v12 == 0;
    if ( v12 )
    {
      v21 = *(_DWORD *)(v3 + 12);
      v19 = *(_DWORD *)(v3 + 8);
    }
    if ( v12 )
      v12 = "%s(%d~%d)";
    if ( v13 )
      v19 = *(_DWORD *)(v3 + 8);
    if ( v13 )
      v12 = "%s(%d)";
    snprintf(&v23, 0x100u, v12, &v23, v19, v21);
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v23, &v23);
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v25);
    memset(&v23, 0, 0x100u);
    memset(&v24, 0, 0x20u);
    sf_strncpy(&v24, v3 + 16, 32);
    sub_2F698(&v24);
    snprintf(&v23, 0x100u, "%s(", &v24);
    v14 = 0;
    do
    {
      v18 = *(_DWORD *)(v5 + 4);
      v5 += 4;
      v17 = v18;
      if ( !v18 )
        break;
      if ( v14++ != 9 && *(_DWORD *)(v5 + 4) )
      {
        v20 = v17;
        v15 = &v23;
        v16 = "%s%d,";
      }
      else
      {
        v16 = "%s%d";
        v15 = &v23;
        v20 = v17;
      }
      snprintf(v15, 0x100u, v16, &v23, v20);
    }
    while ( v14 != 10 );
    snprintf(&v23, 0x100u, "%s)", &v23);
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v23, &v23);
    printf("<TD height=\"24\" align=\"right\" class=\"pf_td\" style=\"color:%s;\">\n", &v25);
    result = puts((const char *)&unk_6B810);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (0002FDCC) --------------------------------------------------------
int __fastcall sub_2FDCC(int a1, int a2)
{
  int v2; // r7@1
  int v3; // r6@1
  char *v4; // r0@3
  const char *v5; // r1@3
  int result; // r0@5
  int v7; // r4@5
  int v8; // r5@6
  const char *v9; // r3@6
  const char *v10; // ST18_4@8
  int v11; // ST10_4@8
  int v12; // ST14_4@8
  int v13; // ST08_4@8
  int v14; // ST0C_4@8
  int v15; // r3@8
  char v16; // [sp+2Ch] [bp-154h]@8
  char v17; // [sp+12Ch] [bp-54h]@8
  char v18; // [sp+14Ch] [bp-34h]@3

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)(a1 + 516) && *(_BYTE *)(a1 + 524) != 1 )
  {
    v4 = &v18;
    v5 = "#000000";
  }
  else
  {
    v5 = "#B4B4B4";
    v4 = &v18;
  }
  result = sf_strncpy(v4, v5, 20);
  v7 = *(_DWORD *)(v2 + 532);
  if ( v7 )
  {
    v8 = v2 + 4;
    v9 = "true";
    if ( *(_BYTE *)(v2 + 516) )
      v9 = "false";
    v10 = v9;
    v11 = *(_DWORD *)(v7 + 16);
    v12 = *(_DWORD *)(v7 + 20);
    v13 = *(_DWORD *)(v7 + 8);
    v14 = *(_DWORD *)(v7 + 12);
    printf(
      "<TR height=\"24\" id=\"%s\" class=\"pf_tr\" style=\"cursor:pointer; background-color:#%s;\" \t\tonclick=\"onClicke"
      "dPFRule('upnp','%s','','%s','%s','%d','%d','%d','%d','','','','',%s,'%d','%d');\">\n",
      v8);
    printf(
      "<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"30\" style=\"color:%s; padding-left:5px;\">%d</TD>\n",
      &v18,
      v3);
    puts("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"100\">");
    printf(
      "<a name=\"%s\" title=\"%s\" class=\"pf_a\" style=\"width:80px; color:%s;\">%s</a>\n",
      v8,
      v8,
      &v18,
      v8,
      v7,
      v13,
      v14,
      v11,
      v12,
      v10,
      v3,
      1);
    puts("</TD>");
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v18);
    memset(&v16, 0, 0x100u);
    memset(&v17, 0, 0x20u);
    snprintf(&v16, 0x100u, "%s", v7 + 24);
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v16, &v16);
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v18);
    memset(&v16, 0, 0x100u);
    memset(&v17, 0, 0x20u);
    sf_strncpy(&v17, v7, 32);
    sub_2F698(&v17);
    v15 = *(_DWORD *)(v7 + 12);
    if ( v15 )
      snprintf(&v16, 0x100u, (const char *)&unk_6B8FA, &v16, &v17, *(_DWORD *)(v7 + 8), v15);
    else
      snprintf(&v16, 0x100u, (const char *)&unk_6B906, &v16, &v17, *(_DWORD *)(v7 + 8));
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n");
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v18);
    puts((const char *)&unk_6B90F);
    printf("<TD height=\"24\" align=\"right\" class=\"pf_td\" style=\"color:%s; %s\">\n", &v18);
    printf("<input type=\"checkbox\" name=\"delcheck\" value=\"%s/%d\">\n", v7, *(_DWORD *)(v7 + 8));
    result = puts((const char *)&unk_6B810);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (00030078) --------------------------------------------------------
int __fastcall sub_30078(int a1, int a2, int a3)
{
  int v3; // r9@1
  int v4; // r7@1
  int v5; // r8@1
  __int64 v6; // r4@1
  char *v7; // r0@3
  const char *v8; // r1@3
  int result; // r0@5
  int v10; // r6@6
  const char *v11; // r3@7
  int v12; // r11@10
  signed int v13; // r4@10
  int v14; // r3@11
  int v15; // t1@11
  const char *v16; // r2@14
  int v17; // r2@19
  const char *v18; // r2@23
  char *v19; // r0@28
  const char *v20; // r2@28
  int v21; // r3@29
  int v22; // r10@33
  int v23; // r8@33
  char *v24; // r0@36
  const char *v25; // r2@36
  int v26; // r3@39
  int v27; // t1@39
  size_t v28; // r1@42
  char *v29; // r0@43
  const char *v30; // r2@43
  char *v31; // r3@43
  int v32; // r2@45
  char *v33; // r0@46
  const char *v34; // r2@49
  int v35; // r1@52
  int v36; // r5@52
  int v37; // r4@52
  char *v38; // r0@55
  const char *v39; // r2@55
  int v40; // r3@58
  int v41; // t1@58
  __int64 v42; // [sp+0h] [bp-388h]@9
  int v43; // [sp+0h] [bp-388h]@36
  int v44; // [sp+0h] [bp-388h]@55
  int v45; // [sp+24h] [bp-364h]@10
  char s; // [sp+2Ch] [bp-35Ch]@10
  char v47; // [sp+22Ch] [bp-15Ch]@17
  char v48; // [sp+32Ch] [bp-5Ch]@17
  char v49; // [sp+34Ch] [bp-3Ch]@3

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = *(_QWORD *)(a2 + 532);
  if ( *(_BYTE *)(a2 + 516) && *(_BYTE *)(a2 + 524) != 1 )
  {
    v7 = &v49;
    v8 = "#000000";
  }
  else
  {
    v8 = "#B4B4B4";
    v7 = &v49;
  }
  result = sf_strncpy(v7, v8, 20);
  if ( v6 )
  {
    v10 = v4 + 4;
    printf("<TR height=\"24\" id=\"%s\" class=\"pf_tr\" style=\"cursor:pointer; background-color:#%s;\" ", v4 + 4);
    if ( v3 == 1 )
    {
      v11 = "true";
      if ( *(_BYTE *)(v4 + 516) )
        v11 = "false";
      printf(
        "onclick=\"onClickedPFRule('user','%s','0','%s','%s','%d','%d','%d','%d','','','','',%s,'%d','%d')\">\n",
        v10,
        (_DWORD)v6 + 24,
        (_DWORD)v6,
        *(_DWORD *)(v6 + 8),
        *(_DWORD *)(v6 + 12),
        *(_DWORD *)(v6 + 16),
        *(_DWORD *)(v6 + 20),
        v11,
        v5,
        1);
    }
    else
    {
      memset(&s, 0, 0x200u);
      v45 = v6;
      v12 = HIDWORD(v6) + 20;
      v13 = 10;
      do
      {
        v15 = *(_DWORD *)(v12 + 4);
        v12 += 4;
        v14 = v15;
        if ( v15 )
          snprintf(&s, 0x200u, "%s%d ", &s, v14);
        --v13;
      }
      while ( v13 );
      v16 = "true";
      if ( *(_BYTE *)(v4 + 516) )
        v16 = "false";
      LODWORD(v6) = v45;
      printf(
        "onclick=\"onClickedPFRule('trigger','%s','trigger','','%s','','','','','%d','%d','%s','%s',%s,'%d','')\">\n",
        v4 + 4,
        HIDWORD(v6),
        *(_DWORD *)(HIDWORD(v6) + 8),
        *(_DWORD *)(HIDWORD(v6) + 12),
        HIDWORD(v6) + 16,
        &s,
        v16,
        v5);
    }
    printf(
      "<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"30\" style=\"color:%s; padding-left:5px;\">%d</TD>\n",
      &v49,
      v5);
    puts("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"100\">");
    printf("<a name=\"%s\" title=\"%s\" class=\"pf_a\" style=\"width:80px; color:%s;\">%s</a>\n", v10, v10, &v49, v10);
    puts("</TD>");
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v49);
    memset(&v47, 0, 0x100u);
    memset(&v48, 0, 0x20u);
    if ( v3 == 1 )
    {
      snprintf(&v47, 0x100u, "%s", (_DWORD)v6 + 24);
    }
    else
    {
      sf_strncpy(&v48, HIDWORD(v6), 32);
      sub_2F698(&v48);
      snprintf(&v47, 0x100u, "%s-%s", "트리거", &v48);
      v17 = *(_DWORD *)(HIDWORD(v6) + 12);
      if ( v17 )
        v42 = *(_QWORD *)(HIDWORD(v6) + 8);
      else
        LODWORD(v42) = *(_DWORD *)(HIDWORD(v6) + 8);
      if ( v17 )
        v18 = "%s(%d~%d)";
      else
        v18 = "%s(%d)";
      snprintf(&v47, 0x100u, v18, &v47, v42);
    }
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v47, &v47);
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v49);
    memset(&v47, 0, 0x100u);
    memset(&v48, 0, 0x20u);
    if ( v3 == 1 )
    {
      sf_strncpy(&v48, v6, 32);
      sub_2F698(&v48);
      if ( !strcmp((const char *)v6, "gre") )
      {
        LODWORD(v42) = &v48;
        v19 = &v47;
        v20 = "%s%s";
      }
      else
      {
        v21 = *(_DWORD *)(v6 + 12);
        if ( v21 )
        {
          snprintf(&v47, 0x100u, (const char *)&unk_6B8FA, &v47, &v48, *(_DWORD *)(v6 + 8), v21);
          goto LABEL_41;
        }
        v20 = (const char *)&unk_6B906;
        v19 = &v47;
        LODWORD(v42) = &v48;
        HIDWORD(v42) = *(_DWORD *)(v6 + 8);
      }
      snprintf(v19, 0x100u, v20, v19, v42);
    }
    else
    {
      v22 = 0;
      sf_strncpy(&v48, HIDWORD(v6) + 16, 32);
      sub_2F698(&v48);
      snprintf(&v47, 0x100u, "%s(", &v48);
      v23 = HIDWORD(v6) + 20;
      do
      {
        v27 = *(_DWORD *)(v23 + 4);
        v23 += 4;
        v26 = v27;
        if ( !v27 )
          break;
        if ( v22++ != 9 && *(_DWORD *)(v23 + 4) )
        {
          v43 = v26;
          v24 = &v47;
          v25 = "%s%d,";
        }
        else
        {
          v25 = "%s%d";
          v24 = &v47;
          v43 = v26;
        }
        snprintf(v24, 0x100u, v25, &v47, v43);
      }
      while ( v22 != 10 );
      snprintf(&v47, 0x100u, "%s)", &v47);
    }
LABEL_41:
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n", &v47, &v47);
    printf("<TD height=\"24\" align=\"left\" class=\"pf_td\" width=\"140\" style=\"color:%s;\">\n", &v49);
    memset(&v47, 0, 0x100u);
    memset(&v48, 0, 0x20u);
    if ( v3 == 1 )
    {
      sf_strncpy(&v48, v6, 32);
      sub_2F698(&v48);
      if ( strcmp((const char *)v6, "gre") )
      {
        if ( *(_DWORD *)(v6 + 16) )
        {
          v32 = *(_DWORD *)(v6 + 20);
          if ( v32 )
          {
            LODWORD(v42) = *(_DWORD *)(v6 + 16);
            v33 = &v47;
            HIDWORD(v42) = *(_DWORD *)(v6 + 20);
            v28 = 256;
          }
          else
          {
            LODWORD(v42) = *(_DWORD *)(v6 + 16);
            v33 = &v47;
          }
          if ( v32 )
          {
            v34 = "%s(%d~%d)";
          }
          else
          {
            v28 = 256;
            v34 = "%s(%d)";
          }
          snprintf(v33, v28, v34, &v48, v42);
        }
        goto LABEL_61;
      }
      v29 = &v47;
      v30 = "%s";
      v31 = &v48;
    }
    else
    {
      v35 = HIDWORD(v6) + 16;
      v36 = HIDWORD(v6) + 20;
      sf_strncpy(&v48, v35, 32);
      v37 = 0;
      sub_2F698(&v48);
      snprintf(&v47, 0x100u, "%s(", &v48);
      do
      {
        v41 = *(_DWORD *)(v36 + 4);
        v36 += 4;
        v40 = v41;
        if ( !v41 )
          break;
        if ( v37++ != 9 && *(_DWORD *)(v36 + 4) )
        {
          v44 = v40;
          v38 = &v47;
          v39 = "%s%d,";
        }
        else
        {
          v39 = "%s%d";
          v38 = &v47;
          v44 = v40;
        }
        snprintf(v38, 0x100u, v39, &v47, v44);
      }
      while ( v37 != 10 );
      v30 = "%s)";
      v29 = &v47;
      v31 = &v47;
    }
    snprintf(v29, 0x100u, v30, v31);
LABEL_61:
    printf("<SPAN style=\"width:140px;\" class=\"pf_overflowable\" title=\"%s\">%s</SPAN></TD>\n");
    printf("<TD height=\"24\" align=\"right\" class=\"pf_td\" style=\"color:%s; %s\">\n", &v49);
    printf("<input type=\"checkbox\" name=\"delcheck\" value=\"%s\">\n", v10);
    result = puts((const char *)&unk_6B810);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (000306AC) --------------------------------------------------------
const char *__fastcall sub_306AC(const char *a1, const char *a2, int a3, signed int a4)
{
  const char *v4; // r6@1
  const char *v5; // r4@1
  int v6; // r5@1
  signed int v7; // r8@1
  size_t v8; // r7@2
  char *v9; // r0@4
  const char *v10; // r6@7
  char *v11; // r0@7
  signed int v12; // r4@9
  void *v13; // r7@15
  signed int v14; // r2@15
  _BYTE *v15; // r3@15
  _BYTE *v16; // r1@16
  int v17; // t1@16

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( a1 )
  {
    v8 = strlen(a2);
    while ( strncmp(v4, v5, v8) )
    {
      v9 = strchr(v4, 38);
      v4 = v9;
      if ( !v9 )
        return v4;
      v4 = v9 + 1;
    }
    if ( v4 )
    {
      v10 = &v4[v8 + 1];
      v11 = strchr(v10, 38);
      if ( !v11 )
        v11 = (char *)&v10[strlen(v10)];
      v12 = v11 - v10;
      if ( v11 == v10 )
      {
        v4 = (const char *)(v11 - v10);
      }
      else
      {
        if ( v7 <= v12 )
          v12 = v7 - 1;
        if ( strchr(v10, 37) )
          v12 *= 3;
        v13 = malloc(v12 + 1);
        memcpy(v13, v10, v12);
        v14 = 0;
        v15 = v13;
        *((_BYTE *)v13 + v12) = 0;
        while ( v14 < v12 )
        {
          v16 = v15;
          v17 = *v15++;
          if ( v17 == 43 )
            *(v15 - 1) = 32;
          if ( *(v15 - 1) == 38 )
          {
            *v16 = 0;
            break;
          }
          ++v14;
        }
        v4 = (const char *)1;
        decode_string(v13);
        sf_strncpy(v6, v13, v7);
        free(v13);
      }
    }
  }
  return v4;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10634: using guessed type int __fastcall decode_string(_DWORD);

//----- (000307E4) --------------------------------------------------------
_DWORD *__fastcall sub_307E4(const char *a1)
{
  const char *v1; // r5@1
  _DWORD *v2; // r10@1
  _DWORD *v3; // r11@1
  const char *v4; // r8@1
  _DWORD *v5; // r4@2
  char *v6; // r6@3
  int v7; // r8@13
  int v8; // r1@16
  const char *v9; // r4@17
  int v10; // r9@18
  int v11; // r4@25
  int v12; // r0@25
  int v13; // r0@33
  int v14; // r0@39
  int v15; // r4@44
  int v16; // r0@44
  const char *v17; // r7@48
  int v18; // r7@52
  int v19; // r0@52
  int v20; // r7@58
  int v21; // r0@58
  int v22; // r7@66
  signed int v23; // r0@67
  signed int v24; // r3@67
  signed int v25; // r8@67
  int v26; // r1@68
  bool v27; // zf@68
  char *v28; // r3@74
  signed int i; // r5@74
  const char *v30; // r6@76
  int v31; // t1@77
  int v32; // r4@80
  signed int v33; // r9@80
  signed int v34; // r3@80
  unsigned int v35; // ST04_4@81
  int v36; // r0@81
  const char *v37; // r2@84
  int v38; // t1@85
  int v39; // t1@89
  int v40; // r2@93
  char nptr[512]; // [sp+8h] [bp-428h]@67
  char s; // [sp+208h] [bp-228h]@1

  v1 = a1;
  v2 = malloc(0x21Cu);
  v3 = v2;
  init_pf_rule();
  memset(&s, 0, 0x200u);
  v4 = sub_306AC(v1, "mode", (int)&s, 512);
  if ( !v4 )
    goto LABEL_7;
  v4 = (const char *)(pf_line_spchar_validate(&s) == 0);
  v5 = (_DWORD *)strcmp(&s, "user");
  if ( v5 )
  {
    v6 = (char *)strcmp(&s, "trigger");
    if ( !v6 )
    {
      v5 = malloc(0x58u);
      init_tr_netfilter();
      insert_tr_to_rule(v2, v5);
      v2[132] = 1;
      goto LABEL_8;
    }
    v4 = 0;
LABEL_7:
    v5 = v4;
    v6 = (char *)v4;
    goto LABEL_8;
  }
  v6 = (char *)malloc(0x30u);
  init_pf_netfilter();
  insert_nf_to_rule(v2, v6);
  v2[132] = 0;
LABEL_8:
  memset(&s, 0, 0x200u);
  if ( v4 )
  {
    v4 = sub_306AC(v1, "name", (int)&s, 512);
    if ( v4 )
    {
      v4 = (const char *)(pf_line_spchar_validate(&s) == 0);
      sf_strncpy(v2 + 1, &s, 512);
    }
  }
  memset(&s, 0, 0x200u);
  if ( !v4 )
    goto LABEL_98;
  if ( sub_306AC(v1, "disabled", (int)&s, 512) )
  {
    v7 = pf_line_spchar_validate(&s);
    if ( atoi(&s) == 1 )
      *((_BYTE *)v2 + 516) = 0;
    if ( v7 )
      goto LABEL_98;
  }
  v8 = v2[132];
  if ( v8 )
  {
    if ( v8 != 1 )
      goto LABEL_98;
    memset(&s, 0, 0x200u);
    v17 = sub_306AC(v1, "trigger_protocol", (int)&s, 8);
    if ( v17 )
    {
      v17 = (const char *)(pf_line_spchar_validate(&s) == 0);
      sf_strncpy(v5, &s, 8);
    }
    memset(&s, 0, 0x200u);
    if ( v17 )
    {
      v17 = sub_306AC(v1, "trigger_sport", (int)&s, 512);
      if ( v17 )
      {
        v18 = pf_line_spchar_validate(&s);
        v19 = atoi(&s);
        if ( (unsigned int)(v19 - 1) <= 0xFFFE )
        {
          v17 = (const char *)(v18 == 0);
          v5[2] = v19;
        }
        else
        {
          v17 = 0;
        }
      }
    }
    memset(&s, 0, 0x200u);
    if ( v17 )
    {
      if ( sub_306AC(v1, "trigger_eport", (int)&s, 512) )
      {
        v20 = pf_line_spchar_validate(&s);
        v21 = atoi(&s);
        if ( (unsigned int)(v21 - 1) <= 0xFFFE )
        {
          v17 = (const char *)(v20 == 0);
          v5[3] = v21;
        }
        else
        {
          v17 = 0;
        }
      }
      else
      {
        v17 = (const char *)1;
      }
    }
    memset(&s, 0, 0x200u);
    if ( v17 )
    {
      v17 = sub_306AC(v1, (const char *)&unk_6BB3D, (int)&s, 8);
      if ( v17 )
      {
        v17 = (const char *)(pf_line_spchar_validate(&s) == 0);
        sf_strncpy(v5 + 4, &s, 8);
      }
    }
    memset(&s, 0, 0x200u);
    if ( !v17 )
      goto LABEL_98;
    if ( !sub_306AC(v1, "forward_ports", (int)&s, 512) )
      goto LABEL_98;
    v22 = pf_line_spchar_validate(&s);
    if ( !s )
      goto LABEL_98;
    sf_strncpy(nptr, &s, 512);
    v23 = strlen(nptr);
    v24 = 0;
    v25 = v23;
    while ( v24 < v23 )
    {
      v26 = (unsigned __int8)nptr[v24];
      v27 = v26 == 32;
      if ( v26 != 32 )
        v27 = v26 == 44;
      if ( v27 )
        nptr[v24] = 0;
      ++v24;
    }
    v28 = nptr;
    for ( i = 0; ; ++i )
    {
      v30 = v28;
      if ( i >= v23 )
        break;
      v31 = (unsigned __int8)*v28++;
      if ( v31 )
        goto LABEL_80;
    }
    v30 = 0;
LABEL_80:
    v32 = (int)(v5 + 5);
    v33 = 0;
    v34 = 65534;
    while ( 1 )
    {
      v40 = v33 <= 9;
      if ( !v30 )
        v40 = 0;
      if ( !v40 )
        break;
      v35 = v34;
      v36 = atoi(v30);
      v34 = v35;
      if ( v36 - 1 > v35 )
        goto LABEL_98;
      *(_DWORD *)(v32 + 4) = v36;
      v32 += 4;
      while ( 1 )
      {
        v37 = v30;
        if ( i >= v25 )
          break;
        v38 = *v30++;
        if ( !v38 )
          break;
        ++i;
      }
      while ( 1 )
      {
        v30 = v37;
        if ( i >= v25 )
          break;
        v39 = *v37++;
        if ( v39 )
          goto LABEL_92;
        ++i;
      }
      v30 = 0;
LABEL_92:
      ++v33;
    }
    v15 = v22 == 0;
  }
  else
  {
    memset(&s, 0, 0x200u);
    v9 = sub_306AC(v1, "internal_ip", (int)&s, 20);
    if ( v9 )
    {
      v10 = pf_line_spchar_validate(&s);
      sf_strncpy(v6 + 24, &s, 20);
      v9 = (const char *)is_valid_pf_ipv4(v6 + 24);
      if ( v9 )
        v9 = (const char *)(v10 == 0);
    }
    memset(&s, 0, 0x200u);
    if ( v9 )
    {
      v9 = sub_306AC(v1, "protocol", (int)&s, 8);
      if ( v9 )
      {
        v9 = (const char *)(pf_line_spchar_validate(&s) == 0);
        sf_strncpy(v6, &s, 8);
      }
    }
    memset(&s, 0, 0x200u);
    if ( v9 && sub_306AC(v1, "ext_sport", (int)&s, 512) )
    {
      v11 = pf_line_spchar_validate(&s);
      v12 = atoi(&s);
      if ( (unsigned int)(v12 - 1) <= 0xFFFE )
      {
        v9 = (const char *)(v11 == 0);
        *((_DWORD *)v6 + 2) = v12;
      }
      else
      {
        v9 = 0;
      }
    }
    else if ( strcmp(v6, "gre") )
    {
      v9 = 0;
    }
    memset(&s, 0, 0x200u);
    if ( v9 )
    {
      if ( sub_306AC(v1, "ext_eport", (int)&s, 512) )
      {
        v9 = (const char *)(pf_line_spchar_validate(&s) == 0);
        v13 = atoi(&s);
        if ( (unsigned int)(v13 - 1) <= 0xFFFE )
          *((_DWORD *)v6 + 3) = v13;
        else
          v9 = 0;
      }
      else
      {
        v9 = (const char *)1;
      }
    }
    memset(&s, 0, 0x200u);
    if ( v9 )
    {
      if ( sub_306AC(v1, "int_sport", (int)&s, 512) )
      {
        v9 = (const char *)(pf_line_spchar_validate(&s) == 0);
        v14 = atoi(&s);
        if ( (unsigned int)(v14 - 1) <= 0xFFFE )
          *((_DWORD *)v6 + 4) = v14;
        else
          v9 = 0;
      }
      else
      {
        v9 = (const char *)1;
      }
    }
    memset(&s, 0, 0x200u);
    if ( !v9 )
      goto LABEL_98;
    if ( !sub_306AC(v1, "int_eport", (int)&s, 512) )
      return v3;
    v15 = pf_line_spchar_validate(&s) == 0;
    v16 = atoi(&s);
    if ( (unsigned int)(v16 - 1) > 0xFFFE )
      goto LABEL_98;
    *((_DWORD *)v6 + 5) = v16;
  }
  if ( !v15 )
  {
LABEL_98:
    v3 = 0;
    delete_pf_rule(0, v2);
  }
  return v3;
}
// 10004: using guessed type int __fastcall insert_nf_to_rule(_DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 106E8: using guessed type int __fastcall is_valid_pf_ipv4(_DWORD);
// 108E0: using guessed type int __fastcall delete_pf_rule(_DWORD, _DWORD);
// 10934: using guessed type int init_pf_netfilter(void);
// 10A6C: using guessed type int init_pf_rule(void);
// 11240: using guessed type int __fastcall pf_line_spchar_validate(_DWORD);
// 1142C: using guessed type int init_tr_netfilter(void);
// 118C4: using guessed type int __fastcall insert_tr_to_rule(_DWORD, _DWORD);
// 307E4: using guessed type char nptr[512];

//----- (00030F68) --------------------------------------------------------
int __fastcall sub_30F68(int result)
{
  if ( result )
    result = delete_pf_rule(0, result);
  return result;
}
// 108E0: using guessed type int __fastcall delete_pf_rule(_DWORD, _DWORD);

//----- (00030F78) --------------------------------------------------------
int __fastcall sub_30F78(int a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r8@1
  int v5; // r7@1
  int v6; // r6@2
  char *v7; // r0@6
  const char *v8; // r8@9
  char *v9; // r0@9
  signed int v10; // r5@12
  void *v11; // r6@16
  signed int v12; // r2@16
  _BYTE *v13; // r3@16
  _BYTE *v14; // r1@17
  int v15; // t1@17

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !a1 )
    return v3;
  v6 = 0;
  while ( 1 )
  {
    if ( strncmp((const char *)v3, "delcheck", 8u) )
      goto LABEL_6;
    if ( v6 == v4 )
      break;
    ++v6;
LABEL_6:
    v7 = strchr((const char *)v3, 38);
    v3 = (int)v7;
    if ( !v7 )
      return v3;
    v3 = (int)(v7 + 1);
  }
  if ( v3 )
  {
    v8 = (const char *)(v3 + 9);
    v9 = strchr((const char *)(v3 + 9), 38);
    if ( !v9 )
      v9 = (char *)&v8[strlen((const char *)(v3 + 9))];
    v3 = v9 - v8;
    if ( v9 != v8 )
    {
      v10 = 511;
      if ( v3 < 511 )
        v10 = v9 - v8;
      if ( strchr(v8, 37) )
        v10 *= 3;
      v11 = malloc(v10 + 1);
      memcpy(v11, v8, v10);
      v12 = 0;
      v13 = v11;
      *((_BYTE *)v11 + v10) = 0;
      while ( v12 < v10 )
      {
        v14 = v13;
        v15 = *v13++;
        if ( v15 == 43 )
          *(v13 - 1) = 32;
        if ( *(v13 - 1) == 38 )
        {
          *v14 = 0;
          break;
        }
        ++v12;
      }
      v3 = 1;
      decode_string(v11);
      sf_strncpy(v5, v11, 512);
      free(v11);
    }
  }
  return v3;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10634: using guessed type int __fastcall decode_string(_DWORD);

//----- (000310B4) --------------------------------------------------------
signed int __fastcall sub_310B4(const char *a1)
{
  const char *v1; // r4@1
  const char *v2; // r0@2
  _DWORD *v3; // r5@4
  int v4; // r0@5
  _DWORD *v5; // r1@5
  signed int v6; // r2@5
  const char *v7; // r0@5
  int v8; // r0@7
  int v9; // r0@10
  _DWORD *v10; // r1@10
  signed int v11; // r2@10
  const char *v12; // r0@10
  signed int v13; // r4@13
  int v14; // r5@14
  int *v15; // r6@15
  int v16; // r0@20
  int v18; // [sp+0h] [bp-C850h]@15
  char s; // [sp+C800h] [bp-50h]@4
  int v20; // [sp+C820h] [bp-30h]@2

  v1 = a1;
  if ( !a1 )
    return -1;
  v2 = sub_306AC(a1, "act", (int)&v20, 32);
  if ( !v2 )
  {
    v13 = -1;
    goto LABEL_20;
  }
  if ( strcmp((const char *)&v20, "add") )
  {
    if ( !strcmp((const char *)&v20, "modify") )
    {
      memset(&s, 0, 0x20u);
      v3 = sub_307E4(v1);
      if ( sub_306AC(v1, "priority", (int)&s, 32) )
      {
        v9 = atoi(&s);
        v10 = v3;
        v11 = v9;
        v12 = "user_pf";
      }
      else
      {
        v12 = "user_pf";
        v10 = v3;
        v11 = -1;
      }
      v8 = portforward_modify_rule(v12, v10, v11);
      goto LABEL_13;
    }
    v14 = strcmp((const char *)&v20, "del");
    if ( !v14 )
    {
      v15 = &v18;
      memset(&v18, 0, 0xC800u);
      do
      {
        if ( !sub_30F78((int)v1, v14, (int)v15) )
          break;
        ++v14;
        v15 += 128;
      }
      while ( v14 != 100 );
      v2 = (const char *)portforward_remove_rules("user_pf", &v18, v14);
      v13 = (signed int)v2;
      goto LABEL_20;
    }
    return -1;
  }
  memset(&s, 0, 0x20u);
  v3 = sub_307E4(v1);
  if ( sub_306AC(v1, "priority", (int)&s, 32) )
  {
    v4 = atoi(&s);
    v5 = v3;
    v6 = v4;
    v7 = "user_pf";
  }
  else
  {
    v7 = "user_pf";
    v5 = v3;
    v6 = 100;
  }
  v8 = portforward_add_rule(v7, v5, v6);
LABEL_13:
  v13 = v8;
  v2 = (const char *)sub_30F68((int)v3);
LABEL_20:
  v16 = signal_update(v2);
  signal_save(v16);
  return v13;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 109C4: using guessed type int __fastcall portforward_add_rule(_DWORD, _DWORD, _DWORD);
// 112E8: using guessed type int __fastcall portforward_remove_rules(_DWORD, _DWORD, _DWORD);
// 1160C: using guessed type int __fastcall portforward_modify_rule(_DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00031288) --------------------------------------------------------
signed int __fastcall sub_31288(const char *a1)
{
  int v1; // r5@1
  const char *v2; // r0@2
  signed int v3; // r4@3
  int v4; // r4@4
  int *v5; // r6@5
  int v6; // r0@9
  int v8; // [sp+0h] [bp-C830h]@5
  char v9; // [sp+C800h] [bp-30h]@2

  v1 = (int)a1;
  if ( !a1 )
    return -1;
  v2 = sub_306AC(a1, "act", (int)&v9, 32);
  if ( v2 )
  {
    v4 = strcmp(&v9, "del");
    if ( !v4 )
    {
      v5 = &v8;
      memset(&v8, 0, 0xC800u);
      do
      {
        if ( !sub_30F78(v1, v4, (int)v5) )
          break;
        ++v4;
        v5 += 128;
      }
      while ( v4 != 100 );
      v2 = (const char *)portforward_remove_rules("upnp_pf", &v8, v4);
      v3 = (signed int)v2;
      goto LABEL_9;
    }
    return -1;
  }
  v3 = -1;
LABEL_9:
  v6 = signal_update(v2);
  signal_save(v6);
  return v3;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 112E8: using guessed type int __fastcall portforward_remove_rules(_DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (0003134C) --------------------------------------------------------
int __fastcall sub_3134C(int a1)
{
  int v1; // r6@1
  FILE *v2; // r5@1
  signed int v3; // r10@2
  char *v4; // r8@2
  char *v5; // r0@5
  const char *v6; // r9@5
  char *v7; // r0@8
  int v8; // r9@8
  char *v9; // r1@8
  const char *v10; // r0@9
  char *v11; // r0@11
  char *v12; // r4@11
  const char *v13; // r0@12
  char v14; // r3@14
  char *v15; // r1@22
  const char *v16; // r0@23
  char *v17; // r4@27
  const char *v18; // r0@30
  char *v19; // r4@30
  int *v20; // r5@34
  void *v21; // r0@34
  int v22; // r0@34
  const char *v23; // r0@35
  const char *v24; // r0@36
  void *v25; // r0@38
  int v26; // r0@38
  int v27; // r0@39
  void *v28; // r0@41
  int v29; // r0@41
  const char *v30; // r0@42
  void *v31; // r0@45
  int v32; // r0@45
  int result; // r0@49
  int v34; // r0@50
  int v35; // r0@53
  void *v36; // r0@55
  FILE *v37; // r5@55
  int v38; // r8@56
  char *v39; // r0@58
  void *v40; // r0@63
  char *v41; // r1@64
  char *v42; // r1@67
  char *v43; // r0@69
  bool v44; // zf@69
  char *v45; // r1@69
  char *v46; // r0@69
  char *v47; // r1@74
  char *v48; // r7@77
  signed int v49; // r5@77
  int v50; // r0@82
  const char *v51; // r0@82
  void *v52; // r0@84
  void *v53; // r0@84
  void *v54; // r0@84
  void *v55; // r0@84
  void *v56; // r0@84
  int v57; // r0@84
  int v58; // r0@85
  void *v59; // r0@87
  void *v60; // r0@92
  void *v61; // r0@92
  char v62; // [sp+1Ch] [bp-4DCh]@5
  char v63; // [sp+21h] [bp-4D7h]@71
  char v64; // [sp+26h] [bp-4D2h]@76
  char v65; // [sp+2Bh] [bp-4CDh]@76
  char v66; // [sp+21Ch] [bp-2DCh]@58
  int v67; // [sp+41Ch] [bp-DCh]@34
  char v68; // [sp+49Ch] [bp-5Ch]@66
  char v69; // [sp+4B0h] [bp-48h]@63
  char v70; // [sp+4C4h] [bp-34h]@63

  v1 = a1;
  print_file("/home/httpd/js/natrouterconf_portforward_v2.lang.js");
  print_file("/home/httpd/js/natrouterconf_portforward_v2.js");
  sub_2F7B4();
  puts("<script language=JavaScript>");
  puts("function SelectServer()");
  puts("{");
  puts("\tvar F = document.portforward_fm;");
  puts("\tButtonViewControl('modify', document);");
  puts("\t\tF.protocol.value = 'tcp';");
  puts("\t\tF.ext_sport.value = '';\tF.ext_eport.value='';");
  puts("\t\tF.int_sport.value = '';\tF.int_eport.value='';");
  puts("\t\tF.trigger_sport.value = '';\tF.trigger_eport.value='';");
  puts("\t\tF.forward_ports.value = '';");
  puts("\tif(F.sel_server.value == '0') {");
  puts("\tChangeInputForm('user',document);");
  puts("\t\tEnableObj_For_PF(F.protocol);\tEnableObj_For_PF(F.int_sport);\tEnableObj_For_PF(F.int_eport);");
  puts("\t}");
  v2 = fopen("/var/virtsvr_rule", "r");
  if ( v2 )
  {
    v3 = 1;
    v4 = 0;
    while ( 1 )
    {
      v17 = (char *)feof(v2);
      if ( v17 || v3 == 11 )
        break;
      memset(&v62, 0, 0x200u);
      fgets(&v62, 512, v2);
      v5 = strtok(&v62, ":");
      v6 = v5;
      if ( v5 )
      {
        printf("\telse if(F.sel_server.value == '%s') {\n", v5);
        puts("\tChangeInputForm('user',document);");
        puts("\t\tF.int_eport.value='';");
        if ( !strcmp(v6, "pptp") )
        {
          puts("\t\tF.protocol.value = 'tcp';");
          puts("\t\tF.ext_sport.value = '1723';\tF.ext_eport.value='';");
          puts("\t\tF.int_sport.value = '1723';\tF.int_eport.value='';");
          puts("\t\tEnableObj_For_PF(F.protocol);\tEnableObj_For_PF(F.int_sport);\tEnableObj_For_PF(F.int_eport);");
        }
        else
        {
          strtok(v17, ":");
          v7 = strtok(v17, ":");
          v8 = atoi(v7);
          strtok(v17, ":");
          strtok(v17, ":");
          strtok(v17, ":");
          v9 = strtok(v17, ":");
          if ( v8 <= 1 )
          {
            printf("\t\tF.protocol.value = '%s';\n", v9);
            v10 = "\t\tEnableObj_For_PF(F.protocol);";
          }
          else
          {
            v10 = "\t\tDisableObj_For_PF(F.protocol);";
          }
          printf(v10, v9);
          strtok(0, ":");
          v11 = strtok(0, ":");
          v12 = v11;
          if ( v8 <= 1 )
          {
            if ( v11 )
            {
              v4 = strchr(v11, 45);
              if ( v4 )
                v14 = 0;
              if ( v4 )
                *v4 = v14;
              printf("\t\tF.int_sport.value = '%s';\n", v12);
            }
            if ( v4 )
              printf("\t\tF.int_eport.value = '%s';\n", v12);
            printf("\t\tEnableObj_For_PF(F.int_sport);");
            v13 = "\t\tEnableObj_For_PF(F.int_eport);";
          }
          else
          {
            puts("\t\tF.int_sport.value = '';");
            puts("\t\tF.int_eport.value = '';");
            printf("\t\tDisableObj_For_PF(F.int_sport);");
            v13 = "\t\tDisableObj_For_PF(F.int_eport);";
          }
          printf(v13);
          strtok(0, ":");
          v15 = strtok(0, ":");
          if ( v8 <= 1 )
          {
            printf("\t\tF.ext_sport.value = '%s';\n", v15);
            puts("\t\tF.ext_eport.value = '';");
            printf("\t\tEnableObj_For_PF(F.ext_sport);");
            v16 = "\t\tEnableObj_For_PF(F.ext_eport);";
          }
          else
          {
            puts("\t\tF.ext_sport.value = '';");
            puts("\t\tF.ext_eport.value = '';");
            printf("\t\tDisableObj_For_PF(F.ext_sport);");
            v16 = "\t\tDisableObj_For_PF(F.ext_eport);";
          }
          printf(v16);
        }
        ++v3;
        puts("\t}");
      }
    }
    fclose(v2);
  }
  puts("\telse if(F.sel_server.value == 'NULL') {");
  puts("\tChangeInputForm('user',document);");
  puts("\t\tF.protocol.value = 'tcp';");
  puts("\t\tF.ext_sport.value = '';\tF.ext_eport.value='';");
  puts("\t\tF.int_sport.value = '';\tF.int_eport.value='';");
  puts("\t\tEnableObj_For_PF(F.protocol);\tEnableObj_For_PF(F.int_sport);\tEnableObj_For_PF(F.int_eport);");
  puts("\t}");
  puts("\telse if(F.sel_server.value == 'trigger') {");
  puts("\tChangeInputForm('trigger',document);");
  puts("\t\tF.protocol.value = 'tcp';");
  puts("\t\tF.ext_sport.value = '';\tF.ext_eport.value='';");
  puts("\t\tF.int_sport.value = '';\tF.int_eport.value='';");
  puts("\t\tEnableObj_For_PF(F.protocol);\tEnableObj_For_PF(F.int_sport);\tEnableObj_For_PF(F.int_eport);");
  puts("\t}");
  puts("}");
  puts("</script>");
  printf("<table class=v3_table>");
  printf("<form method=get action=\"timepro.cgi\" name=\"portforward_fm\">");
  printf("<input type=hidden name=\"tmenu\" value=\"natrouterconf\">");
  printf("<input type=hidden name=\"smenu\" value=\"portforward\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"clicked_name\" value=\"\">");
  printf("<input type=hidden name=\"clicked_bg\" value=\"\">");
  printf("<input type=hidden name=\"old_priority\" value=\"\">");
  printf("<input type=hidden name=\"cur_priority\" value=\"\">");
  printf("<input type=hidden name=\"rule_count\" value=\"0\">");
  printf("<tr class=\"pf_tr\"><td colspan=2 width=100%% class=\"pf_td\" style=\"vertical-align:top;\">");
  if ( v1 )
  {
    v18 = (const char *)get_pvalue(v1, "mode");
    v19 = (char *)v18;
    if ( !v18 || !strcmp(v18, "user") )
      goto LABEL_34;
    if ( !strcmp(v19, "all") )
    {
      puts("<input type=\"hidden\" name=\"mode\" value=\"all\">");
      printf("<TABLE width=100%% class=\"pf_table\">");
      printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
      printf("<TR height=\"24\" class=\"pf_tr\">");
      printf("<TD class=\"pf_td\"><P align=\"center\" class=\"pf_p\">%s</P></TD>\n", "순위");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "사용자 규칙");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 IP");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "외부 포트");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 포트");
      v25 = sub_16094();
      printf(
        "<TD class=\"pf_td\"><P align=\"right\" class=\"pf_p\" style=\"margin:0; padding-right:17px;\">\t\t\t<a class=\"p"
        "f_a\" style=\"cursor:pointer; padding-bottom:3px;\" onclick=\"onDeleteClicked('user');\">\t\t\t<img src=\"/%s/mi"
        "nus_icon.gif\">%s</a>&nbsp;<input type=\"checkbox\" name=\"alldel_user\" \t\t\tonclick=\"onAllDeleteChecked('use"
        "r',document,this.checked);\"></P></TD>\n",
        v25,
        "삭제");
      printf("</TR>");
      printf("<TR style=\"border-collapse:collapse; position:relative; border-top:1px rgba(128,128,128,0.3); solid !important;\t\t\tborder-bottom:1px rgba(128,128,128,0.3); solid !important;\">");
      printf("<TD colspan=\"6\" width=\"100%%\" height=\"216\" class=\"pf_td\">");
      v26 = snprintf((char *)&v67, 0x80u, "timepro.cgi?tmenu=iframe&smenu=user_portforward&mode=all");
      if ( is_mobile_agent(v26) )
      {
        sub_1682C((int)"216", (int)"100%", (int)&unk_6C6FA);
        v27 = printf(
                "<iframe name=\"user_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scroll"
                "ing=yes>\t\t\t\t</iframe>",
                &v67);
        sub_16878(v27);
      }
      else
      {
        printf(
          "<iframe name=\"user_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrolling=ye"
          "s>\t\t\t\t</iframe>",
          &v67);
      }
      printf("</TD></TR>");
      v20 = &v67;
      printf("<TR height=\"24\" class=\"pf_tr\">");
      printf("<TD class=\"pf_td\"><P align=\"center\" class=\"pf_p\">%s</P></TD>\n", "순위");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "UPNP 규칙");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 IP");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "외부 포트");
      puts("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\"></P></TD>");
      v28 = sub_16094();
      printf(
        "<TD class=\"pf_td\"><P align=\"right\" class=\"pf_p\" style=\"margin:0; padding-right:17px;\">\t\t\t<a class=\"p"
        "f_a\" style=\"cursor:pointer; padding-bottom:3px;\" onclick=\"onDeleteClicked('upnp');\">\t\t\t<img src=\"/%s/mi"
        "nus_icon.gif\">%s</a>&nbsp;<input type=\"checkbox\" name=\"alldel_upnp\" \t\t\tonclick=\"onAllDeleteChecked('upn"
        "p',document,this.checked);\"></P></TD>\n",
        v28,
        "삭제");
      printf("</TR>");
      printf("<TR style=\"border-collapse:collapse; position:relative; border-top:1px rgba(128,128,128,0.3); solid !important;\t\t\tborder-bottom:1px rgba(128,128,128,0.3); solid !important;\">");
      printf("<TD colspan=\"6\" width=\"100%%\" height=\"144\" class=\"pf_td\">");
      v29 = snprintf((char *)&v67, 0x80u, "timepro.cgi?tmenu=iframe&smenu=upnp_portforward&mode=all");
      if ( is_mobile_agent(v29) )
      {
        v30 = "144";
LABEL_47:
        sub_1682C((int)v30, (int)"100%", (int)&unk_6C6FA);
        v24 = (const char *)&unk_6CA43;
        goto LABEL_53;
      }
    }
    else
    {
      if ( strcmp(v19, "upnp") )
      {
        result = strcmp(v19, "trigger_status");
        if ( result )
          return result;
        puts("<input type=\"hidden\" name=\"mode\" value=\"trigger_status\">");
        v20 = &v67;
        printf("<TABLE width=100%% class=\"pf_table\">");
        printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
        printf("<TR height=\"24\" class=\"pf_tr\">");
        printf("<TD class=\"pf_td\"><P align=\"center\" class=\"pf_p\">%s</P></TD>\n", "순위");
        printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "트리거 규칙");
        printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 IP");
        printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "트리거 포트");
        printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "포워드 포트");
        puts("<TD class=\"pf_td\"><P align=\"right\" class=\"pf_p\" style=\"margin:0; padding-right:17px;\"></P></TD>");
        printf("</TR>");
        printf("<TR style=\"border-collapse:collapse; position:relative; border-top:1px rgba(128,128,128,0.3); solid !important;\t\t\tborder-bottom:1px rgba(128,128,128,0.3); solid !important;\">");
        printf("<TD colspan=\"6\" width=\"100%%\" height=\"384\" class=\"pf_td\">");
        v34 = snprintf((char *)&v67, 0x80u, (const char *)&unk_6CC01);
        if ( !is_mobile_agent(v34) )
        {
          v23 = "<iframe name=\"trigger_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scr"
                "olling=yes>\t\t\t\t</iframe>";
          goto LABEL_54;
        }
        sub_1682C((int)"384", (int)"100%", (int)&unk_6C6FA);
        v24 = "<iframe name=\"trigger_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrol"
              "ling=yes>\t\t\t\t</iframe>";
        goto LABEL_53;
      }
      puts("<input type=\"hidden\" name=\"mode\" value=\"upnp\">");
      v20 = &v67;
      printf("<TABLE width=100%% class=\"pf_table\">");
      printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
      printf("<TR height=\"24\" class=\"pf_tr\">");
      printf("<TD class=\"pf_td\"><P align=\"center\" class=\"pf_p\">%s</P></TD>\n", "순위");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "사용자 규칙");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 IP");
      printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "외부 포트");
      puts("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\"></P></TD>");
      v31 = sub_16094();
      printf(
        "<TD class=\"pf_td\"><P align=\"right\" class=\"pf_p\" style=\"margin:0; padding-right:17px;\">\t\t\t<a class=\"p"
        "f_a\" style=\"cursor:pointer; padding-bottom:3px;\" onclick=\"onDeleteClicked('upnp');\">\t\t\t<img src=\"/%s/mi"
        "nus_icon.gif\">%s</a>&nbsp;<input type=\"checkbox\" name=\"alldel_upnp\" \t\t\tonclick=\"onAllDeleteChecked('upn"
        "p',document,this.checked);\"></P></TD>\n",
        v31,
        "삭제");
      printf("</TR>");
      printf("<TR style=\"border-collapse:collapse; position:relative; border-top:1px rgba(128,128,128,0.3); solid !important;\t\t\tborder-bottom:1px rgba(128,128,128,0.3); solid !important;\">");
      printf("<TD colspan=\"6\" width=\"100%%\" height=\"384\" class=\"pf_td\">");
      v32 = snprintf((char *)&v67, 0x80u, (const char *)&unk_6CAEC);
      if ( is_mobile_agent(v32) )
      {
        v30 = "384";
        goto LABEL_47;
      }
    }
    v23 = (const char *)&unk_6CA43;
    goto LABEL_54;
  }
  v19 = 0;
LABEL_34:
  puts("<input type=\"hidden\" name=\"mode\" value=\"user\">");
  v20 = &v67;
  printf("<TABLE width=100%% class=\"pf_table\">");
  printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
  printf("<TR height=\"24\" class=\"pf_tr\">");
  printf("<TD class=\"pf_td\"><P align=\"center\" class=\"pf_p\">%s</P></TD>\n", "순위");
  printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "사용자 규칙");
  printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 IP");
  printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "외부 포트");
  printf("<TD class=\"pf_td\"><P align=\"left\" class=\"pf_p\">%s</P></TD>\n", "내부 포트");
  v21 = sub_16094();
  printf(
    "<TD class=\"pf_td\"><P align=\"right\" class=\"pf_p\" style=\"margin:0; padding-right:17px;\">\t\t\t<a class=\"pf_a\""
    " style=\"cursor:pointer; padding-bottom:3px;\" onclick=\"onDeleteClicked('user');\">\t\t\t<img src=\"/%s/minus_icon."
    "gif\">%s</a>&nbsp;<input type=\"checkbox\" name=\"alldel_user\" \t\t\tonclick=\"onAllDeleteChecked('user',document,t"
    "his.checked);\"></P></TD>\n",
    v21,
    "삭제");
  printf("</TR>");
  printf("<TR style=\"border-collapse:collapse; position:relative; border-top:1px rgba(128,128,128,0.3); solid !important;\t\t\tborder-bottom:1px rgba(128,128,128,0.3); solid !important;\">");
  printf("<TD colspan=\"6\" width=\"100%%\" height=\"384\" class=\"pf_td\">");
  v22 = snprintf((char *)&v67, 0x80u, (const char *)&unk_6C6BC);
  if ( !is_mobile_agent(v22) )
  {
    v23 = "<iframe name=\"user_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrolling=ye"
          "s>\t\t\t\t</iframe>";
LABEL_54:
    printf(v23, v20);
    goto LABEL_55;
  }
  sub_1682C((int)"384", (int)"100%", (int)&unk_6C6FA);
  v24 = "<iframe name=\"user_portforward\" src=\"%s\" frameborder=no width=100%% height=100%% align=center scrolling=yes>"
        "\t\t\t\t</iframe>";
LABEL_53:
  v35 = printf(v24, v20);
  sub_16878(v35);
LABEL_55:
  printf((const char *)&unk_5C75F);
  printf("</td></tr>");
  puts("<tr height=\"100\" class=\"pf_tr\" style=\"background-Color:#eeeeee;\">");
  printf("<td width=572 class=\"pf_td\">");
  printf("<TABLE width=572 class=\"pf_table\">");
  puts("<TR id=\"form_line_1\" height=\"24\" class=\"pf_tr\">");
  puts("<TD width=\"10\" align=\"center\" class=\"pf_td\">");
  v36 = sub_16094();
  printf("<img src=\"/%s/pf_square_icon.gif\"></TD>\n", v36);
  printf("<TD width=\"70\" class=\"pf_td\">");
  printf("<span class=\"pf_span\">%s</span></TD>", "규칙이름");
  printf("<TD width=\"155\" align=\"left\" class=\"pf_td\">");
  printf("<input type=\"text\" name=\"rule_name\" size=\"21\" style=\"width:145px;\" maxlength=\"127\" class=\"pf_textbox\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\">");
  printf("</TD><TD width=\"160\" align=\"left\" class=\"pf_td\" id=\"SELMENUBOXTD\">");
  printf("<select name=\"sel_server\" class=\"pf_select\" style=\"width:160px;\" onchange=\"SelectServer();\">");
  printf("<option value=\"0\">%s</option>", "포트포워드 사용자정의");
  v37 = fopen("/var/virtsvr_rule", "r");
  if ( v37 )
  {
    v19 = 0;
    v38 = 0;
    while ( !feof(v37) )
    {
      memset(&v66, 0, 0x200u);
      fgets(&v66, 512, v37);
      v39 = strtok(&v66, ":");
      v19 = v39;
      if ( v39 )
      {
        if ( v38 == 10 )
          break;
        printf("<option value=\"%s\">", v39);
        ++v38;
        v19 = strtok(0, ":");
        printf("%s</option>", v19);
      }
    }
    fclose(v37);
  }
  printf("<option value=\"NULL\">---------------------------</option>");
  printf("<option value=\"trigger\">%s</option>", "포트트리거 사용자정의");
  printf("</select>");
  printf("</TD><TD width=\"172\" class=\"pf_td\" align=\"left\" id=\"DISABLEBOXTD\">");
  printf("<SPAN class=\"pf_span\">");
  printf(
    "<input type=\"checkbox\" class=\"pf_checkbox\" name=\"disable\" id=\"disable_id\" onclick=\"onCheckedDisable();\">\n"
    "\t\t<label for=\"disable_id\">%s</label>\n",
    &unk_6D12D);
  printf("</SPAN>");
  printf("</TD></TR>");
  puts("<TR id=\"form_line_2\" height=\"24\" class=\"pf_tr\">");
  puts("<TD width=\"10\" align=\"center\" class=\"pf_td\">");
  v40 = sub_16094();
  printf("<img src=\"/%s/pf_square_icon.gif\"></TD>\n", v40);
  printf("<TD width=\"70\" class=\"pf_td\">");
  printf("<span class=\"pf_span\">%s</span></TD>", "내부 IP주소");
  printf("<TD width=\"155\" align=\"left\" class=\"pf_td\">");
  get_ifconfig("br0", &v70, &v69);
  if ( v70 )
    v41 = &v70;
  else
    v41 = "";
  sf_strncpy(&v68, v41, 20);
  if ( v68 )
  {
    v42 = strtok(&v68, ".");
    if ( !v42 )
      v42 = "0";
    sf_strncpy(&v62, v42, 5);
    v43 = strtok(0, ".");
    v45 = v43;
    v44 = v43 == 0;
    v46 = &v62;
    if ( v44 )
      v45 = "0";
    else
      v46 = &v63;
    if ( v44 )
      v46 += 5;
    sf_strncpy(v46, v45, 5);
    v47 = strtok(0, ".");
    if ( !v47 )
      v47 = "0";
    sf_strncpy(&v64, v47, 5);
    sf_strncpy(&v65, &unk_6AE5B, 5);
  }
  else
  {
    v65 = 0;
    v64 = 0;
    v63 = 0;
    v62 = 0;
  }
  v48 = &v62;
  v49 = 1;
  do
  {
    printf(
      "<input type=text name=\"%s%d\" maxlength=3 size=3 style=\"width:34px; ime-mode:disabled;\" class=\"pf_textbox\" va"
      "lue=\"%s\" onfocus=\"this.select();\" onkeypress=\"return IPKeyDown('%s', %d);\" title=\"%s%d\" onkeydown=\"Button"
      "ViewControl('modify'); return true;\" onkeyup=\"IPKeyUp('%s',%d);\">",
      "internal_ip",
      v49,
      v48,
      "internal_ip",
      v49,
      "IP 주소",
      v49,
      "internal_ip",
      v49);
    if ( v49 != 4 )
      putchar(46);
    ++v49;
    v48 += 5;
  }
  while ( v49 != 5 );
  printf("</TD>");
  printf("<TD width=\"332\" colspan=\"2\" class=\"pf_td\" id=\"CURCONNBOXTD\">");
  v50 = printf("<SPAN class=\"pf_span\">");
  v51 = (const char *)get_remote_addr(v50);
  snprintf(&v70, 0x14u, v51);
  if ( strcmp(&v70, "Twin IP") )
    printf(
      "<input type=\"checkbox\" class=\"pf_checkbox\" name=\"re_ip\" id=\"re_ip_id\" onclick=\"onCheckedReip(this,'intern"
      "al_ip','%s');\">\n"
      "\t\t\t<label for=\"re_ip_id\">%s</label>\n",
      &v70,
      "현재 접속된 IP 주소");
  printf("</SPAN>");
  printf("</TD>");
  printf("</TR>");
  puts("<TR id=\"form_line_3\" height=\"24\" class=\"pf_tr\">");
  puts("<TD width=\"10\" align=\"center\" class=\"pf_td\">");
  v52 = sub_16094();
  printf("<img src=\"/%s/pf_square_icon.gif\"></TD>\n", v52);
  printf("<TD width=\"70\" class=\"pf_td\">");
  printf("<span class=\"pf_span\">%s</span></TD>", "프로토콜");
  printf("<TD width=\"487\" colspan=\"3\" align=\"left\" class=\"pf_td\">");
  printf("<SPAN class=\"pf_span\" width=\"80\">");
  printf("<select class=\"pf_select\" name=\"protocol\" style=\"width:80px;\" onchange=\"onChangeProtocol(document);\">");
  printf("<option value=\"tcp\">TCP</option>");
  printf("<option value=\"udp\">UDP</option>");
  printf("<option value=\"tcpudp\">TCP/UDP</option>");
  printf("<option value=\"gre\">GRE</option>");
  printf("</select>");
  printf("</SPAN>");
  printf("<SPAN class=\"pf_span\" width=\"146\">");
  printf("<SPAN class=\"pf_span\" style=\"padding:0px 5px 0px 5px;\">%s</SPAN>", "외부 포트");
  printf("<input type=\"text\" name=\"ext_sport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\"> ~ ");
  printf("<input type=\"text\" name=\"ext_eport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\">");
  printf("</SPAN>");
  printf("<SPAN class=\"pf_span\" width=\"146\" id=\"INTPORTBOX\">");
  printf("<SPAN class=\"pf_span\" style=\"padding:0px 5px 0px 5px;\">%s</SPAN>", "내부 포트");
  printf("<input type=\"text\" name=\"int_sport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\"> ~ ");
  printf("<input type=\"text\" name=\"int_eport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\">");
  printf("</SPAN>");
  printf("</TD>");
  printf("</TR>");
  puts("<TR id=\"form_line_trigger1\" height=\"24\" class=\"pf_tr\" style=\"display:none;\">");
  puts("<TD width=\"10\" align=\"center\" class=\"pf_td\">");
  v53 = sub_16094();
  printf("<img src=\"/%s/pf_square_icon.gif\"></TD>\n", v53);
  printf("<TD width=\"70\" class=\"pf_td\">");
  printf("<span class=\"pf_span\">%s</span></TD>", "트리거 조건");
  printf("<TD width=\"155\" align=\"left\" class=\"pf_td\">");
  printf("<select class=\"pf_select\" name=\"trigger_protocol\" style=\"width:80px;\" onchange=\"ButtonViewControl('modify');\">");
  printf("<option value=\"tcp\">TCP</option>");
  printf("<option value=\"udp\">UDP</option>");
  printf("</select>");
  printf("</TD>");
  printf("<TD width=\"332\" colspan=\"2\" class=\"pf_td\" align=\"left\">");
  printf("<SPAN class=\"pf_span\">");
  printf("<SPAN class=\"pf_span\" style=\"padding-right:5px;\">%s</SPAN>", "포트범위");
  printf("<input type=\"text\" name=\"trigger_sport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\"> ~ ");
  printf("<input type=\"text\" name=\"trigger_eport\" class=\"pf_textbox\" size=5 maxlength=5 style=\"width:42px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\">");
  printf("</SPAN>");
  printf("</TD>");
  printf("</TR>");
  puts("<TR id=\"form_line_trigger2\" height=\"24\" class=\"pf_tr\" style=\"display:none;\">");
  puts("<TD width=\"10\" align=\"center\" class=\"pf_td\">");
  v54 = sub_16094();
  printf("<img src=\"/%s/pf_square_icon.gif\"></TD>\n", v54);
  printf("<TD width=\"70\" class=\"pf_td\">");
  printf("<span class=\"pf_span\">%s</span></TD>", "포트포워드");
  printf("<TD width=\"155\" align=\"left\" class=\"pf_td\">");
  printf("<select class=\"pf_select\" name=\"forward_protocol\" style=\"width:80px;\" onchange=\"ButtonViewControl('modify');\">");
  printf("<option value=\"tcp\">TCP</option>");
  printf("<option value=\"udp\">UDP</option>");
  printf("</select>");
  printf("</TD>");
  printf("<TD width=\"332\" colspan=\"2\" class=\"pf_td\" align=\"left\">");
  printf("<SPAN class=\"pf_span\" style=\"padding-right:5px;\">%s</SPAN>", "포트범위");
  printf("<input type=\"text\" name=\"forward_ports\" class=\"pf_textbox\" size=26 maxlength=127 style=\"width:160px;\" \t\tonkeydown=\"ButtonViewControl('modify'); return true;\">");
  printf("</TD>");
  printf("</TR>");
  printf("</TABLE>");
  printf("</td>");
  puts("<td width=\"70\" align=\"right\" height=\"100\" class=\"pf_td\" id=\"PRIORITYBOX\">");
  puts("<TABLE class=\"pf_table\" style=\"width:70px;\">");
  printf("<TR class=\"pf_tr\" style=\"height:24px;\">");
  puts("<TD class=\"pf_td\" align=\"right\">");
  puts("<SPAN class=\"pf_span\">");
  printf(
    "%s <input type=\"text\" name=\"priority\" class=\"pf_textbox\"                 size=3 maxlength=3 style=\"width:37px"
    ";\" onchange=\"onChangedPriority(%d);\">",
    "순위",
    100);
  puts("</SPAN>");
  printf("</TD>");
  printf("</TR>");
  printf("<TR class=\"pf_tr\" style=\"height:24px;\">");
  puts("<TD class=\"pf_td\" align=\"right\">");
  printf("<button type=\"button\" name=\"pri_up\" class=\"pf_button\" style=\"width:70px;\" onclick=\"onRowUpClicked();\">");
  v55 = sub_16094();
  printf("<img src=\"/%s/fw_up.gif\">%s</button>", v55, "순위높임");
  printf("</TD>");
  printf("</TR>");
  printf("<TR class=\"pf_tr\" style=\"height:24px;\">");
  puts("<TD class=\"pf_td\" align=\"right\">");
  printf("<button type=\"button\" name=\"pri_down\" class=\"pf_button\" style=\"width:70px;\" onclick=\"onRowDownClicked();\">");
  v56 = sub_16094();
  printf("<img src=\"/%s/fw_down.gif\">%s</button>", v56, "순위낮춤");
  printf("</TD>");
  printf("</TR>");
  printf("<TR class=\"pf_tr\" style=\"height:24px;\">");
  puts("<TD class=\"pf_td\" align=\"right\">");
  printf("&nbsp;");
  printf("</TD>");
  printf("</TR>");
  printf("</TABLE>");
  printf("</td></tr>");
  puts("<tr id=\"form_line_5\" height=\"26\" class=\"pf_tr\">");
  puts("<td colspan=2 class=\"pf_td\" align=\"center\">");
  printf("<TABLE class=\"pf_table\" width=\"100%%\">\n");
  puts("<TD class=\"pf_td\" width=\"466\">");
  v57 = snprintf((char *)&v67, 0x100u, (const char *)&unk_6DF00);
  if ( is_mobile_agent(v57) )
  {
    sub_1682C((int)"26", (int)"466", (int)"display:inline-block; vertical-align:middle;");
    v58 = printf(
            "<iframe name=\"restore_iframe\" src=\"%s\" frameborder=no width=466 height=26 align=center scrolling=no></iframe>",
            &v67);
    sub_16878(v58);
  }
  else
  {
    printf(
      "<iframe name=\"restore_iframe\" src=\"%s\" frameborder=no width=466 height=26 align=center scrolling=no></iframe>",
      &v67);
  }
  puts("</TD>");
  puts("<TD class=\"pf_td\" align=\"right\" style=\"padding-right:5px;\">");
  puts("<button type=\"button\" class=\"pf_button\" name=\"new_rule_btn\" style=\"width:65px;\" onclick=\"onNewRuleBtnClicked();\">");
  v59 = sub_16094();
  printf("<img src=\"/%s/pf_plus_icon.gif\"> %s\n", v59, "새규칙");
  puts("</button>");
  memset(&v70, 0, 0x14u);
  get_ifconfig("br0", &v70, &v69);
  printf(
    "<button type=\"button\" class=\"pf_button\" name=\"apply_btn\" style=\"width:45px;\" onclick=\"onApplyBtnClicked('%s"
    "','%s',%d);\">\n",
    &v70,
    &v69,
    100);
  puts("적용");
  puts("</button>");
  puts("<button type=\"button\" class=\"pf_button\" name=\"cancel_btn\" style=\"width:45px;\" onclick=\"onCancelBtnClicked();\">");
  puts("취소");
  puts("</button>");
  puts("</TD>");
  puts("</TABLE>");
  puts("</td>");
  puts("</tr>");
  puts("<tr id=\"form_line_blank\" height=\"26\" class=\"pf_tr\" style=\"display:none;\">");
  puts("<td colspan=2 class=\"pf_td\" align=\"center\">");
  printf("</td></tr>");
  printf("</form>");
  puts("</table>");
  if ( v1 )
    v19 = (char *)get_pvalue(v1, "mode");
  if ( v19 )
  {
    if ( !strcmp(v19, "upnp") )
    {
      printf("<SCRIPT>");
      printf("var obj = parent.frames[3].document.getElementById('pf_select_menu');");
      printf("if(obj){");
      printf("obj.value = 'upnp';");
      putchar(125);
      printf("</SCRIPT>");
    }
  }
  printf(
    "<DIV ID=\"%s\" style=\"position:absolute; left:%dpx; top:%dpx; width:%dpx; height:%dpx; z-index:1; background-color:"
    "#ffffff;                 opacity:1.0; display:none;\">\n",
    "restore_mask");
  printf("<table width=\"%d\" height=\"%d\">\n", 642, 536);
  printf("<tr><td width=\"100%%\" height=\"100%%\" align=\"center\" valign=\"middle\">\n");
  puts("<SPAN style=\"height:30px; vertical-align:middle; display:block; text-align:center;\">");
  v60 = sub_16094();
  printf(
    "<img src=\"/%s/apply_ani.gif\" style=\"display:inline-block; vertical-align:middle;\">%s",
    v60,
    "포트포워딩 규칙을 복원중입니다.");
  printf("</SPAN></td></tr></table></DIV>");
  printf(
    "<DIV ID=\"%s\" style=\"position:absolute; left:%dpx; top:%dpx; width:%dpx; height:%dpx; z-index:1; background-color:"
    "#ffffff;                 opacity:1.0; display:none;\">\n",
    "apply_mask");
  printf("<table width=\"%d\" height=\"%d\">\n", 642, 536);
  printf("<tr><td width=\"100%%\" height=\"100%%\" align=\"center\" valign=\"middle\">\n");
  puts("<SPAN style=\"height:30px; vertical-align:middle; display:block; text-align:center;\">");
  v61 = sub_16094();
  printf("<img src=\"/%s/apply_ani.gif\" style=\"display:inline-block; vertical-align:middle;\">", v61);
  return printf("</SPAN></td></tr></table></DIV>");
}
// 10148: using guessed type int __fastcall get_remote_addr(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 11324: using guessed type int __fastcall is_mobile_agent(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (000327D0) --------------------------------------------------------
int __fastcall sub_327D0(int a1, int a2)
{
  int v2; // r4@1
  int result; // r0@1
  const char *v4; // r0@3
  const char *v5; // r1@3
  int v6; // r0@5
  int v7; // r0@5
  int v8; // [sp+0h] [bp-88h]@1

  v2 = a2;
  printf("<BODY style=\"height:26px; display:block; vertical-align:middle; padding:0 0 0 0; margin:0 0 0 0; border:0 0 0 0; overflow:hidden;\">");
  printf("<form action=\"timepro.cgi\" method=\"post\" name=\"portforward_file_fm\" enctype=\"multipart/form-data\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"restore_portforward\">");
  printf("<input type=\"hidden\" name=\"commit\" value=\"pf_restore\">");
  printf("<table class=v3_table width=100%% height=26 style=\"vertical-align:middle; padding:0 0 0 0; margin:0 0 0 0;\">");
  printf("<tr style=\"vertical-align:middle;\" height=24><td width=94>");
  printf(
    "<input type=button name=\"saverulebtn\" value=\"%s\" onclick=\"self.location.href='download_portforward.cgi'\" ",
    "PC<-규칙저장");
  printf("style=\"width:94px; font-size:12px; padding:1 0 1 0; margin:0 0 0 5; text-align:center;\"></td>");
  printf("<td width=94><input type=button value=\"%s\" onclick=\"parent.Portforward_Restore();\" ", "PC->규칙복원");
  printf("style=\"width:94px; font-size:12px; padding:1 0 1 0; margin:0 0 0 5; text-align:center;\"></td>");
  printf("<td><input type=file name=\"pf_restore_file\" maxlength=100 style=\"padding:1 0 1 0; margin:0 0 0 5;\"></td>");
  printf((const char *)&unk_6E88F);
  printf("</BODY>");
  result = get_value_post_multipart(v2, "commit", &v8, 128);
  if ( result )
  {
    printf("<script>");
    if ( portforward_update_by_file("/tmp/user_pf.set.tmp", "user_pf") == -1 )
    {
      v4 = "alert('%s');";
      v5 = "규칙 복원에 실패하였습니다.";
    }
    else
    {
      v4 = "alert('%s');";
      v5 = "규칙 복원에 성공하였습니다.";
    }
    printf(v4, v5);
    printf("parent.UnMaskIt(parent.document,'restore_mask');");
    printf("parent.onChangedPFView(parent.parent.frames[3].document.getElementById('pf_select_menu').value);");
    printf("parent.onLoadCompleted(parent.document);");
    v6 = printf("</script>");
    v7 = signal_update(v6);
    result = signal_save(v7);
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108C8: using guessed type int __fastcall portforward_update_by_file(_DWORD, _DWORD);
// 10DD8: using guessed type int __fastcall get_value_post_multipart(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00032934) --------------------------------------------------------
int __fastcall sub_32934(int a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r8@1
  const char *v4; // r4@1
  signed int v5; // r10@4
  int v6; // r6@6
  int v7; // r5@6
  int v8; // r7@10
  int v9; // r6@14
  int v10; // r7@14
  int result; // r0@18
  int v12; // r5@18
  int i; // r6@19
  int v14; // r7@24
  int v15; // r6@28
  int v16; // r7@28
  int v17; // r5@32
  signed int j; // r3@32
  const char *v19; // r0@40
  const char *v20; // r1@40
  bool v21; // nf@41
  unsigned __int8 v22; // vf@41
  int v23; // r3@48
  int v24; // r0@48
  int v25; // r1@48
  int v26; // ST00_4@48
  int v27; // ST04_4@48
  int v28; // r4@49
  signed int v29; // r6@49
  int v30; // r7@49
  int v31; // r3@50
  int v32; // t1@50
  const char *v33; // r2@53
  const char *v34; // r0@56
  char v35; // [sp+24h] [bp-26Ch]@49
  char v36; // [sp+224h] [bp-6Ch]@37
  char s; // [sp+244h] [bp-4Ch]@2
  char v38; // [sp+263h] [bp-2Dh]@3
  int v39; // [sp+264h] [bp-2Ch]@1
  int v40; // [sp+268h] [bp-28h]@1
  unsigned int v41; // [sp+26Ch] [bp-24h]@1

  v2 = a1;
  v3 = a2;
  v41 = 0;
  v39 = 0;
  v40 = 0;
  print_file("/home/httpd/js/natrouterconf_portforward_v2.lang.js");
  print_file("/home/httpd/js/natrouterconf_portforward_v2.js");
  sub_2F7B4();
  v4 = (const char *)get_pvalue(v2, "mode");
  if ( !v4 )
  {
    memset(&s, 0, 0x20u);
    if ( sub_306AC(v3, "view_mode", (int)&s, 32) )
    {
      v38 = (char)v4;
      v4 = &s;
    }
  }
  printf("<BODY style=\"padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;\">");
  printf("<form method=post action=\"timepro.cgi\" name=\"user_portforward_fm\" style=\"margin:0px 0px 0px 0px; padding:0px 0px 0px 0px;\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"user_portforward\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"view_mode\" value=\"%s\">");
  printf("<input type=hidden name=\"mode\" value=\"\">");
  printf("<input type=hidden name=\"name\" value=\"\">");
  printf("<input type=hidden name=\"int_sport\" value=\"\">");
  printf("<input type=hidden name=\"int_eport\" value=\"\">");
  printf("<input type=hidden name=\"ext_sport\" value=\"\">");
  printf("<input type=hidden name=\"ext_eport\" value=\"\">");
  printf("<input type=hidden name=\"trigger_protocol\" value=\"\">");
  printf("<input type=hidden name=\"trigger_sport\" value=\"\">");
  printf("<input type=hidden name=\"trigger_eport\" value=\"\">");
  printf("<input type=hidden name=\"forward_ports\" value=\"\">");
  printf("<input type=hidden name=\"forward_protocol\" value=\"\">");
  printf("<input type=hidden name=\"internal_ip\" value=\"\">");
  printf("<input type=hidden name=\"protocol\" value=\"\">");
  printf("<input type=hidden name=\"disabled\" value=\"\">");
  printf("<input type=hidden name=\"priority\" value=\"\">");
  printf("<input type=hidden name=\"old_priority\" value=\"\">");
  printf("<table style=\"table-layout:fixed; border-collapse:collapse; border-style:none none none none; width:100%%;\">\n");
  printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
  v5 = sub_310B4(v3);
  portforward_read_db("user_pf", &v39);
  if ( !v4 || !strcmp(v4, "user") )
  {
    v6 = v39;
    v7 = 0;
    while ( v6 && !*(_DWORD *)(v6 + 528) )
    {
      sub_30078(1, v6, ++v7);
      v6 = *(_DWORD *)v6;
    }
    v8 = v7;
    sub_2F6F8();
    while ( v6 && *(_DWORD *)(v6 + 528) == 1 )
    {
      ++v7;
      ++v8;
      sub_30078(2, v6, v7);
      v6 = *(_DWORD *)v6;
    }
    v9 = 0;
    sub_2F718();
    v10 = 15 - v8;
    while ( v9 < v10 )
    {
      ++v9;
      sub_2F6C0();
    }
    goto LABEL_31;
  }
  result = strcmp(v4, "all");
  v12 = result;
  if ( !result )
  {
    for ( i = v39; i && !*(_DWORD *)(i + 528); i = *(_DWORD *)i )
      sub_30078(1, i, ++v12);
    v14 = v12;
    sub_2F6F8();
    while ( i && *(_DWORD *)(i + 528) == 1 )
    {
      ++v12;
      ++v14;
      sub_30078(2, i, v12);
      i = *(_DWORD *)i;
    }
    v15 = 0;
    sub_2F718();
    v16 = 8 - v14;
    while ( v15 < v16 )
    {
      ++v15;
      sub_2F6C0();
    }
LABEL_31:
    printf((const char *)&unk_6E894);
    puts("<SCRIPT language=\"javascript\">");
    puts((const char *)&unk_6EE4F);
    puts("function onNewLineClicked(mode){");
    puts("\tvar obj = document.getElementById(\"_-new_line\");");
    puts("\tif(obj){ \n\tobj.scrollIntoView(true);");
    puts("\tif(mode){");
    puts("\t\tonClickedPFRule(mode,'','','','','','','','','','','','','','','');\n}");
    puts("\telse{");
    puts("\t\tonClickedPFRule('user','','','','','','','','','','','','','','','');\n}");
    puts("\t}\n}");
    if ( v5 == -1 )
    {
      if ( !v4 || !strcmp(v4, "all") )
        printf("onNewLineClicked();");
      else
        printf("onNewLineClicked('%s');", v4);
      memset(&v36, 0, 0x20u);
      if ( !sub_306AC(v3, "act", (int)&v36, 32) || strcmp(&v36, "add") || v41 <= 0x63 )
        goto LABEL_63;
      v19 = "alert('%s');";
      v20 = "더 이상 규칙을 추가할 수 없습니다.";
    }
    else
    {
      v17 = v39;
      for ( j = 1; ; ++j )
      {
        v22 = 0;
        v21 = v17 < 0;
        if ( v17 )
        {
          v22 = __OFSUB__(j, v5);
          v21 = j - v5 < 0;
        }
        if ( !(v21 ^ v22) )
          break;
        v17 = *(_DWORD *)v17;
      }
      if ( v17 )
      {
        if ( *(_DWORD *)(v17 + 528) )
        {
          v28 = *(_DWORD *)(v17 + 536);
          v29 = 10;
          v30 = v28 + 20;
          memset(&v35, 0, 0x200u);
          do
          {
            v32 = *(_DWORD *)(v30 + 4);
            v30 += 4;
            v31 = v32;
            if ( v32 )
              snprintf(&v35, 0x200u, "%s%d ", &v35, v31);
            --v29;
          }
          while ( v29 );
          v33 = "true";
          if ( *(_BYTE *)(v17 + 516) )
            v33 = "false";
          printf(
            "onClickedPFRule('trigger','%s','trigger','','%s','','','','','%d','%d','%s','%s',%s,'%d','');",
            v17 + 4,
            v28,
            *(_DWORD *)(v28 + 8),
            *(_DWORD *)(v28 + 12),
            v28 + 16,
            &v35,
            v33,
            v5);
        }
        else
        {
          v23 = *(_DWORD *)(v17 + 532);
          v24 = *(_DWORD *)(v23 + 16);
          v25 = *(_DWORD *)(v23 + 20);
          *(_BYTE *)(v17 + 516);
          v26 = *(_DWORD *)(v23 + 8);
          v27 = *(_DWORD *)(v23 + 12);
          printf(
            "onClickedPFRule('user','%s','0','%s','%s','%d','%d','%d','%d','','','','',%s,'%d','%d');",
            v17 + 4,
            v23 + 24);
        }
        printf("\tvar obj = document.getElementById('%s');", v17 + 4);
        v34 = "\tif(obj) obj.scrollIntoView(true);";
        goto LABEL_62;
      }
      if ( !v4 || !strcmp(v4, "all") )
      {
        v34 = "onNewLineClicked();";
LABEL_62:
        printf(v34);
        goto LABEL_63;
      }
      v19 = "onNewLineClicked('%s');";
      v20 = v4;
    }
    printf(v19, v20);
LABEL_63:
    printf("parent.document.portforward_fm.rule_count.value = %d;", v41);
    printf("onLoadCompleted(parent.document);");
    printf("</SCRIPT>");
    printf("</BODY>");
    result = free_portforward_list(&v39);
  }
  return result;
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11930: using guessed type int __fastcall portforward_read_db(_DWORD, _DWORD);
// 119FC: using guessed type int __fastcall free_portforward_list(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00032FC4) --------------------------------------------------------
int __fastcall sub_32FC4(int a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r6@1
  const char *v4; // r4@1
  int v5; // r5@6
  int j; // r6@6
  int v7; // r6@9
  int v8; // r7@9
  int result; // r0@15
  int v10; // r5@15
  int i; // r6@16
  int v12; // r6@19
  int v13; // r7@19
  char s; // [sp+4h] [bp-44h]@2
  char v15; // [sp+23h] [bp-25h]@3
  int v16; // [sp+24h] [bp-24h]@1
  int v17; // [sp+28h] [bp-20h]@1
  int v18; // [sp+2Ch] [bp-1Ch]@1

  v2 = a1;
  v3 = a2;
  v18 = 0;
  v16 = 0;
  v17 = 0;
  print_file("/home/httpd/js/natrouterconf_portforward_v2.lang.js");
  print_file("/home/httpd/js/natrouterconf_portforward_v2.js");
  sub_2F7B4();
  v4 = (const char *)get_pvalue(v2, "mode");
  if ( !v4 )
  {
    memset(&s, 0, 0x20u);
    if ( sub_306AC(v3, "view_mode", (int)&s, 32) )
    {
      v15 = (char)v4;
      v4 = &s;
    }
  }
  printf("<BODY style=\"padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;\">");
  printf("<form method=post action=\"timepro.cgi\" name=\"upnp_portforward_fm\" style=\"margin:0px 0px 0px 0px; padding:0px 0px 0px 0px;\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"upnp_portforward\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"view_mode\" value=\"%s\">");
  printf("<input type=hidden name=\"mode\" value=\"\">");
  printf("<input type=hidden name=\"priority\" value=\"\">");
  printf("<input type=hidden name=\"old_priority\" value=\"\">");
  printf("<table style=\"table-layout:fixed; border-collapse:collapse; border-style:none none none none; width:100%%;\">\n");
  printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
  sub_31288(v3);
  if ( v4 && strcmp(v4, "upnp") )
  {
    result = strcmp(v4, "all");
    v10 = result;
    if ( result )
      return result;
    portforward_read_db("upnp_pf", &v16);
    for ( i = v16; i && !*(_DWORD *)(i + 528); i = *(_DWORD *)i )
      sub_2FDCC(i, ++v10);
    v12 = 0;
    v13 = 6 - v10;
    while ( v12 < v13 )
    {
      ++v10;
      ++v12;
      sub_2F6C0();
    }
  }
  else
  {
    portforward_read_db("upnp_pf", &v16);
    v5 = 0;
    for ( j = v16; j && !*(_DWORD *)(j + 528); j = *(_DWORD *)j )
      sub_2FDCC(j, ++v5);
    v7 = 0;
    v8 = 16 - v5;
    while ( v7 < v8 )
    {
      ++v5;
      ++v7;
      sub_2F6C0();
    }
  }
  printf((const char *)&unk_6E894);
  puts("<SCRIPT language=\"javascript\">");
  puts((const char *)&unk_6EE4F);
  if ( v4 )
  {
    if ( !strcmp(v4, "upnp") )
      printf("onClickedPFRule('upnp','','','','','','','','','','','','','','','');");
  }
  printf("</SCRIPT>");
  printf("</BODY>");
  return free_portforward_list(&v16);
}
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11930: using guessed type int __fastcall portforward_read_db(_DWORD, _DWORD);
// 119FC: using guessed type int __fastcall free_portforward_list(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (0003328C) --------------------------------------------------------
int __fastcall sub_3328C(int a1)
{
  int v1; // r5@1
  int v2; // r6@1
  int i; // r4@1
  int v4; // r6@7
  int v6; // [sp+0h] [bp-20h]@1
  int v7; // [sp+4h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-18h]@1
  int v9; // [sp+Ch] [bp-14h]@1

  v6 = a1;
  v1 = 0;
  v2 = 0;
  v9 = 0;
  v7 = 0;
  v8 = 0;
  print_file("/home/httpd/js/natrouterconf_portforward_v2.lang.js");
  print_file("/home/httpd/js/natrouterconf_portforward_v2.js");
  sub_2F7B4();
  printf("<BODY style=\"padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;\">");
  printf("<form method=post action=\"timepro.cgi\" name=\"trigger_portforward_fm\" style=\"margin:0px 0px 0px 0px; padding:0px 0px 0px 0px;\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"trigger_portforward\">");
  printf("<table style=\"table-layout:fixed; border-collapse:collapse; border-style:none none none none; width:100%%;\">\n");
  printf("<COL WIDTH=\"30\"><COL WIDTH=\"100\"><COL WIDTH=\"140\"><COL WIDTH=\"140\"><COL WIDTH=\"120\"><COL WIDTH=\"%%\">\n");
  portforward_read_db("user_pf", &v7);
  for ( i = v7; i; i = *(_DWORD *)i )
  {
    if ( *(_DWORD *)(i + 528) == 1 && *(_BYTE *)(*(_DWORD *)(i + 536) + 64) )
    {
      ++v1;
      ++v2;
      sub_2FA90(i, v1);
    }
  }
  v4 = 16 - v2;
  while ( i < v4 )
  {
    ++v1;
    ++i;
    sub_2F6C0();
  }
  printf((const char *)&unk_6E894);
  puts("<SCRIPT language=\"javascript\">");
  puts((const char *)&unk_6EE4F);
  printf("onClickedPFRule('trigger_status','','','','','','','','','','','','','','','');");
  printf("</SCRIPT>");
  printf("</BODY>");
  free_portforward_list(&v7);
  return v6;
}
// 11930: using guessed type int __fastcall portforward_read_db(_DWORD, _DWORD);
// 119FC: using guessed type int __fastcall free_portforward_list(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (000333D0) --------------------------------------------------------
FILE *__fastcall sub_333D0(int a1, int a2)
{
  FILE *result; // r0@1
  FILE *v3; // r4@1
  char v4; // [sp+8h] [bp-90h]@1
  void *ptr; // [sp+88h] [bp-10h]@1
  size_t n; // [sp+8Ch] [bp-Ch]@1

  n = 0;
  get_value_post_multipart_file(a2, "pf_restore_file", &ptr, &v4);
  result = fopen("/tmp/user_pf.set.tmp", "w+");
  v3 = result;
  if ( result )
  {
    fwrite(ptr, 1u, n, result);
    result = (FILE *)fclose(v3);
  }
  return result;
}
// 10C1C: using guessed type int __fastcall get_value_post_multipart_file(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00033468) --------------------------------------------------------
int sub_33468()
{
  char *v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  char *v6; // r0@2
  char *v7; // r1@2
  int v8; // r2@2
  int v9; // r0@4
  int v10; // r0@4
  int v11; // r0@4
  int v12; // r0@6
  char *v13; // r0@6
  const char *v14; // r1@6
  int v15; // r2@10
  int v16; // r0@12
  int v17; // r0@14
  const char *v18; // r0@15
  char *v19; // r0@16
  int v20; // r4@16
  const char *v21; // r2@17
  int v22; // r0@19
  const char *v23; // r2@20
  int v24; // r0@22
  int v25; // r0@22
  char v27; // [sp+Ch] [bp-25Ch]@1
  char v28; // [sp+10Ch] [bp-15Ch]@4
  char v29; // [sp+18Ch] [bp-DCh]@12
  int v30; // [sp+1CCh] [bp-9Ch]@1
  char v31; // [sp+1D0h] [bp-98h]@11
  int v32; // [sp+1E4h] [bp-84h]@2
  char v33; // [sp+1F8h] [bp-70h]@3
  char v34; // [sp+20Ch] [bp-5Ch]@3
  char dest[4]; // [sp+220h] [bp-48h]@1
  char s; // [sp+224h] [bp-44h]@1
  char v37; // [sp+234h] [bp-34h]@1
  int v38; // [sp+248h] [bp-20h]@1
  int v39; // [sp+24Ch] [bp-1Ch]@1

  v38 = 0;
  v39 = 0;
  *(_DWORD *)dest = 0;
  memset(&s, 0, 0x10u);
  v0 = getenv("REMOTE_ADDR");
  v1 = get_internal_pc_hardware_address(v0, &v37);
  print_start_content_table(v1);
  v2 = dmztwinip_read_config("wan1", &v30);
  str(v2);
  puts("<td class=itemdesc_td colspan=2>");
  printf("<input type=hidden name=opmode value=%d>", v30);
  v3 = printf("<input type=radio name=\"w%dmode\" value=0 onclick='select_twinipdmz(this.value,%d)' %s><span class=\"bold_item_text\">사용하지 않음</span>");
  br(v3);
  v4 = printf("<input type=radio name=\"w%dmode\" value=1 onclick='select_twinipdmz(this.value,%d)' %s><span class=\"bold_item_text\">DMZ</span> (%s)");
  br(v4);
  printf((const char *)&unk_6F526);
  v5 = puts("</td>");
  etr(v5);
  print_blank_line(2, 10);
  printf("<tr id=\"w%dipaddr\" style='display:%s'>\n");
  print_item_desc("내부 IP주소");
  puts("<td class=item_td>");
  snprintf(&v27, 0x100u, "w%dip", 1, "");
  if ( v30 == 1 )
  {
    v6 = &v27;
    v7 = (char *)&v32;
    v8 = 2;
  }
  else
  {
    get_ifconfig("br0", &v34, &v33);
    v6 = &v27;
    v7 = &v34;
    v8 = 3;
  }
  v9 = sub_157CC((int)v6, v7, v8);
  v10 = get_remote_addr(v9);
  v11 = snprintf(&v28, 0x80u, "%s", v10);
  br(v11);
  if ( strcmp(&v28, "Twin IP") )
    printf(
      "<input type=checkbox class=navi_chk name='re_ip' onclick=\"OnCheckEnableIP(this, '%s', '%s')\">현재 접속된 PC"
      "의 IP 주소로 설정(%s)",
      &v27,
      &v28,
      &v28);
  v12 = puts("</td>");
  etr(v12);
  printf("<tr id=\"w%dhwaddr\" style='display:%s'>\n", 1);
  print_item_desc("MAC 주소");
  puts("<td class=item_td align=left>");
  printf("<input type=checkbox name=\"get_w%dhosthw\" onclick='get_hwaddr(this,%d,\"%s\")'>\n");
  printf("현재 접속된 PC의 MAC주소로 설정");
  printf("<br>");
  v13 = (char *)snprintf(&v27, 0x100u, "w%dhw", 1, "");
  if ( v30 == 2 )
    v13 = &v27;
  else
    v14 = 0;
  if ( v30 == 2 )
  {
    v14 = &v31;
    v15 = 0;
  }
  else
  {
    v13 = &v27;
    v15 = (int)v14;
  }
  sub_15664((int)v13, v14, v15);
  print_nbsp(5);
  snprintf(&v27, 0x100u, (const char *)&unk_6F755, 1);
  snprintf(&v29, 0x40u, (const char *)&unk_6F79E, 1);
  print_popup_button(
    &v27,
    "searchmac",
    "width=400px,height=250px,scrollbars=yes,menubar=no,toolbar=no,resizable=yes",
    &v29);
  v16 = puts("</td>");
  etr(v16);
  printf("<tr id=\"w%dlease_time\" style='display:%s'>\n", 1);
  print_item_desc("IP 갱신 시간");
  puts("<td class=item_td align=left>");
  read_real_ipclone_leasetime("wan1", &v38);
  if ( !v38 )
    v38 = 60;
  printf("<input type=text name=\"w%dleasetime\" id=\"w%dleasetime\"size=5 maxlength=5 value=\"%d\"> 초\n");
  v17 = puts("</td>");
  etr(v17);
  if ( !dest[0] )
  {
    v18 = (const char *)get_twinip_wan_virtual_ip("wan1");
    strcpy(dest, v18);
  }
  v19 = getenv("REMOTE_ADDR");
  v20 = strcmp(v19, dest) == 0;
  if ( v30 == 2 )
    v21 = "none";
  else
    v21 = "block";
  printf("<tr id=\"w%dother_apply\" style='display:%s'>\n", 1, v21);
  puts("<td class=\"item_td\" align=right colspan=2>");
  printf(
    "<input type=\"button\" class=navi_bt name=\"apply\" value=\"적용\" onclick=\"submit_twinipdmz(%d, %d, %d)\">",
    1,
    v30,
    v20,
    "",
    1);
  v22 = puts("</td>");
  etr(v22);
  if ( v30 == 2 )
    v23 = "block";
  else
    v23 = "none";
  printf("<tr id=\"w%dtwinip_apply\" style='display:%s'>\n", 1, v23);
  puts("<td class=\"item_td\" align=right colspan=2>");
  printf(
    "<input type=\"button\" class=navi_bt name=\"apply\" value=\"적용\" onclick=\"submit_twinipdmz(%d, %d, %d)\">",
    1,
    v30,
    v20);
  v24 = puts("</td>");
  v25 = etr(v24);
  return print_end_content_table(v25);
}
// 10148: using guessed type int __fastcall get_remote_addr(_DWORD);
// 103F4: using guessed type int __fastcall dmztwinip_read_config(_DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10844: using guessed type int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10E8C: using guessed type int __fastcall read_real_ipclone_leasetime(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00033950) --------------------------------------------------------
signed int __fastcall sub_33950(int a1)
{
  int v1; // r5@1
  int v2; // r0@2
  int v3; // r4@2
  bool v4; // zf@2
  const char *v5; // r0@2
  int v6; // r0@5
  int v7; // r6@5
  signed int v8; // r10@6
  int v9; // r7@17
  int v10; // r0@19
  const char *v11; // r0@19
  const char *v12; // r0@21
  int v13; // r0@23
  const char *v14; // r0@25
  int v15; // r0@30
  int v16; // r0@31
  int v18; // [sp+0h] [bp-140h]@9
  int v19; // [sp+80h] [bp-C0h]@4
  int v20; // [sp+84h] [bp-BCh]@6
  char v21; // [sp+ACh] [bp-94h]@27
  char v22; // [sp+CCh] [bp-74h]@4
  char v23; // [sp+ECh] [bp-54h]@1
  char v24; // [sp+10Ch] [bp-34h]@9

  v1 = a1;
  if ( get_value(a1, "act", &v23, 32) )
  {
    get_value(v1, "wanid", &v23, 32);
    v2 = atoi(&v23);
    v3 = v2;
    v4 = v2 == 1;
    v5 = "wan2";
    if ( v4 )
      v5 = "wan1";
    dmztwinip_read_config(v5, &v19);
    snprintf(&v22, 0x20u, "w%dmode", v3);
    if ( get_value(v1, &v22, &v23, 32) )
    {
      v6 = atoi(&v23);
      v7 = v6;
      if ( v19 == 2 )
      {
        v8 = 1;
        dhcpd_remove_static_lease(0, &v20);
        dhcpd_remove_dynamic_lease(0, &v20);
      }
      else
      {
        if ( v6 == 2 )
        {
          v8 = 1;
          snprintf((char *)&v18, 0x80u, "w%dhw", v3);
          get_hw_value(v1, &v18, &v24);
          dhcpd_remove_static_lease(0, &v24);
          dhcpd_remove_dynamic_lease(0, &v24);
          goto LABEL_17;
        }
        v8 = 0;
      }
      if ( v7 == 1 )
      {
        if ( v19 == 2 )
        {
          dmztwinip_apply_off(v3, &v19);
          write_file(&unk_6F93D, "0");
        }
        snprintf((char *)&v18, 0x80u, "w%dip", v3);
        get_ip_value(v1, &v18, &v23);
        dmztwinip_apply_dmz(v3, &v23, &v19);
LABEL_20:
        v19 = v7;
        if ( v3 == 1 )
          v12 = "wan1";
        else
          v12 = "wan2";
        v13 = dmztwinip_write_config(v12, &v19);
        if ( v19 == 2 )
        {
          dhcpd_remove_static_lease(0, &v20);
          dhcpd_remove_dynamic_lease(0, &v20);
          if ( v3 == 1 )
            v14 = "wan1";
          else
            v14 = "wan2";
          v13 = get_wan_ip(v14, &v21);
          if ( v13 )
            v13 = dhcpd_add_static_lease(&v21, &v20);
        }
        else if ( !v8 )
        {
LABEL_31:
          v16 = signal_update(v13);
          signal_save(v16);
          return 1;
        }
        v15 = dhcpd_stop(v13);
        v13 = dhcpd_start(v15);
        goto LABEL_31;
      }
      if ( v7 != 2 )
      {
        if ( !v7 )
        {
          dmztwinip_apply_off(v3, &v19);
          write_file(&unk_6F93D, "0");
        }
        goto LABEL_20;
      }
LABEL_17:
      snprintf((char *)&v18, 0x80u, "w%dhw", v3);
      get_hw_value(v1, &v18, &v24);
      snprintf((char *)&v18, 0x80u, (const char *)&unk_6F951, v3);
      get_value(v1, &v18, &v23, 32);
      v9 = atoi(&v23);
      if ( v19 == 1 )
        dmztwinip_apply_off(v3, &v19);
      v10 = get_twinip_wan_virtual_ip("wan1");
      snprintf((char *)&v18, 0x80u, "1 %s ", v10);
      v11 = (const char *)get_twinip_wan_virtual_ip("wan2");
      strcat((char *)&v18, v11);
      write_file(&unk_6F93D, &v18);
      dmztwinip_apply_twinip(v3, &v24, v9, &v19);
      goto LABEL_20;
    }
  }
  return 1;
}
// 10058: using guessed type int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD);
// 100AC: using guessed type int __fastcall dhcpd_start(_DWORD);
// 100F4: using guessed type int __fastcall dmztwinip_write_config(_DWORD, _DWORD);
// 1022C: using guessed type int __fastcall dmztwinip_apply_dmz(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 103F4: using guessed type int __fastcall dmztwinip_read_config(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10880: using guessed type int __fastcall dhcpd_remove_static_lease(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 111D4: using guessed type int __fastcall dmztwinip_apply_off(_DWORD, _DWORD);
// 113FC: using guessed type int __fastcall dhcpd_add_static_lease(_DWORD, _DWORD);
// 114C8: using guessed type int __cdecl dhcpd_stop(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 119C0: using guessed type int __fastcall dmztwinip_apply_twinip(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11AC8: using guessed type int __fastcall dhcpd_remove_dynamic_lease(_DWORD, _DWORD);
// 11AE0: using guessed type int __fastcall write_file(_DWORD, _DWORD);

//----- (00034554) --------------------------------------------------------
int sub_34554()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r4@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r8@2
  const char *v7; // r1@3
  char *v8; // r0@3
  char *v9; // r0@5
  int v10; // r1@5
  int v11; // r0@5
  char s[10360]; // [sp+8h] [bp-29C8h]@1
  int v14; // [sp+Ch] [bp-29C4h]@6
  int v15; // [sp+28B0h] [bp-120h]@3

  memset(s, 0, 0x68u);
  read_rt_db(s);
  puts("<form method=get action=\"timepro.cgi\" name=\"router_list_fm\">");
  puts("<input type=hidden name=\"tmenu\" value='natrouterconf'>");
  puts("<input type=hidden name=\"smenu\" value='router'>");
  puts("<input type=hidden name=\"del\" value=\"\">");
  v0 = puts("<input type=hidden name=\"act\" value=\"\">");
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("");
  print_item_desc("Type");
  print_item_desc("Target");
  print_item_desc("Mask");
  v2 = 0;
  print_item_desc("Gateway");
  puts("<td class=itemdesc_td align=left width=65>");
  v3 = puts("<input type=button class=navi_bt name=\"del_bt\" value=\"삭제\" onclick=\"deleteRT();\">");
  br(v3);
  puts("<input type=checkbox name=\"allchk\" onclick=\"CheckAllCheckBox(document, this, 'delchk');\">");
  v4 = puts("</td>");
  v5 = etr(v4);
  while ( v2 < v14 )
  {
    v6 = 104 * v2;
    if ( !strcmp(&s[104 * v2 + 12], "host") )
    {
      v7 = "HOST";
      v8 = (char *)&v15;
    }
    else
    {
      v7 = "NETWORK";
      v8 = (char *)&v15;
    }
    v9 = strcpy(v8, v7);
    str(v9);
    printf("<td class=\"item_td\" align=center>%d</td>", v2 + 1);
    printf("<td class=item_td>%s</td>", &v15);
    printf("<td class=item_td>%s</td>", &s[v6 + 20]);
    printf("<td class=item_td>%s</td>", &s[v6 + 40]);
    printf("<td class=item_td>%s</td>", &s[v6 + 60]);
    printf("<td class=\"item_td\" align=left>");
    v10 = v2++;
    printf("<input type=checkbox name=\"delchk\" value=\"%d\" >", v10);
    v11 = printf("</td>");
    v5 = etr(v11);
  }
  print_end_content_table(v5);
  return puts("</form>");
}
// 10028: using guessed type int __fastcall read_rt_db(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 34554: using guessed type char s[10360];

//----- (00034784) --------------------------------------------------------
signed int __fastcall sub_34784(const char *a1, int a2)
{
  int v2; // r4@1
  int v3; // r0@1
  unsigned int v4; // r3@1
  int i; // r2@1
  char *v6; // r3@4
  signed int result; // r0@5

  v2 = a2;
  v3 = atoi(a1);
  v4 = 0;
  for ( i = 0; i < v3; ++i )
    v4 |= 0x80000000 >> i;
  v6 = inet_ntoa((struct in_addr)__rev(v4));
  if ( v6 )
  {
    sf_strncpy(v2, v6, 20);
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (000347E0) --------------------------------------------------------
int __fastcall sub_347E0(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  int v3; // r5@10
  int *v4; // r6@11
  int *v5; // r7@11
  int v6; // r0@15
  char s; // [sp+8h] [bp-2B50h]@2
  signed int v8; // [sp+Ch] [bp-2B4Ch]@7
  int v9; // [sp+28B0h] [bp-2A8h]@12
  int v10; // [sp+2AB0h] [bp-A8h]@2
  int v11; // [sp+2AB4h] [bp-A4h]@5
  int v12; // [sp+2ABCh] [bp-9Ch]@5
  int v13; // [sp+2AD0h] [bp-88h]@5
  int v14; // [sp+2AE4h] [bp-74h]@7
  int v15; // [sp+2B18h] [bp-40h]@1

  v1 = a1;
  result = get_value(a1, "act", &v15, 32);
  if ( result )
  {
    memset(&s, 0, 0x68u);
    memset(&v10, 0, 0x68u);
    read_rt_db(&s);
    if ( get_value(v1, "act", &v15, 32) && !strcmp((const char *)&v15, "add") )
    {
      get_value(v1, "rtselect", &v15, 32);
      result = check_unpermitted_chars(&v15);
      if ( result )
        return result;
      sf_strncpy(&v11, &v15, 8);
      get_ip_value(v1, "targetip", &v12);
      strcpy((char *)&v13, "");
      if ( get_value(v1, "netmask", &v15, 32) )
        sub_34784((const char *)&v15, (int)&v13);
      strcpy((char *)&v14, "");
      get_ip_value(v1, "gw", &v14);
      if ( v8 <= 99 )
        add_rt_entry();
    }
    if ( get_value(v1, "act", &v15, 32) )
    {
      v3 = strcmp((const char *)&v15, "del");
      if ( !v3 )
      {
        v4 = (int *)malloc(0x190u);
        v5 = v4;
        while ( get_value_array(v1, "delchk", v3, &v9) )
        {
          ++v3;
          *v5 = atoi((const char *)&v9);
          ++v5;
        }
        delete_rt_entry_list(&s, v4, v3);
        free(v4);
      }
    }
    v6 = write_rt_db(&s);
    result = signal_save(v6);
  }
  return result;
}
// 10028: using guessed type int __fastcall read_rt_db(_DWORD);
// 10094: using guessed type int __fastcall delete_rt_entry_list(_DWORD, _DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 109D0: using guessed type int add_rt_entry(void);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 118E8: using guessed type int __fastcall write_rt_db(_DWORD);

//----- (00034C10) --------------------------------------------------------
int __fastcall sub_34C10(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  int v3; // r0@3
  int v4; // r4@4
  char *v5; // r0@4
  int v6; // r5@5
  int v7; // r6@7
  int *v8; // r3@13
  int v9; // t1@14
  char *v10; // r2@15
  int v11; // t1@16
  int v12; // r0@28
  int v13; // r0@35
  int v14; // r4@35
  int v15; // r0@37
  int v16; // r0@38
  char v17; // [sp+4h] [bp-1F4h]@8
  char v18; // [sp+84h] [bp-174h]@3
  char v19; // [sp+104h] [bp-F4h]@1
  char v20; // [sp+184h] [bp-74h]@8
  char v21; // [sp+1A0h] [bp-58h]@15
  char v22[20]; // [sp+1A4h] [bp-54h]@10
  char v23; // [sp+1B8h] [bp-40h]@18
  char s; // [sp+1BCh] [bp-3Ch]@3
  int v25; // [sp+1D4h] [bp-24h]@19
  char v26; // [sp+1D8h] [bp-20h]@4

  v1 = a1;
  result = get_value(a1, "act", &v19, 128);
  if ( result )
  {
    if ( !strcmp(&v19, "addftpport") )
    {
      memset(&s, 0, 0x18u);
      v3 = get_value(v1, "ftp_port", &v18, 128);
      if ( v3 )
      {
        v4 = read_ftp_private_port(&s, 6);
        *((_DWORD *)&v26 + v4 - 7) = atoi(&v18);
        v5 = &s;
LABEL_21:
        v3 = write_ftp_private_port(v5, 6);
        goto LABEL_38;
      }
    }
    else
    {
      v6 = strcmp(&v19, "delftpport");
      if ( v6 )
      {
        if ( strcmp(&v19, "mc") )
        {
          if ( !strcmp(&v19, "pppoe_relay") )
          {
            get_intvalue(v1, "pppoe_relay", &v25);
            v3 = set_pppoe_relay_enabled(v25);
          }
          else
          {
            v3 = strcmp(&v19, "upnp_relay");
            if ( !v3 )
            {
              v13 = get_intvalue(v1, "upnp_relay", &v25);
              v14 = v25;
              v3 = get_upnp_relay(v13);
              if ( v14 != v3 )
              {
                v3 = set_upnp_relay(v25);
                if ( v25 )
                {
                  discover_upper_upnp_igd(v3);
                  v15 = portforward_upnp_relay_init("user_pf");
                  v3 = nas_service_upnp_relay_init(v15);
                }
              }
            }
          }
          goto LABEL_38;
        }
        result = get_value(v1, "mc_run", &v19, 128);
        if ( !result )
          return result;
        v3 = atoi(&v19);
        if ( v3 )
        {
          if ( v3 == 1 )
          {
            set_multicast_forward_flag();
            v12 = get_value(v1, "mc_wl", &v19, 128) != 0;
            v3 = set_multicast_forward_wireless(v12);
            goto LABEL_38;
          }
          if ( v3 != 2 )
            goto LABEL_38;
          v3 = get_multicast_forward_flag();
          if ( !v3 )
            goto LABEL_38;
        }
        else
        {
          v3 = get_multicast_forward_flag();
          if ( !v3 )
            goto LABEL_38;
        }
        v3 = set_multicast_forward_flag();
        goto LABEL_38;
      }
      v3 = read_ftp_private_port(&s, 6);
      if ( v3 )
      {
        v7 = 0;
        do
        {
          snprintf(&v18, 0x20u, "port%d", v7);
          snprintf(&v20, 0x20u, "%s_ch", &v18);
          if ( get_value(v1, &v20, &v17, 32) && get_value(v1, &v18, &v17, 32) )
            *(_DWORD *)&v22[v6] = atoi(&v17);
          else
            *(_DWORD *)&v22[v6] = 0;
          ++v7;
          v6 += 4;
        }
        while ( v7 != 6 );
        v8 = (int *)&s;
        do
        {
          v9 = *v8;
          ++v8;
          if ( v9 )
          {
            v10 = &v21;
            do
            {
              v11 = *((_DWORD *)v10 + 1);
              v10 += 4;
              if ( *(v8 - 1) == v11 )
                *(v8 - 1) = 0;
            }
            while ( v10 != &v23 );
          }
        }
        while ( v8 != &v25 );
        v5 = &s;
        goto LABEL_21;
      }
    }
LABEL_38:
    v16 = signal_update(v3);
    result = signal_save(v16);
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10B80: using guessed type int set_multicast_forward_flag(void);
// 10B98: using guessed type int __fastcall set_pppoe_relay_enabled(_DWORD);
// 10C4C: using guessed type int __fastcall set_multicast_forward_wireless(_DWORD);
// 10E74: using guessed type int __fastcall set_upnp_relay(_DWORD);
// 10F04: using guessed type int __fastcall read_ftp_private_port(_DWORD, _DWORD);
// 10F58: using guessed type int __fastcall discover_upper_upnp_igd(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 10FC4: using guessed type int __fastcall get_upnp_relay(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11120: using guessed type int __fastcall write_ftp_private_port(_DWORD, _DWORD);
// 11234: using guessed type int __fastcall nas_service_upnp_relay_init(_DWORD);
// 117A4: using guessed type int get_multicast_forward_flag(void);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11BE8: using guessed type int __fastcall portforward_upnp_relay_init(_DWORD);
// 34C10: using guessed type char var_54[20];

//----- (00034F34) --------------------------------------------------------
int __fastcall sub_34F34(int a1)
{
  int v1; // r4@1
  int result; // r0@3
  const char *v3; // r1@4
  int v4; // r0@6
  int v5; // [sp+0h] [bp-28h]@1

  get_value(a1, "nat_run", &v5, 30);
  v1 = atoi((const char *)&v5);
  if ( !v1 && sysconf_nat_get(1) || (result = sysconf_nat_get(1)) == 0 )
  {
    sysconf_nat_set(v1, 0);
    v3 = "관리자가 NAT기능을 끔";
    if ( v1 )
      v3 = "관리자가 NAT기능을 킴";
    v4 = syslog_msg(1, v3);
    result = saveconf(v4);
  }
  return result;
}
// 107CC: using guessed type int __fastcall sysconf_nat_set(_DWORD, _DWORD);
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 11018: using guessed type int __fastcall sysconf_nat_get(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003542C) --------------------------------------------------------
_BYTE *__fastcall sub_3542C(_BYTE *result)
{
  char v1; // r3@4
  int v2; // t1@4

  while ( 1 )
  {
    v2 = *result++;
    v1 = v2;
    if ( !v2 )
      break;
    if ( (unsigned __int8)(v1 - 97) <= 0x19u )
      *(result - 1) = v1 - 32;
  }
  return result;
}

//----- (00035454) --------------------------------------------------------
int sub_35454()
{
  printf("<TR height=24 STYLE=\"cursor:pointer; background-Color:#%s\">");
  return printf("<TD width=100%% colspan=10 CLASS=text_gray></TD></TR>");
}

//----- (0003548C) --------------------------------------------------------
int __fastcall sub_3548C(unsigned int a1)
{
  unsigned int v1; // r4@1
  const char *v2; // r0@3
  void *v3; // r0@5
  const char *v4; // r0@7

  v1 = a1;
  printf("<TR height=\"24\" ID=\"_-new_line\" class=\"fw_tr\" style=\"cursor:pointer; background-color:#%s;\">\n");
  puts("<TD align=\"left\" width=\"30\" class=\"fw_td\">");
  if ( v1 <= 1 || v1 != 2 )
    v2 = "<SPAN id=\"_-new_line_span_1\" class=\"fw_span\" style=\"padding-left:5px;\"\t\t\t onclick=\"onClickedFWRule('i"
         "nternet','','','','','','','','','','','','','','','','','');\">";
  else
    v2 = "<SPAN id=\"_-new_line_span_1\" class=\"fw_span\" style=\"padding-left:5px;\"\t\t\t onclick=\"onClickedFWRule('w"
         "ifi','','','','','','','','','','','','','','','','','');\">";
  puts(v2);
  v3 = sub_16094();
  printf("<img src=\"/%s/pf_new_rule.gif\">\n", v3);
  puts("</SPAN></TD>");
  puts("<TD align=\"left\" colspan=\"9\" class=\"fw_td\">");
  puts("<a name=\"_-new_line\" class=\"fw_a\">");
  if ( v1 <= 1 || v1 != 2 )
    v4 = "<SPAN ID=\"_-new_line_span_2\" class=\"fw_span\" style=\"color:#4789FF;\"\t\t \tonclick=\"onClickedFWRule('inte"
         "rnet','','','','','','','','','','','','','','','','','');\">";
  else
    v4 = "<SPAN ID=\"_-new_line_span_2\" class=\"fw_span\" style=\"color:#4789FF;\"\t\t \tonclick=\"onClickedFWRule('wifi"
         "','','','','','','','','','','','','','','','','','');\">";
  printf(v4);
  return printf("%s</SPAN></A></TD></TR>", &unk_6B198);
}

//----- (0003555C) --------------------------------------------------------
int sub_3555C()
{
  puts("<style type=\"text/css\">");
  puts(".fw_table {");
  puts("\tborder-collapse:collapse; padding:0 0 0 0; margin:0 0 0 0;");
  puts("\ttable-layout:fixed;");
  puts("}");
  puts(".fw_tr {");
  puts("\tborder:0 0 0 0; padding:0 0 0 0;");
  puts("}");
  puts(".fw_td {");
  puts("\tpadding:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".left_padding_td {");
  puts("\tpadding:0 0 0 5; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_p {");
  puts("\tpadding:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_span {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_select {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_textbox {");
  puts("\tpadding:1 0 1 0; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_button {");
  puts("\tpadding:0 1 0 1; margin:0 0 0 0; font-size:12px;");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_checkbox {");
  puts("\tvertical-align:middle;");
  puts("}");
  puts(".fw_a {");
  puts("\tvertical-align:middle; text-decoration:none;");
  puts("\tdisplay:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;");
  puts("}");
  puts(".fw_overflowable {");
  puts("\tpadding:0 0 0 0; margin:0 0 0 0; border:none none none none; vertical-align:middle; text-decoration:none;");
  puts("\tdisplay:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;");
  puts("}");
  puts(".fw_opacity_30 {");
  puts("\topacity:0.3;");
  puts("\t-moz-opacity:0.3;");
  puts("\t-khtml-opacity:0.3;");
  puts("\tfilter:alpha(opacity=30);");
  puts("}");
  printf("::-webkit-input-placeholder {");
  printf("\tcolor:#B4B4B4;");
  putchar(125);
  printf(":-moz-placeholder {");
  printf("\tcolor:#B4B4B4;");
  printf("\topacity:1;");
  putchar(125);
  printf((const char *)&unk_6B545);
  printf("\tcolor:#B4B4B4;");
  printf("\topacity:1;");
  putchar(125);
  printf(":-ms-input-placeholder {");
  printf("\tcolor:#B4B4B4;");
  putchar(125);
  return printf("</style>");
}

//----- (00035838) --------------------------------------------------------
int __fastcall sub_35838(int a1, char *a2)
{
  int v2; // r5@1
  char *v3; // r0@3
  char *v4; // r1@6
  char *v5; // r0@8
  bool v6; // zf@8
  const char *v7; // r1@8
  char *v8; // r0@8
  char *v9; // r0@13
  bool v10; // zf@13
  const char *v11; // r1@13
  char *v12; // r0@13
  char *v13; // r6@20
  signed int v14; // r4@20
  char v16; // [sp+18h] [bp-40h]@8
  char v17; // [sp+1Dh] [bp-3Bh]@10
  char v18; // [sp+22h] [bp-36h]@15
  char v19; // [sp+27h] [bp-31h]@18
  char dest; // [sp+2Ch] [bp-2Ch]@3

  v2 = a1;
  if ( a2 && *a2 )
  {
    v3 = &dest;
  }
  else
  {
    a2 = "";
    v3 = &dest;
  }
  strcpy(v3, a2);
  if ( dest )
  {
    v4 = strtok(&dest, ".");
    if ( !v4 )
      v4 = "0";
    strcpy(&v16, v4);
    v5 = strtok(0, ".");
    v7 = v5;
    v6 = v5 == 0;
    v8 = &v16;
    if ( v6 )
      v7 = "0";
    else
      v8 = &v17;
    if ( v6 )
      v8 += 5;
    strcpy(v8, v7);
    v9 = strtok(0, ".");
    v11 = v9;
    v10 = v9 == 0;
    v12 = &v16;
    if ( v10 )
      v11 = "0";
    else
      v12 = &v18;
    if ( v10 )
      v12 += 10;
    strcpy(v12, v11);
    strcpy(&v19, (const char *)&unk_70C4D);
  }
  else
  {
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
  }
  v13 = &v16;
  v14 = 1;
  do
  {
    printf(
      "<input type=text name=\"%s%d\" maxlength=3 size=3 style=\"width:26px; ime-mode:disabled;\" class=\"fw_textbox\" va"
      "lue=\"%s\" onfocus=\"this.select();\" onkeypress=\"return IPKeyDown('%s', %d);\" title=\"%s%d\" onkeydown=\"Button"
      "ViewControl('modify'); return true;\" onkeyup=\"IPKeyUp('%s',%d);\">",
      v2,
      v14,
      v13,
      v2,
      v14,
      "IP 주소",
      v14,
      v2,
      v14,
      *(_DWORD *)&v16);
    if ( v14 != 4 )
      putchar(46);
    ++v14;
    v13 += 5;
  }
  while ( v14 != 5 );
  return printf(
           "~<input type=text name=\"%s%d\" maxlength=3 size=3 style=\"width:26px; ime-mode:disabled;\" onfocus=\"this.se"
           "lect();\"                    class=\"fw_textbox\" onkeypress=\"return IPKeyDown('%s', %d);\" title=\"%s%d\" \t"
           "\t\tonkeyup=\"IPKeyUp('%s',%d);\" onkeydown=\"ButtonViewControl('modify'); return true;\">",
           v2,
           5,
           v2,
           5,
           "IP 주소",
           5,
           v2,
           5);
}

//----- (0003599C) --------------------------------------------------------
signed int __fastcall sub_3599C(const char **a1, const char *a2)
{
  const char *v2; // r6@1
  const char **v3; // r5@1
  signed int i; // r4@1
  const char *v5; // r0@4
  const char *v6; // t1@4
  int v7; // r3@4

  v2 = a2;
  v3 = a1;
  for ( i = 0; ; ++i )
  {
    v6 = *v3;
    ++v3;
    v5 = v6;
    v7 = i <= 199;
    if ( !v6 )
      v7 = 0;
    if ( !v7 )
      return 0;
    if ( !strcmp(v5, v2) )
      break;
  }
  return 1;
}

//----- (000359F4) --------------------------------------------------------
char *__fastcall sub_359F4(int a1)
{
  char *result; // r0@3
  const char *v2; // r4@4

  if ( *(_BYTE *)(a1 + 16) || *(_BYTE *)(a1 + 144) )
  {
    v2 = (const char *)(a1 + 8);
    if ( !strcmp((const char *)(a1 + 8), "ip") )
    {
      result = "ip";
    }
    else if ( !strcmp(v2, "ipmac") )
    {
      result = "ip";
    }
    else
    {
      result = "mac";
    }
  }
  else
  {
    result = "all";
  }
  return result;
}

//----- (00035A68) --------------------------------------------------------
const char *__fastcall sub_35A68(char *src)
{
  const char *result; // r0@1
  int v2; // [sp+0h] [bp-28h]@1

  strncpy((char *)&v2, src, 0x20u);
  strtok((char *)&v2, ".");
  strtok(0, ".");
  strtok(0, ".");
  result = strtok(0, ".");
  if ( result )
    result = (const char *)atoi(result);
  return result;
}

//----- (00035AD0) --------------------------------------------------------
int __fastcall sub_35AD0(int result)
{
  if ( result )
    result = delete_fw_rule(0, result);
  return result;
}
// 10430: using guessed type int __fastcall delete_fw_rule(_DWORD, _DWORD);

//----- (00035AE0) --------------------------------------------------------
const char *__fastcall sub_35AE0(const char *a1, const char *a2, int a3, signed int a4)
{
  const char *v4; // r6@1
  const char *v5; // r4@1
  int v6; // r5@1
  signed int v7; // r8@1
  size_t v8; // r7@2
  char *v9; // r0@4
  const char *v10; // r6@7
  char *v11; // r0@7
  signed int v12; // r4@9
  void *v13; // r7@15
  signed int v14; // r2@15
  _BYTE *v15; // r3@15
  _BYTE *v16; // r1@16
  int v17; // t1@16

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( a1 )
  {
    v8 = strlen(a2);
    while ( strncmp(v4, v5, v8) )
    {
      v9 = strchr(v4, 38);
      v4 = v9;
      if ( !v9 )
        return v4;
      v4 = v9 + 1;
    }
    if ( v4 )
    {
      v10 = &v4[v8 + 1];
      v11 = strchr(v10, 38);
      if ( !v11 )
        v11 = (char *)&v10[strlen(v10)];
      v12 = v11 - v10;
      if ( v11 == v10 )
      {
        v4 = (const char *)(v11 - v10);
      }
      else
      {
        if ( v7 <= v12 )
          v12 = v7 - 1;
        if ( strchr(v10, 37) )
          v12 *= 3;
        v13 = malloc(v12 + 1);
        memcpy(v13, v10, v12);
        v14 = 0;
        v15 = v13;
        *((_BYTE *)v13 + v12) = 0;
        while ( v14 < v12 )
        {
          v16 = v15;
          v17 = *v15++;
          if ( v17 == 43 )
            *(v15 - 1) = 32;
          if ( *(v15 - 1) == 38 )
          {
            *v16 = 0;
            break;
          }
          ++v14;
        }
        v4 = (const char *)1;
        decode_string(v13);
        sf_strncpy(v6, v13, v7);
        free(v13);
      }
    }
  }
  return v4;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10634: using guessed type int __fastcall decode_string(_DWORD);

//----- (00035C18) --------------------------------------------------------
void *__fastcall sub_35C18(const char *a1)
{
  const char *v1; // r6@1
  void *v2; // r8@1
  void *v3; // r9@1
  void *v4; // r5@1
  const char *v5; // r7@1
  signed int v6; // r10@24
  int v7; // r10@32
  int v8; // r0@45
  int v9; // r7@51
  const char *v10; // r10@69
  unsigned int v11; // r3@84
  bool v12; // zf@98
  char *v13; // r0@98
  const char *v14; // r4@99
  int v15; // r0@111
  char *v16; // r0@140
  int v17; // r10@141
  int v18; // r0@153
  int v19; // r10@154
  signed int v20; // r3@170
  int v21; // r7@171
  int v23; // [sp+0h] [bp-288h]@1
  char s1; // [sp+200h] [bp-88h]@98
  char v25; // [sp+220h] [bp-68h]@94
  char dest; // [sp+240h] [bp-48h]@4

  v1 = a1;
  v2 = malloc(0x224u);
  v3 = v2;
  v4 = malloc(0x1C8u);
  init_fw_rule(v2);
  init_fw_netfilter(v4);
  *((_DWORD *)v2 + 133) = v4;
  memset(&v23, 0, 0x200u);
  v5 = sub_35AE0(v1, "mode", (int)&v23, 32);
  if ( v5 )
  {
    if ( fw_spchar_validate(&v23) )
    {
      v5 = 0;
    }
    else
    {
      v5 = (const char *)1;
      strcpy(&dest, (const char *)&v23);
    }
  }
  memset(&v23, 0, 0x200u);
  if ( v5 )
  {
    v5 = sub_35AE0(v1, "name", (int)&v23, 512);
    if ( v5 )
    {
      strncpy((char *)v2, (const char *)&v23, 0x200u);
      *((_BYTE *)v2 + 511) = 0;
      v5 = (const char *)(fw_spchar_validate(&v23) == 0);
    }
  }
  memset(&v23, 0, 0x200u);
  if ( v5 )
  {
    v5 = sub_35AE0(v1, "days", (int)&v23, 32);
    if ( v5 )
    {
      if ( fw_spchar_validate(&v23) )
      {
        v5 = 0;
      }
      else
      {
        v5 = (const char *)1;
        *((_DWORD *)v2 + 129) = atoi((const char *)&v23);
      }
    }
  }
  memset(&v23, 0, 0x200u);
  if ( v5 )
  {
    v5 = sub_35AE0(v1, "policy", (int)&v23, 32);
    if ( v5 )
    {
      v5 = (const char *)fw_spchar_validate(&v23);
      if ( v5 )
      {
        v5 = 0;
      }
      else if ( !strcmp((const char *)&v23, "accept") )
      {
        v5 = (const char *)1;
        *((_DWORD *)v4 + 112) = 1;
      }
      else if ( !strcmp((const char *)&v23, "drop") )
      {
        v5 = (const char *)1;
        *((_DWORD *)v4 + 112) = 0;
      }
    }
  }
  memset(&v23, 0, 0x200u);
  if ( v5 )
  {
    v5 = sub_35AE0(v1, "stime", (int)&v23, 32);
    if ( v5 )
    {
      v5 = (const char *)(fw_spchar_validate(&v23) == 0);
      if ( !strcmp((const char *)&v23, "all") )
      {
        *((_DWORD *)v2 + 130) = 0;
        v6 = 1;
        *((_DWORD *)v2 + 131) = 0;
        goto LABEL_31;
      }
      if ( v5 )
        *((_DWORD *)v2 + 130) = atoi((const char *)&v23);
      if ( *((_DWORD *)v2 + 130) < 0x960u )
      {
        v6 = 0;
        goto LABEL_31;
      }
      v5 = 0;
    }
  }
  v6 = (signed int)v5;
LABEL_31:
  if ( v6 == 1 )
    v7 = 0;
  else
    v7 = (unsigned __int8)v5 & 1;
  memset(&v23, 0, 0x200u);
  if ( v7 )
  {
    if ( sub_35AE0(v1, "etime", (int)&v23, 32) )
    {
      if ( fw_spchar_validate(&v23) )
      {
        v5 = 0;
      }
      else
      {
        v5 = (const char *)1;
        *((_DWORD *)v2 + 131) = atoi((const char *)&v23);
      }
      if ( *((_DWORD *)v2 + 131) >= 0x960u )
        v5 = 0;
    }
    else
    {
      v5 = (const char *)1;
    }
  }
  memset(&v23, 0, 0x200u);
  if ( !v5 )
    goto LABEL_181;
  if ( sub_35AE0(v1, "disabled", (int)&v23, 32) )
  {
    if ( fw_spchar_validate(&v23) )
      goto LABEL_181;
    v8 = atoi((const char *)&v23);
    if ( v8 )
    {
      if ( v8 != 1 )
        goto LABEL_181;
      *((_DWORD *)v2 + 128) = 0;
    }
    else
    {
      *((_DWORD *)v2 + 128) = 1;
    }
  }
  v9 = strcmp(&dest, "internet");
  if ( !v9 )
  {
    memset(&v23, 0, 0x200u);
    if ( sub_35AE0(v1, "direction", (int)&v23, 8) )
    {
      if ( !fw_spchar_validate(&v23) )
      {
        if ( !strcmp((const char *)&v23, "inout")
          || !strcmp((const char *)&v23, "outin")
          || !strcmp((const char *)&v23, "both") )
        {
          v9 = 1;
          strcpy((char *)v4, (const char *)&v23);
        }
        else
        {
          v9 = 0;
        }
      }
    }
    else
    {
      v9 = 0;
    }
    memset(&v23, 0, 0x200u);
    if ( v9
      && sub_35AE0(v1, "protocol", (int)&v23, 8)
      && !fw_spchar_validate(&v23)
      && (!strcmp((const char *)&v23, "none")
       || !strcmp((const char *)&v23, "tcp")
       || !strcmp((const char *)&v23, "udp")
       || !strcmp((const char *)&v23, "icmp")
       || !strcmp((const char *)&v23, "gre")
       || !strcmp((const char *)&v23, "tcpudp")) )
    {
      strcpy((char *)v4 + 432, (const char *)&v23);
      if ( !strcmp((const char *)v4 + 432, "none")
        || !strcmp((const char *)v4 + 432, "gre")
        || !strcmp((const char *)v4 + 432, "icmp") )
      {
        goto LABEL_188;
      }
      memset(&v23, 0, 0x200u);
      if ( sub_35AE0(v1, "sport", (int)&v23, 8) )
      {
        if ( fw_spchar_validate(&v23) )
        {
          v10 = 0;
        }
        else
        {
          v10 = (const char *)1;
          *((_DWORD *)v4 + 110) = atoi((const char *)&v23);
        }
        if ( *((_DWORD *)v4 + 110) >= 0x10000u )
          v10 = 0;
      }
      else
      {
        v10 = (const char *)1;
      }
      memset(&v23, 0, 0x200u);
      if ( !v10 )
        goto LABEL_90;
      if ( !sub_35AE0(v1, "eport", (int)&v23, 8) )
      {
LABEL_188:
        v10 = (const char *)1;
      }
      else
      {
        if ( fw_spchar_validate(&v23) )
        {
          v10 = 0;
        }
        else
        {
          v10 = (const char *)1;
          *((_DWORD *)v4 + 111) = atoi((const char *)&v23);
        }
        v11 = *((_DWORD *)v4 + 111);
        if ( v11 >= 0x10000 )
          v10 = 0;
        if ( *((_DWORD *)v4 + 110) > (signed int)v11 )
          v10 = 0;
      }
    }
    else
    {
      v10 = 0;
    }
LABEL_90:
    memset(&v23, 0, 0x200u);
    if ( v10 )
    {
      v10 = sub_35AE0(v1, "src_addr_type", (int)&v23, 8);
      if ( v10 )
      {
        if ( fw_spchar_validate(&v23) )
        {
          v10 = 0;
        }
        else
        {
          v10 = (const char *)1;
          strcpy(&v25, (const char *)&v23);
        }
      }
    }
    memset(&v23, 0, 0x200u);
    if ( !v10 || !sub_35AE0(v1, "dest_addr_type", (int)&v23, 8) || fw_spchar_validate(&v23) )
      goto LABEL_169;
    strcpy(&s1, (const char *)&v23);
    v12 = strcmp(&v25, "all") == 0;
    v13 = (char *)v4 + 8;
    if ( v12 )
    {
      strcpy(v13, "ip");
LABEL_121:
      if ( strcmp(&s1, "all") )
      {
        memset(&v23, 0, 0x200u);
        if ( sub_35AE0(v1, "dest_start", (int)&v23, 32) )
        {
          if ( fw_spchar_validate(&v23) )
          {
            v14 = 0;
          }
          else
          {
            v14 = (const char *)1;
            strcpy((char *)v4 + 80, (const char *)&v23);
          }
          if ( validate_ipv4_addr((char *)v4 + 80) )
            v14 = 0;
        }
        else
        {
          v14 = (const char *)1;
        }
        memset(&v23, 0, 0x200u);
        if ( sub_35AE0(v1, "dest_end", (int)&v23, 32) )
        {
          if ( fw_spchar_validate(&v23) )
          {
            v14 = 0;
          }
          else if ( v14 )
          {
            v14 = (const char *)1;
            strcpy((char *)v4 + 112, (const char *)&v23);
          }
          if ( validate_ipv4_addr((char *)v4 + 112) )
            v14 = 0;
        }
        goto LABEL_170;
      }
      goto LABEL_168;
    }
    strcpy(v13, &v25);
    v14 = (const char *)strcmp(&v25, "ip");
    if ( v14 )
    {
      v14 = (const char *)strcmp(&v25, "mac");
      if ( v14 )
        goto LABEL_169;
      memset(&v23, 0, 0x200u);
      if ( !sub_35AE0(v1, "src_start", (int)&v23, 32) )
        goto LABEL_169;
      if ( !fw_spchar_validate(&v23) )
      {
        v14 = (const char *)1;
        strcpy((char *)v4 + 144, (const char *)&v23);
      }
      v15 = validate_mac_addr((char *)v4 + 144);
    }
    else
    {
      memset(&v23, 0, 0x200u);
      if ( sub_35AE0(v1, "src_start", (int)&v23, 32) )
      {
        if ( !fw_spchar_validate(&v23) )
        {
          v14 = (const char *)1;
          strcpy((char *)v4 + 16, (const char *)&v23);
        }
        if ( validate_ipv4_addr((char *)v4 + 16) )
          v14 = 0;
      }
      else
      {
        v14 = 0;
      }
      memset(&v23, 0, 0x200u);
      if ( !sub_35AE0(v1, "src_end", (int)&v23, 32) )
      {
LABEL_120:
        if ( !v14 )
        {
LABEL_170:
          v20 = 0;
          goto LABEL_180;
        }
        goto LABEL_121;
      }
      if ( fw_spchar_validate(&v23) )
      {
        v14 = 0;
      }
      else if ( v14 )
      {
        v14 = (const char *)1;
        strcpy((char *)v4 + 48, (const char *)&v23);
      }
      v15 = validate_ipv4_addr((char *)v4 + 48);
    }
    if ( !v15 )
      goto LABEL_120;
LABEL_169:
    v14 = 0;
    goto LABEL_170;
  }
  if ( !strcmp(&dest, "site") )
  {
    memset(&v23, 0, 0x200u);
    if ( !sub_35AE0(v1, "src_addr_type", (int)&v23, 8) || (v14 = (const char *)fw_spchar_validate(&v23)) != 0 )
    {
      v14 = 0;
      goto LABEL_164;
    }
    strcpy(&v25, (const char *)&v23);
    v12 = strcmp(&v25, "all") == 0;
    v16 = (char *)v4 + 8;
    if ( v12 )
    {
      v14 = (const char *)1;
      strcpy(v16, "ip");
      goto LABEL_164;
    }
    strcpy(v16, &v25);
    v17 = strcmp(&v25, "ip");
    if ( v17 )
    {
      v19 = strcmp(&v25, "mac");
      if ( v19 )
        goto LABEL_164;
      memset(&v23, 0, 0x200u);
      v14 = sub_35AE0(v1, "src_start", (int)&v23, 32);
      if ( !v14 )
        goto LABEL_164;
      if ( fw_spchar_validate(&v23) )
      {
        v14 = (const char *)v19;
      }
      else
      {
        v14 = (const char *)1;
        strcpy((char *)v4 + 144, (const char *)&v23);
      }
      v18 = validate_mac_addr((char *)v4 + 144);
    }
    else
    {
      memset(&v23, 0, 0x200u);
      v14 = sub_35AE0(v1, "src_start", (int)&v23, 32);
      if ( v14 )
      {
        if ( fw_spchar_validate(&v23) )
        {
          v14 = (const char *)v17;
        }
        else
        {
          v14 = (const char *)1;
          strcpy((char *)v4 + 16, (const char *)&v23);
        }
        if ( validate_ipv4_addr((char *)v4 + 16) )
          v14 = 0;
      }
      memset(&v23, 0, 0x200u);
      if ( !sub_35AE0(v1, "src_end", (int)&v23, 32) )
      {
LABEL_164:
        memset(&v23, 0, 0x200u);
        if ( !v14 )
          goto LABEL_170;
        v14 = sub_35AE0(v1, "dest_start", (int)&v23, 256);
        if ( !v14 )
          goto LABEL_170;
        if ( !fw_spchar_validate(&v23) )
        {
          convert_url_to_new(&v23, (char *)v4 + 176);
LABEL_168:
          v14 = (const char *)1;
          goto LABEL_170;
        }
        goto LABEL_169;
      }
      if ( fw_spchar_validate(&v23) )
      {
        v14 = 0;
      }
      else if ( v14 )
      {
        v14 = (const char *)1;
        strcpy((char *)v4 + 48, (const char *)&v23);
      }
      v18 = validate_ipv4_addr((char *)v4 + 48);
    }
    if ( v18 )
      v14 = 0;
    goto LABEL_164;
  }
  v21 = strcmp(&dest, "wifi");
  if ( v21 )
  {
LABEL_181:
    v3 = 0;
    delete_fw_rule(0, v2);
    return v3;
  }
  memset(&v23, 0, 0x200u);
  v14 = sub_35AE0(v1, "band", (int)&v23, 8);
  if ( v14 )
  {
    v14 = (const char *)(fw_spchar_validate(&v23) == 0);
    if ( !strcmp((const char *)&v23, "2g") || !strcmp((const char *)&v23, "5g") || !strcmp((const char *)&v23, "all") )
    {
      if ( v14 )
      {
        v14 = (const char *)1;
        strcpy((char *)v2 + 536, (const char *)&v23);
      }
    }
    else
    {
      v14 = (const char *)v21;
    }
  }
  v20 = 1;
LABEL_180:
  *((_DWORD *)v2 + 132) = v20;
  if ( !v14 )
    goto LABEL_181;
  return v3;
}
// 103E8: using guessed type int __fastcall init_fw_rule(_DWORD);
// 10430: using guessed type int __fastcall delete_fw_rule(_DWORD, _DWORD);
// 10AF0: using guessed type int __fastcall validate_mac_addr(_DWORD);
// 10CC4: using guessed type int __fastcall validate_ipv4_addr(_DWORD);
// 10E08: using guessed type int __fastcall convert_url_to_new(_DWORD, _DWORD);
// 10FF4: using guessed type int __fastcall init_fw_netfilter(_DWORD);
// 11C00: using guessed type int __fastcall fw_spchar_validate(_DWORD);

//----- (000368B0) --------------------------------------------------------
int __fastcall sub_368B0(int a1, int a2, int a3)
{
  int v3; // r7@1
  int v4; // r4@1
  const char *v5; // r3@1
  int v6; // lr@1
  const char *v7; // r5@3
  const char *v8; // r1@4
  void *v9; // r1@11
  const char *v10; // r0@11
  void *v11; // r3@14
  const char *v12; // r2@14
  char *v13; // r0@14
  void *v14; // r0@17
  int v15; // r6@18
  int v16; // r5@20
  int v17; // r10@20
  int v18; // r1@22
  int v19; // r6@23
  int v20; // r7@24
  int v21; // r1@24
  int v22; // r5@29
  int v24; // [sp+Ch] [bp-14Ch]@3
  int v25; // [sp+10h] [bp-148h]@3
  const char *v26; // [sp+14h] [bp-144h]@3
  int v27; // [sp+18h] [bp-140h]@3
  char s; // [sp+24h] [bp-134h]@6
  char dest; // [sp+124h] [bp-34h]@6
  char v30; // [sp+138h] [bp-20h]@33

  v3 = a3;
  v4 = a2;
  v5 = "true";
  v6 = *(_DWORD *)(a2 + 516);
  if ( *(_DWORD *)(a2 + 512) )
    v5 = "false";
  v7 = (const char *)(a2 + 536);
  v25 = *(_DWORD *)(a2 + 524);
  v26 = v5;
  v24 = *(_DWORD *)(a2 + 520);
  v27 = a2 + 536;
  printf("<TR height=\"24\" ID=\"%s\" class=\"fw_tr\" style=\"cursor:pointer; background-color:#%s;\" \t\tonclick=\"onClickedFWRule('%s','%s','','','','','','',0,0,'','','%s',%d,'%04d','%04d',%s,0,'%s');\">\n");
  if ( *(_DWORD *)(v4 + 512) )
    v8 = "#000000";
  else
    v8 = "#B4B4B4";
  strcpy(&dest, v8);
  printf(
    "<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"30\" style=\"color:%s; padding-left:5px;\"></TD>\n",
    &dest);
  puts("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"80\">");
  printf(
    "<a name=\"%s\" title=\"%s\" class=\"fw_a\" style=\"width:80px; color:%s;\">%s</a>\n",
    v4,
    v4,
    &dest,
    v4,
    "drop",
    v6,
    v24,
    v25,
    v26,
    v27);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"80\" style=\"color:%s;\">\n", &dest);
  puts("<SPAN style=\"width:80px;\" class=\"fw_overflowable\" title=\"5G WiFi\">");
  memset(&s, 0, 0x100u);
  strcpy(&s, v7);
  if ( !strcmp(v7, "2g") )
    strcpy(&s, "2.4g");
  if ( !strcmp(v7, "all") )
    strcpy(&s, "all");
  sub_3542C(&s);
  printf("WiFi %s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"center\" class=\"fw_td\" width=\"20\" style=\"color:%s;\">\n", &dest);
  if ( *(_DWORD *)(v4 + 512) )
  {
    v9 = sub_16094();
    v10 = "<img src=\"/%s/fw_right_arrow.gif\">";
  }
  else
  {
    v9 = sub_16094();
    v10 = "<img src=\"/%s/fw_right_arrow.gif\" class=\"fw_opacity_30\">";
  }
  printf(v10, v9);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"90\" style=\"color:%s;\">\n", &dest);
  printf("<SPAN style=\"width:90px;\" class=\"fw_overflowable\" title=\"%s\">\n", "모든 IP");
  printf("모든 IP");
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"70\" style=\"color:%s;\">\n", &dest);
  puts("<SPAN style=\"width:70px;\" class=\"fw_overflowable\" title=\"ALL\">");
  printf("ALL");
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"30\" style=\"color:%s;\">\n", &dest);
  printf("<SPAN style=\"width:30px;\" class=\"fw_overflowable\" title=\"%s\">\n", "차단");
  printf("차단");
  printf("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"right\" class=\"fw_td\" width=\"15\" style=\"color:%s;\">\n", &dest);
  if ( *(_DWORD *)(v4 + 512) )
  {
    if ( v3 == 1 )
    {
      v11 = sub_16094();
      v12 = "/%s/fw_play.gif";
      v13 = &s;
    }
    else
    {
      v14 = sub_16094();
      v12 = "/%s/fw_pause.gif";
      v11 = v14;
      v13 = &s;
    }
  }
  else
  {
    v11 = sub_16094();
    v12 = "/%s/fw_stop_gray.gif";
    v13 = &s;
  }
  snprintf(v13, 0x100u, v12, v11);
  printf("<img src=\"%s\" style=\"margin-right:3px; vertical-align:middle;\">\n", &s);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"155\" style=\"color:%s;\">\n", &dest);
  memset(&s, 0, 0x100u);
  v15 = *(_DWORD *)(v4 + 520);
  if ( v15 )
  {
    v16 = sub_4EC48(*(_DWORD *)(v4 + 520), 100);
    sub_4ED24(v15, 0x64u);
    v17 = v18;
  }
  else
  {
    if ( !*(_DWORD *)(v4 + 524) )
    {
      snprintf(&s, 0x100u, "%s ", "24시간");
      goto LABEL_27;
    }
    v16 = *(_DWORD *)(v4 + 520);
    v17 = *(_DWORD *)(v4 + 520);
  }
  v19 = *(_DWORD *)(v4 + 524);
  if ( v19 )
  {
    v20 = sub_4EC48(*(_DWORD *)(v4 + 524), 100);
    sub_4ED24(v19, 0x64u);
  }
  else
  {
    v20 = 0;
    v21 = 0;
  }
  snprintf(&s, 0x100u, "%02d:%02d~%02d:%02d ", v16, v17, v20, v21);
LABEL_27:
  if ( *(_DWORD *)(v4 + 516) )
  {
    v22 = 0;
    do
    {
      if ( (*(_DWORD *)(v4 + 516) >> v22) & 1 )
        snprintf(&s, 0x100u, "%s%s/", &s, *(&off_8FBA0 + v22));
      ++v22;
    }
    while ( v22 != 7 );
    *(&v30 + strlen(&s) - 277) = 0;
  }
  else
  {
    snprintf(&s, 0x100u, "%s %s", &s, "매일");
  }
  printf("<SPAN style=\"width:155px;\" class=\"fw_overflowable\" title=\"%s\">\n", &s);
  printf("%s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"right\" class=\"fw_td\" style=\"%s\">\n");
  printf("<input type=\"checkbox\" name=\"delcheck\" value=\"%s\">\n", v4);
  puts("</TD>");
  return puts("</TR>");
}
// 8FBA0: using guessed type void *off_8FBA0;

//----- (00036DE4) --------------------------------------------------------
int __fastcall sub_36DE4(int a1, int a2, int a3)
{
  const char *v3; // r7@1
  int v4; // r5@1
  int v5; // r8@1
  const char *v6; // r1@2
  int v7; // r4@4
  const char *v8; // r3@4
  int v9; // r6@4
  const char *v10; // r11@4
  const char *v11; // r2@6
  char *v12; // r0@8
  int v13; // r0@8
  char *v14; // r12@8
  int v15; // r2@9
  bool v16; // zf@11
  int v17; // r3@16
  bool v18; // zf@20
  const char *v19; // r0@26
  char *v20; // r0@28
  const char *v21; // r2@28
  const char *v22; // r3@28
  const char *v23; // r0@36
  void *v24; // r3@42
  const char *v25; // r2@42
  char *v26; // r0@42
  int v27; // r0@44
  int v28; // r3@44
  void *v29; // r0@50
  const char *v30; // r0@54
  char *v31; // r0@56
  const char *v32; // r2@56
  const char *v33; // r3@56
  char *v34; // r0@62
  const char *v35; // r1@62
  int v36; // r2@68
  bool v37; // zf@68
  char *v38; // r0@69
  const char *v39; // r2@69
  void *v40; // r3@78
  const char *v41; // r2@78
  char *v42; // r0@78
  void *v43; // r0@81
  int v44; // r6@82
  int v45; // r4@84
  int v46; // r8@84
  int v47; // r1@86
  int v48; // r6@87
  int v49; // r7@88
  int v50; // r1@88
  int v51; // r4@93
  int v53; // [sp+0h] [bp-1A8h]@24
  int v54; // [sp+4h] [bp-1A4h]@24
  const char *v55; // [sp+54h] [bp-154h]@6
  const char *v56; // [sp+58h] [bp-150h]@8
  char *v57; // [sp+5Ch] [bp-14Ch]@8
  int v58; // [sp+60h] [bp-148h]@1
  char s; // [sp+6Ch] [bp-13Ch]@26
  char dest; // [sp+16Ch] [bp-3Ch]@4
  char v61; // [sp+180h] [bp-28h]@97

  v3 = *(const char **)(a2 + 512);
  v4 = a2;
  v5 = a1;
  v58 = a3;
  if ( v3 )
    v6 = "#000000";
  else
    v6 = "#B4B4B4";
  strcpy(&dest, v6);
  v7 = *(_DWORD *)(v4 + 532);
  v8 = "ffffff";
  v9 = *(_BYTE *)(v7 + 176);
  v10 = "drop";
  if ( !(v5 & 1) )
    v8 = "f7f7f7";
  v11 = "internet";
  v55 = v8;
  if ( *(_BYTE *)(v7 + 176) )
    v11 = "site";
  v56 = v11;
  v12 = sub_359F4(*(_DWORD *)(v4 + 532));
  v57 = v12;
  v13 = strcmp(v12, "ip");
  v14 = (char *)*(_BYTE *)(v7 + 80);
  if ( v13 )
    v15 = v7 + 144;
  else
    v15 = v7 + 16;
  v16 = v14 == 0;
  if ( !*(_BYTE *)(v7 + 80) )
    v14 = "all";
  if ( !v16 )
    v14 = "ip";
  if ( v9 )
    v17 = v7 + 176;
  else
    v17 = v7 + 80;
  if ( *(_DWORD *)(v7 + 448) == 1 )
    v10 = "accept";
  v18 = v3 == 0;
  if ( v3 )
    v3 = "false";
  if ( v18 )
    v3 = "true";
  printf(
    "<TR height=\"24\" ID=\"%s\" class=\"fw_tr\" style=\"cursor:pointer; background-color:#%s;\" \t\tonclick=\"onClickedF"
    "WRule('%s','%s','%s','%s','%s','%s','%s','%s',%d,%d,'%s','%s','%s',%d,'%04d','%04d',%s,%d);\">\n",
    v4,
    v55,
    v56,
    v4,
    v57,
    v15,
    v7 + 48,
    v14,
    v17,
    v7 + 112,
    *(_DWORD *)(v7 + 440),
    *(_DWORD *)(v7 + 444),
    v7,
    v7 + 432,
    v10,
    *(_DWORD *)(v4 + 516),
    *(_DWORD *)(v4 + 520),
    *(_DWORD *)(v4 + 524),
    v3,
    v5);
  printf(
    "<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"30\" style=\"color:%s; padding-left:5px;\">%d</TD>\n",
    &dest,
    v5);
  puts("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"80\">");
  printf("<a name=\"%s\" title=\"%s\" class=\"fw_a\" style=\"width:80px; color:%s;\">%s</a>\n", v4, v4, &dest, v4);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"80\" style=\"color:%s;\">\n", &dest);
  if ( !strcmp((const char *)(v7 + 8), "ip") )
  {
    if ( *(_BYTE *)(v7 + 48) )
    {
      v19 = sub_35A68((char *)(v7 + 48));
      snprintf(&s, 0x100u, "%s~%d", v7 + 16, v19);
      goto LABEL_40;
    }
    if ( *(_BYTE *)(v7 + 16) )
    {
      v20 = &s;
      v21 = "%s";
      v22 = (const char *)(v7 + 16);
    }
    else
    {
      v20 = &s;
      v21 = "%s";
      v22 = "모든 IP";
    }
    goto LABEL_33;
  }
  if ( !strcmp((const char *)(v7 + 8), "mac") )
  {
    v21 = "%s";
    v20 = &s;
    v22 = (const char *)(v7 + 144);
LABEL_33:
    snprintf(v20, 0x100u, v21, v22);
    goto LABEL_40;
  }
  if ( !strcmp((const char *)(v7 + 8), "ipmac") )
  {
    if ( *(_BYTE *)(v7 + 48) )
    {
      v23 = sub_35A68((char *)(v7 + 48));
      snprintf(&s, 0x100u, "%s~%d", v7 + 16, v23);
    }
    else
    {
      snprintf(&s, 0x100u, "%s", v7 + 16);
    }
    strcat(&s, "/");
    strcat(&s, (const char *)(v7 + 144));
  }
  else
  {
    strcpy(&s, "ERROR");
  }
LABEL_40:
  printf("<SPAN style=\"width:80px;\" class=\"fw_overflowable\" title=\"%s\">\n", &s);
  printf("%s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"center\" class=\"fw_td\" width=\"20\" style=\"color:%s;\">\n", &dest);
  if ( !strcmp((const char *)v7, "inout") )
  {
    if ( *(_DWORD *)(v4 + 512) )
    {
      v24 = sub_16094();
      v25 = "<img src=\"/%s/fw_right_arrow.gif\">";
      v26 = &s;
    }
    else
    {
      v24 = sub_16094();
      v25 = "<img src=\"/%s/fw_right_arrow.gif\" class=\"fw_opacity_30\">";
      v26 = &s;
    }
  }
  else
  {
    v27 = strcmp((const char *)v7, "outin");
    v28 = *(_DWORD *)(v4 + 512);
    if ( v27 )
    {
      if ( v28 )
      {
        v24 = sub_16094();
        v25 = "<img src=\"/%s/fw_both_arrow.gif\">";
        v26 = &s;
      }
      else
      {
        v29 = sub_16094();
        v25 = "<img src=\"/%s/fw_both_arrow.gif\" class=\"fw_opacity_30\">";
        v24 = v29;
        v26 = &s;
      }
    }
    else if ( v28 )
    {
      v24 = sub_16094();
      v25 = "<img src=\"/%s/fw_left_arrow.gif\">";
      v26 = &s;
    }
    else
    {
      v24 = sub_16094();
      v25 = "<img src=\"/%s/fw_left_arrow.gif\" class=\"fw_opacity_30\">";
      v26 = &s;
    }
  }
  snprintf(v26, 0x100u, v25, v24);
  printf("%s", &s);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"90\" style=\"color:%s;\">\n", &dest);
  if ( *(_BYTE *)(v7 + 176) )
  {
    strcpy(&s, (const char *)(v7 + 176));
  }
  else if ( *(_BYTE *)(v7 + 112) )
  {
    v30 = sub_35A68((char *)(v7 + 112));
    snprintf(&s, 0x100u, "%s~%d", v7 + 80, v30);
  }
  else
  {
    if ( *(_BYTE *)(v7 + 80) )
    {
      v31 = &s;
      v32 = "%s";
      v33 = (const char *)(v7 + 80);
    }
    else
    {
      v31 = &s;
      v32 = "%s";
      v33 = "모든 IP";
    }
    snprintf(v31, 0x100u, v32, v33);
  }
  printf("<SPAN style=\"width:90px;\" class=\"fw_overflowable\" title=\"%s\">\n", &s);
  printf("%s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"70\" style=\"color:%s;\">\n", &dest);
  if ( *(_BYTE *)(v7 + 176) )
  {
    strcpy(&s, " ");
    goto LABEL_77;
  }
  if ( !strcmp((const char *)(v7 + 432), "none") )
  {
    v34 = &s;
    v35 = "all";
  }
  else
  {
    if ( strcmp((const char *)(v7 + 432), "icmp") && strcmp((const char *)(v7 + 432), "gre") )
    {
      if ( *(_DWORD *)(v7 + 440) )
      {
        v36 = *(_DWORD *)(v7 + 444);
        v37 = v36 == 0;
        if ( v36 )
        {
          v53 = *(_DWORD *)(v7 + 444);
          v38 = &s;
          v39 = "%d~%d(%s)";
        }
        else
        {
          v38 = &s;
          v39 = "%d(%s)";
        }
        if ( v37 )
          v53 = v7 + 432;
        else
          v54 = v7 + 432;
        snprintf(v38, 0x100u, v39);
      }
      else
      {
        snprintf(&s, 0x100u, "%s", v7 + 432);
      }
      goto LABEL_76;
    }
    v34 = &s;
    v35 = (const char *)(v7 + 432);
  }
  strcpy(v34, v35);
LABEL_76:
  sub_3542C(&s);
LABEL_77:
  printf("<SPAN style=\"width:70px;\" class=\"fw_overflowable\" title=\"%s\">\n", &s);
  printf("%s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"30\" style=\"color:%s;\">\n", &dest);
  *(_DWORD *)(v7 + 448);
  snprintf(&s, 0x100u, "%s");
  printf("<SPAN style=\"width:30px;\" class=\"fw_overflowable\" title=\"%s\">%s<SPAN>", &s, &s);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"right\" class=\"fw_td\" style=\"color:%s; width:15px;\">\n", &dest);
  if ( *(_DWORD *)(v4 + 512) )
  {
    if ( v58 == 1 )
    {
      v40 = sub_16094();
      v41 = "/%s/fw_play.gif";
      v42 = &s;
    }
    else
    {
      v43 = sub_16094();
      v41 = "/%s/fw_pause.gif";
      v40 = v43;
      v42 = &s;
    }
  }
  else
  {
    v40 = sub_16094();
    v41 = "/%s/fw_stop_gray.gif";
    v42 = &s;
  }
  snprintf(v42, 0x100u, v41, v40, v53, v54);
  printf("<img src=\"%s\" style=\"margin-right:3px; vertical-align:middle;\">\n", &s);
  puts("</TD>");
  printf("<TD height=\"24\" align=\"left\" class=\"fw_td\" width=\"155\" style=\"color:%s;\">\n", &dest);
  memset(&s, 0, 0x100u);
  v44 = *(_DWORD *)(v4 + 520);
  if ( v44 )
  {
    v45 = sub_4EC48(*(_DWORD *)(v4 + 520), 100);
    sub_4ED24(v44, 0x64u);
    v46 = v47;
  }
  else
  {
    if ( !*(_DWORD *)(v4 + 524) )
    {
      snprintf(&s, 0x100u, "%s ", "24시간");
      goto LABEL_91;
    }
    v45 = *(_DWORD *)(v4 + 520);
    v46 = *(_DWORD *)(v4 + 520);
  }
  v48 = *(_DWORD *)(v4 + 524);
  if ( v48 )
  {
    v49 = sub_4EC48(*(_DWORD *)(v4 + 524), 100);
    sub_4ED24(v48, 0x64u);
  }
  else
  {
    v49 = 0;
    v50 = 0;
  }
  snprintf(&s, 0x100u, "%02d:%02d~%02d:%02d ", v45, v46, v49, v50);
LABEL_91:
  if ( *(_DWORD *)(v4 + 516) )
  {
    v51 = 0;
    do
    {
      if ( (*(_DWORD *)(v4 + 516) >> v51) & 1 )
        snprintf(&s, 0x100u, "%s%s/", &s, *(&off_8FBA0 + v51));
      ++v51;
    }
    while ( v51 != 7 );
    *(&v61 + strlen(&s) - 277) = 0;
  }
  else
  {
    snprintf(&s, 0x100u, "%s %s", &s, "매일");
  }
  printf("<SPAN style=\"width:155px;\" class=\"fw_overflowable\" title=\"%s\">\n", &s);
  printf("%s", &s);
  puts("</SPAN>");
  puts("</TD>");
  printf("<TD height=\"24\" align=\"right\" class=\"fw_td\" style=\"%s\">\n");
  printf("<input type=\"checkbox\" name=\"delcheck\" value=\"%s\">\n", v4);
  puts("</TD>");
  return printf("</TR>");
}
// 8FBA0: using guessed type void *off_8FBA0;

//----- (00037724) --------------------------------------------------------
int __fastcall sub_37724(int a1, int a2)
{
  int v2; // r3@1
  int result; // r0@1
  int v4; // r2@4
  int v5; // r2@8

  v2 = a1;
  result = a2;
  if ( a2 )
  {
    result = 0;
    while ( v2 )
    {
      v5 = *(_DWORD *)(v2 + 528);
      v2 = *(_DWORD *)(v2 + 544);
      if ( v5 == 1 )
        ++result;
    }
  }
  else
  {
    while ( v2 )
    {
      v4 = *(_DWORD *)(v2 + 528);
      v2 = *(_DWORD *)(v2 + 544);
      if ( !v4 )
        ++result;
    }
  }
  return result;
}

//----- (00037770) --------------------------------------------------------
int __fastcall sub_37770(int a1)
{
  int v1; // r6@1
  int v2; // r4@1

  v1 = a1;
  v2 = lock_file("/var/run/stat_fw.set");
  fw_read_status("/var/run/stat_fw.set", v1);
  return unlock_file(v2);
}
// 10718: using guessed type int __fastcall fw_read_status(_DWORD, _DWORD);
// 11A44: using guessed type int __fastcall unlock_file(_DWORD);
// 11C6C: using guessed type int __fastcall lock_file(_DWORD);

//----- (000377A4) --------------------------------------------------------
signed int __fastcall sub_377A4(const char *a1)
{
  const char *v1; // r4@1
  const char *v2; // r0@2
  void *v3; // r5@4
  int v4; // r0@5
  const char *v5; // r1@5
  signed int v6; // r3@5
  void *v7; // r2@5
  const char *v8; // r0@5
  int v9; // r0@7
  int v10; // r0@10
  const char *v11; // r1@10
  signed int v12; // r3@10
  void *v13; // r2@10
  const char *v14; // r0@10
  signed int v15; // r4@13
  int v16; // r0@14
  int v17; // r6@14
  int *v18; // r8@15
  int v19; // r5@16
  int v20; // r7@16
  char *v21; // r0@20
  const char *v22; // r11@23
  char *v23; // r0@23
  signed int v24; // r5@25
  char *v25; // r0@26
  void *v26; // r7@30
  _BYTE *v27; // r3@30
  signed int i; // r2@30
  _BYTE *v29; // r1@31
  int v30; // t1@31
  int *v31; // r0@37
  int v32; // r0@40
  int v34; // [sp+0h] [bp-19248h]@15
  char v35; // [sp+19000h] [bp-248h]@4
  int v36; // [sp+19200h] [bp-48h]@2

  v1 = a1;
  if ( !a1 )
    return -1;
  memset(&v36, 0, 0x20u);
  v2 = sub_35AE0(v1, "act", (int)&v36, 32);
  if ( v2 )
  {
    if ( !strcmp((const char *)&v36, "add") )
    {
      v3 = sub_35C18(v1);
      memset(&v35, 0, 0x200u);
      if ( sub_35AE0(v1, "priority", (int)&v35, 32) )
      {
        v4 = atoi(&v35);
        v5 = "/var/run/stat_fw.set";
        v6 = v4;
        v7 = v3;
        v8 = "user_fw";
      }
      else
      {
        v8 = "user_fw";
        v7 = v3;
        v5 = "/var/run/stat_fw.set";
        v6 = 200;
      }
      v9 = fw_add_db(v8, v5, v7, v6);
LABEL_13:
      v15 = v9;
      v2 = (const char *)sub_35AD0((int)v3);
      goto LABEL_40;
    }
    if ( !strcmp((const char *)&v36, "modify") )
    {
      v3 = sub_35C18(v1);
      memset(&v35, 0, 0x200u);
      if ( sub_35AE0(v1, "priority", (int)&v35, 32) )
      {
        v10 = atoi(&v35);
        v11 = "/var/run/stat_fw.set";
        v12 = v10;
        v13 = v3;
        v14 = "user_fw";
      }
      else
      {
        v14 = "user_fw";
        v13 = v3;
        v11 = "/var/run/stat_fw.set";
        v12 = -1;
      }
      v9 = fw_modify_db(v14, v11, v13, v12);
      goto LABEL_13;
    }
    v16 = strcmp((const char *)&v36, "del");
    v17 = v16;
    if ( !v16 )
    {
      v18 = &v34;
      memset(&v34, 0, 0x19000u);
      while ( 1 )
      {
        v19 = (int)v1;
        v20 = 0;
        while ( 1 )
        {
          if ( strncmp((const char *)v19, "delcheck", 8u) )
            goto LABEL_20;
          if ( v20 == v17 )
            break;
          ++v20;
LABEL_20:
          v21 = strchr((const char *)v19, 38);
          if ( !v21 )
            goto LABEL_38;
          v19 = (int)(v21 + 1);
        }
        if ( v19 )
        {
          v22 = (const char *)(v19 + 9);
          v23 = strchr((const char *)(v19 + 9), 38);
          if ( !v23 )
            v23 = (char *)&v22[strlen((const char *)(v19 + 9))];
          v24 = v23 - v22;
          if ( v23 != v22 )
          {
            v25 = strchr(v22, 37);
            if ( v24 >= 511 )
              v24 = 511;
            if ( v25 )
              v24 *= 3;
            v26 = malloc(v24 + 1);
            memcpy(v26, v22, v24);
            *((_BYTE *)v26 + v24) = 0;
            v27 = v26;
            for ( i = 0; i < v24; ++i )
            {
              v29 = v27;
              v30 = *v27++;
              if ( v30 == 43 )
                *(v27 - 1) = 32;
              if ( *(v27 - 1) == 38 )
              {
                *v29 = 0;
                break;
              }
            }
            ++v17;
            decode_string(v26);
            v31 = v18;
            v18 += 128;
            sf_strncpy(v31, v26, 512);
            free(v26);
            if ( v17 != 200 )
              continue;
          }
        }
LABEL_38:
        v2 = (const char *)fw_delete_rules("user_fw", "/var/run/stat_fw.set", &v34, v17);
        v15 = (signed int)v2;
        goto LABEL_40;
      }
    }
    return -1;
  }
  v15 = -1;
LABEL_40:
  v32 = signal_update(v2);
  signal_save(v32);
  return v15;
}
// 10040: using guessed type int __fastcall fw_add_db(_DWORD, _DWORD, _DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10634: using guessed type int __fastcall decode_string(_DWORD);
// 118A0: using guessed type int __fastcall fw_delete_rules(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11AF8: using guessed type int __fastcall fw_modify_db(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00037AB4) --------------------------------------------------------
int __fastcall sub_37AB4(int a1, const char *a2)
{
  int v2; // r4@1
  const char *v3; // r8@1
  const char *v4; // r4@1
  int v5; // r6@6
  int v6; // r7@6
  int v7; // r5@6
  int v8; // r2@7
  int v9; // r6@10
  const char *v10; // r0@12
  int v11; // r2@17
  int v12; // r0@18
  int v13; // r5@23
  int v14; // r7@23
  int v15; // r6@27
  signed int v16; // r7@28
  int v17; // r5@28
  int v18; // r1@30
  int v19; // r2@30
  int v20; // r0@30
  int v21; // r7@35
  int result; // r0@39
  int i; // r5@40
  int v24; // r6@43
  int v25; // r7@43
  const char *v26; // r0@47
  int v27; // r1@53
  int v28; // r2@53
  int v29; // r0@53
  int v30; // r5@58
  int v31; // r7@58
  int v32; // r5@62
  signed int j; // r3@62
  const char *v34; // r0@70
  const char *v35; // r1@70
  bool v36; // nf@72
  unsigned __int8 v37; // vf@72
  int v38; // r4@78
  const char *v39; // r2@78
  int v40; // r6@78
  char *v41; // r0@80
  int v42; // r0@80
  int v43; // r2@80
  char *v44; // r8@80
  bool v45; // zf@84
  int v46; // r3@89
  const char *v47; // r0@91
  const char *v48; // r9@93
  const char *v49; // r3@98
  const char *v50; // r0@101
  signed int v51; // [sp+4Ch] [bp-3ACh]@4
  const char *v52; // [sp+50h] [bp-3A8h]@80
  char *v53; // [sp+54h] [bp-3A4h]@80
  char s; // [sp+60h] [bp-398h]@1
  char v55; // [sp+384h] [bp-74h]@67
  char v56; // [sp+3A4h] [bp-54h]@2
  char v57; // [sp+3C3h] [bp-35h]@3
  int v58; // [sp+3C4h] [bp-34h]@1
  int v59; // [sp+3C8h] [bp-30h]@1
  int v60; // [sp+3CCh] [bp-2Ch]@1

  v2 = a1;
  v3 = a2;
  memset(&s, 0, 0x324u);
  v58 = 0;
  v59 = 0;
  v60 = 0;
  print_file("/home/httpd/js/firewallconf_firewall_v2.lang.js");
  print_file("/home/httpd/js/firewallconf_firewall_v2.js");
  sub_3555C();
  v4 = (const char *)get_pvalue(v2, "mode");
  if ( !v4 )
  {
    memset(&v56, 0, 0x20u);
    if ( sub_35AE0(v3, "view_mode", (int)&v56, 32) )
    {
      v57 = (char)v4;
      v4 = &v56;
    }
  }
  printf("<BODY style=\"padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;\">");
  printf("<form method=post action=\"timepro.cgi\" name=\"firewall_iframe_fm\" style=\"margin:0px 0px 0px 0px; padding:0px 0px 0px 0px;\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"firewall\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"view_mode\" value=\"%s\">");
  printf("<input type=hidden name=\"mode\" value=\"\">");
  printf("<input type=hidden name=\"name\" value=\"\">");
  printf("<input type=hidden name=\"src_addr_type\" value=\"\">");
  printf("<input type=hidden name=\"src_start\" value=\"\">");
  printf("<input type=hidden name=\"src_end\" value=\"\">");
  printf("<input type=hidden name=\"dest_addr_type\" value=\"\">");
  printf("<input type=hidden name=\"dest_start\" value=\"\">");
  printf("<input type=hidden name=\"dest_end\" value=\"\">");
  printf("<input type=hidden name=\"sport\" value=\"\">");
  printf("<input type=hidden name=\"eport\" value=\"\">");
  printf("<input type=hidden name=\"direction\" value=\"\">");
  printf("<input type=hidden name=\"protocol\" value=\"\">");
  printf("<input type=hidden name=\"policy\" value=\"\">");
  printf("<input type=hidden name=\"days\" value=\"\">");
  printf("<input type=hidden name=\"stime\" value=\"\">");
  printf("<input type=hidden name=\"etime\" value=\"\">");
  printf("<input type=hidden name=\"disabled\" value=\"\">");
  printf("<input type=hidden name=\"priority\" value=\"\">");
  printf("<input type=hidden name=\"old_priority\" value=\"\">");
  printf("<input type=hidden name=\"band\" value=\"\">");
  printf("<table style=\"table-layout:fixed; border-collapse:collapse; border-style:none none none none; width:100%%;\">\n");
  printf("<COL WIDTH=\"30\"><COL WIDTH=\"80\"><COL WIDTH=\"80\"><COL WIDTH=\"20\">\t\t<COL WIDTH=\"90\"><COL WIDTH=\"70\"><COL WIDTH=\"30\"><COL WIDTH=\"15\"><COL WIDTH=\"155\"><COL WIDTH=\"%%\">\n");
  v51 = sub_377A4(v3);
  if ( !v4 || !strncmp(v4, "all", 3u) )
  {
    v5 = 1;
    v6 = 0;
    sub_37770((int)&s);
    fw_read_db("user_fw", &v58);
    v7 = v59;
    while ( v7 && !*(_DWORD *)(v7 + 528) )
    {
      v8 = sub_3599C((const char **)&s, (const char *)v7) != 0;
      sub_36DE4(v5, v7, v8);
      v7 = *(_DWORD *)(v7 + 544);
      ++v6;
      ++v5;
    }
    v9 = v6;
    printf("<TR height=\"0\" id=\"_-guard_line\" class=\"fw_tr\" style=\"display:none;\">");
    printf((const char *)&unk_720DA);
    while ( 1 )
    {
      if ( !v7 || *(_DWORD *)(v7 + 528) != 1 )
      {
        v13 = 0;
        free_fw_status_list(&s);
        sub_3548C(0);
        v14 = 15 - v6;
        while ( v13 < v14 )
        {
          ++v13;
          sub_35454();
        }
        goto LABEL_61;
      }
      if ( !strcmp((const char *)(v7 + 536), "2g") )
      {
        v10 = "eth2";
      }
      else
      {
        if ( strcmp((const char *)(v7 + 536), "5g") )
          goto LABEL_17;
        v10 = "eth1";
      }
      if ( wireless_api_get_run(v10) )
      {
LABEL_17:
        v11 = sub_3599C((const char **)&s, (const char *)v7);
        ++v9;
        if ( v11 )
        {
          v12 = v9;
          v11 = 1;
        }
        else
        {
          v12 = v9;
        }
        ++v6;
        sub_368B0(v12, v7, v11);
        v7 = *(_DWORD *)(v7 + 544);
      }
      else
      {
        v7 = *(_DWORD *)(v7 + 544);
      }
    }
  }
  v15 = strncmp(v4, "internet", 8u);
  if ( v15 )
  {
    result = strncmp(v4, "wifi", 4u);
    if ( result )
      return result;
    sub_37770((int)&s);
    fw_read_db("user_fw", &v58);
    for ( i = v59; i && !*(_DWORD *)(i + 528); i = *(_DWORD *)(i + 544) )
      ;
    v24 = 0;
    v25 = 0;
    while ( 1 )
    {
      if ( !i || *(_DWORD *)(i + 528) != 1 )
      {
        sub_3548C(2u);
        v30 = 0;
        v31 = 15 - v25;
        while ( v30 < v31 )
        {
          ++v30;
          sub_35454();
        }
        goto LABEL_61;
      }
      if ( !strcmp((const char *)(i + 536), "2g") )
      {
        v26 = "eth2";
      }
      else
      {
        if ( strcmp((const char *)(i + 536), "5g") )
          goto LABEL_52;
        v26 = "eth1";
      }
      if ( wireless_api_get_run(v26) )
      {
LABEL_52:
        ++v24;
        if ( sub_3599C((const char **)&s, (const char *)i) )
        {
          sub_37724(v59, 1);
          v27 = i;
          v28 = 1;
          v29 = v24;
        }
        else
        {
          sub_37724(v59, 1);
          v27 = i;
          v28 = 0;
          v29 = v24;
        }
        sub_368B0(v29, v27, v28);
        i = *(_DWORD *)(i + 544);
        ++v25;
      }
      else
      {
        i = *(_DWORD *)(i + 544);
      }
    }
  }
  v16 = 1;
  sub_37770((int)&s);
  fw_read_db("user_fw", &v58);
  v17 = v59;
  while ( v17 && !*(_DWORD *)(v17 + 528) )
  {
    if ( sub_3599C((const char **)&s, (const char *)v17) )
    {
      sub_37724(v59, 0);
      v18 = v17;
      v19 = 1;
      v20 = v16;
    }
    else
    {
      sub_37724(v59, 0);
      v18 = v17;
      v19 = 0;
      v20 = v16;
    }
    sub_36DE4(v20, v18, v19);
    v17 = *(_DWORD *)(v17 + 544);
    ++v15;
    ++v16;
  }
  free_fw_status_list(&s);
  sub_3548C(1u);
  v21 = 0;
  while ( v21 < 15 - v15 )
  {
    ++v21;
    sub_35454();
  }
LABEL_61:
  printf((const char *)&unk_6E894);
  puts("<SCRIPT language=\"javascript\">");
  puts((const char *)&unk_6EE4F);
  puts("function onNewLineClicked(mode){");
  puts("\tvar obj = document.getElementById(\"_-new_line\");");
  puts("\tif(obj){ \n\tobj.scrollIntoView(true);");
  puts("\tif(mode){");
  puts("\t\tonClickedFWRule(mode,'','','','','','','','','','','','','','','','','');\n}");
  puts("\telse{");
  puts("\t\tonClickedFWRule('internet','','','','','','','','','','','','','','','','','');\n}");
  puts("\t}\n}");
  if ( v51 == -1 )
  {
    if ( !v4 || !strcmp(v4, "all") )
      printf("onNewLineClicked();");
    else
      printf("onNewLineClicked('%s');", v4);
    memset(&v55, 0, 0x20u);
    if ( !sub_35AE0(v3, "act", (int)&v55, 32) || strcmp(&v55, "add") || v58 <= 199 )
      goto LABEL_108;
    v34 = "alert('%s');";
    v35 = "규칙을 더 추가할 수 없습니다.";
  }
  else
  {
    v32 = v59;
    for ( j = 1; ; ++j )
    {
      v37 = 0;
      v36 = v32 < 0;
      if ( v32 )
      {
        v37 = __OFSUB__(j, v51);
        v36 = j - v51 < 0;
      }
      if ( !(v36 ^ v37) )
        break;
      v32 = *(_DWORD *)(v32 + 544);
    }
    if ( v32 )
    {
      if ( *(_DWORD *)(v32 + 528) )
      {
        if ( strcmp(v4, "internet") )
        {
          v49 = "true";
          if ( *(_DWORD *)(v32 + 512) )
            v49 = "false";
          printf(
            "onClickedFWRule('%s','%s','','','','','','',0,0,'','','%s',%d,'%04d','%04d',%s,0,'%s');",
            "wifi",
            v32,
            "drop",
            *(_DWORD *)(v32 + 516),
            *(_DWORD *)(v32 + 520),
            *(_DWORD *)(v32 + 524),
            v49,
            v32 + 536);
          goto LABEL_101;
        }
      }
      else if ( strcmp(v4, "wifi") )
      {
        v38 = *(_DWORD *)(v32 + 532);
        v39 = "internet";
        v40 = *(_BYTE *)(v38 + 176);
        if ( *(_BYTE *)(v38 + 176) )
          v39 = "site";
        v52 = v39;
        v41 = sub_359F4(*(_DWORD *)(v32 + 532));
        v53 = v41;
        v42 = strcmp(v41, "ip");
        v44 = (char *)*(_BYTE *)(v38 + 80);
        if ( !v42 )
          v43 = v38 + 16;
        if ( v42 )
          v43 = v38 + 144;
        v45 = v44 == 0;
        if ( !*(_BYTE *)(v38 + 80) )
          v44 = "all";
        if ( !v45 )
          v44 = "ip";
        if ( v40 )
          v46 = v38 + 176;
        else
          v46 = v38 + 80;
        v47 = "drop";
        if ( *(_DWORD *)(v38 + 448) == 1 )
          v47 = "accept";
        v48 = "false";
        if ( !*(_DWORD *)(v32 + 512) )
          v48 = "true";
        printf(
          "onClickedFWRule('%s','%s','%s','%s','%s','%s','%s','%s',%d,%d,'%s','%s','%s',%d,'%04d','%04d',%s,%d);",
          v52,
          v32,
          v53,
          v43,
          v38 + 48,
          v44,
          v46,
          v38 + 112,
          *(_DWORD *)(v38 + 440),
          *(_DWORD *)(v38 + 444),
          v38,
          v38 + 432,
          v47,
          *(_DWORD *)(v32 + 516),
          *(_DWORD *)(v32 + 520),
          *(_DWORD *)(v32 + 524),
          v48,
          v51);
        goto LABEL_101;
      }
      printf("onNewLineClicked('%s');", v4);
LABEL_101:
      printf("\tvar obj = document.getElementById('%s');", v32);
      v50 = "\tif(obj) obj.scrollIntoView(true);";
LABEL_107:
      printf(v50);
      goto LABEL_108;
    }
    if ( !v4 || !strcmp(v4, "all") )
    {
      v50 = "onNewLineClicked();";
      goto LABEL_107;
    }
    v34 = "onNewLineClicked('%s');";
    v35 = v4;
  }
  printf(v34, v35);
LABEL_108:
  printf("parent.document.firewall_fm.rule_count.value = %d;", v58);
  printf("onLoadCompleted(parent.document);");
  printf("</SCRIPT>");
  printf("</BODY>");
  return free_fw_list(&v58);
}
// 105BC: using guessed type int __fastcall free_fw_list(_DWORD);
// 10808: using guessed type int __fastcall wireless_api_get_run(_DWORD);
// 10B68: using guessed type int __fastcall free_fw_status_list(_DWORD);
// 1118C: using guessed type int __fastcall fw_read_db(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (00038488) --------------------------------------------------------
int sub_38488()
{
  void *v0; // r4@1
  int v1; // r7@1
  char *v2; // r0@1
  void *v3; // r8@2
  int i; // r6@2
  int v5; // r0@4
  char *v6; // r0@9
  char *v7; // r0@10
  void *v8; // r5@10
  int v9; // r6@10
  char v11; // [sp+4h] [bp-64h]@1
  char v12; // [sp+18h] [bp-50h]@1
  char v13; // [sp+2Ch] [bp-3Ch]@1

  sub_3555C();
  printf("<BODY style=\"display:block; vertical-align:middle; padding:0 0 0 0; margin:0 0 0 0; border:0 0 0 0; overflow:hidden;\">");
  printf("<form action=\"timepro.cgi\" method=\"post\" name=\"firewall_maclist_fm\" style=\"margin:0; border:0; padding:0;\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"macsearch_firewall\">");
  printf("<table class=v3_table height=22>");
  v0 = malloc(0xBC00u);
  memset(v0, 0, 0xBC00u);
  v1 = get_hostinfo_from_arp("br0", 256, v0);
  get_ifconfig("br0", &v12, &v11);
  puts("<select name=\"macselect\" class=\"fw_select\" style=\"width:145px; overflow:hidden;\" \t\tonchange=\"parent.onClickedMacSelect(parent.document);\">");
  printf("<option value=\"none\">%s</option>", "MAC 주소 선택");
  v2 = getenv("REMOTE_ADDR");
  get_internal_pc_hardware_address(v2, &v13);
  if ( v13 )
  {
    v3 = v0;
    for ( i = 0; i < v1; ++i )
    {
      v5 = strcmp((const char *)v3 + 148, &v13);
      v3 = (char *)v3 + 188;
      if ( !v5 )
      {
        if ( !dhcpd_search_static_lease(0, &v13) )
        {
          v6 = getenv("REMOTE_ADDR");
          printf((const char *)&unk_724B1, &v13, &v13, v6);
        }
        break;
      }
    }
  }
  v7 = getenv("REMOTE_ADDR");
  v8 = v0;
  get_internal_pc_hardware_address(v7, &v13);
  v9 = 0;
  while ( v9 < v1 )
  {
    if ( !dhcpd_search_static_lease((char *)v8 + 128, 0)
      && !dhcpd_search_static_lease(0, (char *)v8 + 148)
      && strcmp(&v13, (const char *)v8 + 148)
      && check_same_network((char *)v8 + 128, &v12, &v11) )
    {
      printf((const char *)&unk_724B1, (char *)v8 + 148, (char *)v8 + 148, (char *)v8 + 128);
    }
    ++v9;
    v8 = (char *)v8 + 188;
  }
  printf("<option value=\"search\">%s</option>", "MAC주소 재검색");
  printf("</select>");
  free(v0);
  printf((const char *)&unk_6E894);
  return printf("</BODY>");
}
// 1040C: using guessed type int __fastcall get_hostinfo_from_arp(_DWORD, _DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 11984: using guessed type int __fastcall check_same_network(_DWORD, _DWORD, _DWORD);
// 1199C: using guessed type int __fastcall dhcpd_search_static_lease(_DWORD, _DWORD);

//----- (000386A0) --------------------------------------------------------
int __fastcall sub_386A0(int a1, int a2)
{
  int v2; // r4@1
  const char *v3; // r0@3
  const char *v4; // r1@3
  int v5; // r0@5
  int v6; // r0@5
  int v8; // [sp+0h] [bp-88h]@1

  v2 = a2;
  sub_3555C();
  printf("<BODY style=\"display:block; vertical-align:middle; padding:0 0 0 0; margin:0 0 0 0; border:0 0 0 0; overflow:hidden;\">");
  printf("<form action=\"timepro.cgi\" method=\"post\" name=\"firewall_file_fm\" enctype=\"multipart/form-data\">");
  printf("<input type=hidden name=\"tmenu\" value=\"iframe\">");
  printf("<input type=hidden name=\"smenu\" value=\"restore_firewall\">");
  printf("<input type=\"hidden\" name=\"commit\" value=\"fw_restore\">");
  printf("<table class=v3_table height=26>");
  printf("<tr class=\"fw_tr\"><td width=\"10\" class=\"fw_td\"></td><td width=94 class=\"fw_td\">");
  printf(
    "<input type=button name=\"saverulebtn\" value=\"%s\" onclick=\"self.location.href='download_firewall.cgi'\" ",
    "PC<-규칙저장");
  printf("class=\"fw_button\" style=\"width:94px; text-align:center;\"></td>");
  printf("<td width=94><input type=button value=\"%s\" onclick=\"parent.Firewall_Restore();\" ", "PC->규칙복원");
  printf("class=\"fw_button\" style=\"width:94px; text-align:center;\"></td>");
  printf("<td><input type=file name=\"fw_restore_file\" maxlength=100 style=\"padding:1 0 1 0; margin:0 0 0 5;\"></td>");
  printf((const char *)&unk_6E88F);
  printf("</BODY>");
  printf("<script>");
  if ( get_value_post_multipart(v2, "commit", &v8, 128) )
  {
    if ( firewall_update_by_file("/tmp/user_fw.set.tmp", "/var/run/stat_fw.set", "user_fw") == -1 )
    {
      v3 = "alert('%s');";
      v4 = "규칙 복원에 실패하였습니다.";
    }
    else
    {
      v3 = "alert('%s');";
      v4 = "규칙 복원에 성공하였습니다.";
    }
    printf(v3, v4);
    printf("parent.UnMaskIt(parent.document,'restore_mask');");
    v5 = printf("parent.onChangedFWView(parent.parent.frames[3].document.getElementById('fw_select_menu').value);");
    v6 = signal_update(v5);
    signal_save(v6);
  }
  printf("parent.onLoadCompleted(parent.document);");
  return printf("</script>");
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108EC: using guessed type int __fastcall firewall_update_by_file(_DWORD, _DWORD, _DWORD);
// 10DD8: using guessed type int __fastcall get_value_post_multipart(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00038810) --------------------------------------------------------
FILE *__fastcall sub_38810(int a1, int a2)
{
  FILE *result; // r0@1
  FILE *v3; // r4@1
  char v4; // [sp+8h] [bp-90h]@1
  void *ptr; // [sp+88h] [bp-10h]@1
  size_t n; // [sp+8Ch] [bp-Ch]@1

  n = 0;
  get_value_post_multipart_file(a2, "fw_restore_file", &ptr, &v4);
  result = fopen("/tmp/user_fw.set.tmp", "w+");
  v3 = result;
  if ( result )
  {
    fwrite(ptr, 1u, n, result);
    result = (FILE *)fclose(v3);
  }
  return result;
}
// 10C1C: using guessed type int __fastcall get_value_post_multipart_file(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003971C) --------------------------------------------------------
int __fastcall sub_3971C(int a1)
{
  int v1; // r5@1
  int v2; // r0@4
  signed int v3; // r3@4
  int v5; // [sp+0h] [bp-38h]@1
  int v6; // [sp+20h] [bp-18h]@1
  int v7; // [sp+24h] [bp-14h]@1

  v1 = a1;
  get_arp_protection(&v6, &v7, &v5);
  if ( !get_intvalue(v1, "arp_protection", &v6) )
    v6 = 0;
  if ( v6 )
  {
    v2 = get_intvalue(v1, "period", &v7);
    if ( !v2 )
      v3 = 10;
    if ( !v2 )
      v7 = v3;
    if ( !get_value(v1, "ifname", &v5, 32) )
      strcpy((char *)&v5, "vlan1");
  }
  if ( check_unpermitted_chars(&v5) )
    strcpy((char *)&v5, "vlan1");
  set_arp_protection(v6, v7, &v5);
  return 0;
}
// 10994: using guessed type int __fastcall set_arp_protection(_DWORD, _DWORD, _DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10E20: using guessed type int __fastcall get_arp_protection(_DWORD, _DWORD, _DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000397F0) --------------------------------------------------------
int __fastcall sub_397F0(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  char v3; // r3@5
  char v4; // r3@9
  char v5; // r3@13
  char v6; // r3@17
  char v7; // r3@21
  char v8; // r3@25
  int v9; // r0@27
  int v10; // r0@27
  int v11; // [sp+0h] [bp-C0h]@1
  char v12; // [sp+80h] [bp-40h]@3
  char v13; // [sp+A0h] [bp-20h]@7
  char v14; // [sp+A1h] [bp-1Fh]@11
  char v15; // [sp+A2h] [bp-1Eh]@15
  char v16; // [sp+A3h] [bp-1Dh]@19
  char v17; // [sp+A4h] [bp-1Ch]@23
  char v18; // [sp+A5h] [bp-1Bh]@27

  v1 = a1;
  result = get_value(a1, "act", &v11, 128);
  if ( result )
  {
    result = strcmp((const char *)&v11, "dos_submit");
    if ( !result )
    {
      if ( get_value(v1, "synflood", &v12, 32) && !strcmp(&v12, "on") )
        v3 = 49;
      else
        v3 = 48;
      v13 = v3;
      if ( get_value(v1, "smurf", &v12, 32) && !strcmp(&v12, "on") )
        v4 = 49;
      else
        v4 = 48;
      v14 = v4;
      if ( get_value(v1, "sourceroute", &v12, 32) && !strcmp(&v12, "on") )
        v5 = 49;
      else
        v5 = 48;
      v15 = v5;
      if ( get_value(v1, "ipspoof", &v12, 32) && !strcmp(&v12, "on") )
        v6 = 49;
      else
        v6 = 48;
      v16 = v6;
      if ( get_value(v1, "icmpblock", &v12, 32) && !strcmp(&v12, "on") )
        v7 = 49;
      else
        v7 = 48;
      v17 = v7;
      if ( get_value(v1, "internal_icmpbk", &v12, 32) && !strcmp(&v12, "on") )
        v8 = 49;
      else
        v8 = 48;
      v18 = v8;
      apply_dos_config(&v13);
      v9 = sub_3971C(v1);
      v10 = signal_update(v9);
      result = signal_save(v10);
    }
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 110CC: using guessed type int __fastcall apply_dos_config(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (000399F0) --------------------------------------------------------
const char *__fastcall sub_399F0(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  int v3; // r0@4
  int v4; // r1@4
  char *v5; // r4@4
  int v6; // r0@9
  int v7; // [sp+0h] [bp-210h]@5
  char dest; // [sp+100h] [bp-110h]@4

  v1 = a1;
  result = (const char *)get_pvalue(a1, "act");
  if ( result )
  {
    result = (const char *)strcmp(result, "csrf");
    if ( !result )
    {
      result = (const char *)get_pvalue(v1, "csrf");
      if ( result )
      {
        v3 = atoi(result);
        set_csrf_op(v3);
        v4 = get_pvalue(v1, "whitedomains");
        v5 = &dest;
        if ( !v4 )
          goto LABEL_12;
        sf_strncpy(&dest, v4, 256);
        sf_strncpy(&v7, &dest, 256);
        strtoupper(&v7);
        if ( strstr((const char *)&v7, "<SCRIPT>") )
          strcpy(&dest, "");
        v5 = &dest;
        if ( check_unpermitted_chars(&dest) )
LABEL_12:
          strcpy(v5, "");
        v6 = set_csrf_whites(&dest);
        result = (const char *)signal_save(v6);
      }
    }
  }
  return result;
}
// 101FC: using guessed type int __fastcall set_csrf_op(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1034C: using guessed type int __fastcall set_csrf_whites(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00039AE0) --------------------------------------------------------
int __fastcall sub_39AE0(int a1)
{
  int v1; // r7@1
  int v2; // r0@1
  int v3; // r0@1
  char *v4; // r1@2
  char *v5; // r1@5
  int v6; // r0@7
  int v7; // r0@7
  int v8; // r0@7
  int v9; // r0@7
  int v10; // r0@7
  int v11; // r0@7
  int v12; // r0@7
  int v13; // r0@7
  int v15; // [sp+0h] [bp-118h]@1

  v1 = get_csrf_op(a1);
  get_csrf_whites(&v15);
  printf("<form method= get action=\"timepro.cgi\" name=\"csrf_fm\">");
  printf("<input type=hidden name=\"tmenu\" value=\"firewallconf\">");
  printf("<input type=hidden name=\"smenu\" value=\"etc\">");
  printf("<input type=hidden name=\"act\" value=\"csrf\">");
  v2 = print_sub_title("악성 스크립트 접근 방지(CSRF)", 1);
  v3 = print_start_content_table(v2);
  str(v3);
  printf("<td width=120 class=\"itemdesc_td\">%s</td>", "동작 설정");
  printf("<td class=item_td>");
  if ( v1 )
    v4 = "checked";
  else
    v4 = "";
  printf("<input type=radio name=csrf value=1 %s> 실행", v4);
  print_nbsp(5);
  if ( v1 )
    v5 = "";
  else
    v5 = "checked";
  printf("<input type=radio name=csrf value=0 %s> 중단", v5);
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  printf("<td width=120 rowspan=2 class=\"itemdesc_td\">%s</td>", "접근 허용 도메인");
  printf("<td class=item_td>");
  printf("<input type=text name=\"whitedomains\" maxlength=256 size=64 value='%s'>\n", &v15);
  v8 = printf("</td>");
  v9 = etr(v8);
  str(v9);
  printf("<td class=item_td><font color='gray'>");
  printf("※ 추가할  도메인들을  콤마(,)로 구분하여 나열하면 됩니다. (최대 3개 허용)<br>※ http://와 같은 프로토콜 부분을 제외한 도메인만 입력하세요. <br>※ (예) white1.ipdisk.co.kr,whihte2.domain2.com,white3.domain3.com");
  v10 = printf("</td>");
  v11 = etr(v10);
  str(v11);
  printf("<td colspan=2 class=item_td align=right>");
  printf("<input type=button name=dos_submit class=navi_bt value=\"적용\" onclick=\"submitCSRF();\">");
  v12 = printf("</td>");
  v13 = etr(v12);
  print_end_content_table(v13);
  return printf("</form>");
}
// 1088C: using guessed type int __fastcall get_csrf_whites(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 10FB8: using guessed type int __fastcall get_csrf_op(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00039C60) --------------------------------------------------------
int sub_39C60()
{
  int v0; // r0@1
  int v1; // r0@1
  char *v2; // r1@2
  char *v3; // r1@5
  int v4; // r0@7
  int v5; // r0@7
  int v6; // r0@7
  int v7; // r0@7
  char *v8; // r1@8
  char *v9; // r1@11
  int v10; // r0@13
  int v11; // r0@13
  int v12; // r0@13
  int v13; // r0@13
  char *v14; // r1@14
  char *v15; // r1@17
  int v16; // r0@19
  int v17; // r0@19
  int v18; // r0@19
  int v19; // r0@19
  char *v20; // r1@20
  char *v21; // r1@23
  int v22; // r0@25
  int v23; // r0@25
  int v24; // r0@25
  int v25; // r0@25
  char *v26; // r1@26
  char *v27; // r1@29
  int v28; // r0@31
  char *v29; // r2@32
  char *v30; // r2@35
  int v31; // r0@37
  int v32; // r0@37
  int v33; // r0@37
  int v34; // r0@37
  int v35; // r0@37
  int v36; // r0@37
  char *v37; // r1@38
  char *v38; // r1@41
  int v39; // r0@43
  int v40; // r0@43
  char *v41; // r1@44
  char *v42; // r1@47
  int v43; // r0@49
  int v44; // r0@49
  int v45; // r0@49
  int v46; // r0@49
  int v48; // [sp+0h] [bp-50h]@25
  char v49; // [sp+20h] [bp-30h]@1
  char v50; // [sp+21h] [bp-2Fh]@7
  char v51; // [sp+22h] [bp-2Eh]@13
  char v52; // [sp+23h] [bp-2Dh]@19
  char v53; // [sp+24h] [bp-2Ch]@37
  char v54; // [sp+25h] [bp-2Bh]@43
  int v55; // [sp+30h] [bp-20h]@25
  int v56; // [sp+34h] [bp-1Ch]@25

  read_dos_config(&v49);
  printf("<form method= get action=\"timepro.cgi\" name=\"firewallconfetc\">");
  printf("<input type=hidden name=\"tmenu\" value=\"firewallconf\">");
  printf("<input type=hidden name=\"smenu\" value=\"etc\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  v0 = print_sub_title("기타 보안 설정", 1);
  v1 = print_start_content_table(v0);
  str(v1);
  printf("<td width=120 rowspan=2 class=\"itemdesc_td\">%s</td>", "SYN Flood");
  printf("<td class=item_td>");
  if ( v49 == 48 )
    v2 = "";
  else
    v2 = "checked";
  printf("<input type=radio name=synflood value=on %s> 실행", v2);
  print_nbsp(5);
  if ( v49 == 48 )
    v3 = "checked";
  else
    v3 = "";
  printf("<input type=radio name=synflood value=off %s> 중단", v3);
  v4 = printf("</td>");
  v5 = etr(v4);
  str(v5);
  printf("<td class=item_td><font color='gray'>");
  printf("TCP가 데이터를 보내기 전에 연결을 맺어야 하는 연결 지향(connection-oriented) 방식이라는 점을 착안하여 많은 수의 SYN bit이 설정 되어있는, 즉 연결을 요청하는 TCP 패킷을 호스트의 특정 포트에 보내어 포트의 대기 큐(backlog queue)를 가득차게 하여 포트에 들어오는 연결 요청을 큐가 빌 때 까지(connection time out이 될 때 까지) 무시하도록 하게 끔 하는 공격방식.");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  printf("<td rowspan=2 class=\"itemdesc_td\">%s</td>", "Smurf");
  printf("<td class=item_td>");
  if ( v50 == 48 )
    v8 = "";
  else
    v8 = "checked";
  printf("<input type=radio name=smurf value=on %s> 실행", v8);
  print_nbsp(5);
  if ( v50 == 48 )
    v9 = "checked";
  else
    v9 = "";
  printf("<input type=radio name=smurf value=off %s> 중단", v9);
  v10 = printf("</td>");
  v11 = etr(v10);
  str(v11);
  printf("<td class=item_td><font color='gray'>");
  printf(" ping의 목적지주소를 브로드캐스트 주소로 사용하는 공격방식. Smurf 공격은 Echo-request 패킷을 어떤 네트웍의 브로드캐스트 주소로 보내면 해당 네트워크의 모든 호스트가 request 패킷에 응답하느라 다른 일은 하지 못하도록 하는 공격방식.");
  v12 = printf("</td>");
  v13 = etr(v12);
  str(v13);
  printf("<td rowspan=2 class=\"itemdesc_td\">%s</td>", "IP source routing");
  printf("<td class=item_td>");
  if ( v51 == 48 )
    v14 = "";
  else
    v14 = "checked";
  printf("<input type=radio name=sourceroute value=on %s> 실행", v14);
  print_nbsp(5);
  if ( v51 == 48 )
    v15 = "checked";
  else
    v15 = "";
  printf("<input type=radio name=sourceroute value=off %s> 중단", v15);
  v16 = printf("</td>");
  v17 = etr(v16);
  str(v17);
  printf("<td class=item_td><font color='gray'>");
  printf("RFC 1122에 따르면 목적지의 경로에 대한 세부적인 내용을 담고 있는 IP Source Routing은 목적지 호스트에서도 같은 경로를 따라 반응을 해야 하다는 문제점이 있다. 크래커가 특정 네트워크에 Source Routing 패킷을 보낼 수 있다면 돌아오는 반응을 가로채서 상대방의 신뢰받은 호스트처럼 속일 수 있다.");
  v18 = printf("</td>");
  v19 = etr(v18);
  str(v19);
  printf("<td rowspan=2 class=\"itemdesc_td\">%s</td>", "IP Spoofing");
  printf("<td class=item_td>");
  if ( v52 == 48 )
    v20 = "";
  else
    v20 = "checked";
  printf("<input type=radio name=ipspoof value=on %s> 실행", v20);
  print_nbsp(5);
  if ( v52 == 48 )
    v21 = "checked";
  else
    v21 = "";
  printf("<input type=radio name=ipspoof value=off %s> 중단", v21);
  v22 = printf("</td>");
  v23 = etr(v22);
  str(v23);
  printf("<td class=item_noline_td><font color='gray'>");
  printf("네트워크 시스템에서 서로 신뢰관계에 있는 A, B 두 시스템간에는 A 시스템의 계정을 가지고 B 시스템을 액세스 할 수 있다. 이는 네트워크에서 신뢰관계를 형성하는 서비스가 네트워크 주소에 기반하여 이를 인증하기 때문이다. 이로 인해 IP Spoofing이 가능해 진다. IP Spoofing은 이 신뢰관계에 있는 두 시스템사이에서 해커의 호스트를 마치 하나의 신뢰관계에 있는 호스트인 것처럼 속이는 것이다.");
  v24 = printf("</td>");
  etr(v24);
  v25 = get_arp_protection(&v55, &v56, &v48);
  str(v25);
  printf("<td rowspan=2 class=\"itemdesc_td\">%s</td>", "ARP Virus 방어 기능");
  printf("<td class=item_td>");
  if ( v55 )
    v26 = "checked";
  else
    v26 = "";
  printf((const char *)&unk_752F2, v26);
  print_nbsp(5);
  if ( v55 )
    v27 = "";
  else
    v27 = "checked";
  v28 = printf((const char *)&unk_7534C, v27);
  br(v28);
  printf("초당 <input type=text name=period size=3 maxlength=3 value=%d>", v56);
  printf("개의 ARP를 ");
  printf("<select name=ifname>");
  if ( !strcmp((const char *)&v48, "vlan1") )
    v29 = "selected";
  else
    v29 = "";
  printf("<option value=%s %s> %s", "vlan1", v29, "유선네트워크");
  if ( !strcmp((const char *)&v48, "br0") )
    v30 = "selected";
  else
    v30 = "";
  printf("<option value=%s %s> %s", "br0", v30, "유,무선네트워크");
  printf("</select>");
  printf("%s", "로 전송합니다.");
  v31 = printf("</td>");
  v32 = etr(v31);
  str(v32);
  printf("<td class=item_noline_td><font color='gray'>");
  printf("ARP Virus 방어 기능은 ARP를 통한 공격(ARP snoofing)을 방어하는 기능입니다.");
  v33 = printf("</td>");
  v34 = etr(v33);
  v35 = print_end_content_table(v34);
  v36 = print_start_content_table(v35);
  str(v36);
  printf("<td rowspan=1 width=370 class=\"itemdesc_td\">%s</td>", "인터넷으로부터 오는 ICMP(ping) 막기");
  printf("<td class=item_noline_td>");
  if ( v53 == 48 )
    v37 = "";
  else
    v37 = "checked";
  printf("<input type=radio name=icmpblock value=on %s> 실행", v37);
  print_nbsp(5);
  if ( v53 == 48 )
    v38 = "checked";
  else
    v38 = "";
  printf("<input type=radio name=icmpblock value=off %s> 중단", v38);
  v39 = printf("</td>");
  v40 = etr(v39);
  str(v40);
  printf("<td rowspan=1 class=\"itemdesc_td\">%s</td>", "인터넷으로 나가는 ICMP(ping) 막기");
  printf("<td class=item_td>");
  if ( v54 == 48 )
    v41 = "";
  else
    v41 = "checked";
  printf("<input type=radio name=internal_icmpbk value=on %s> 실행", v41);
  print_nbsp(5);
  if ( v54 == 48 )
    v42 = "checked";
  else
    v42 = "";
  printf("<input type=radio name=internal_icmpbk value=off %s> 중단", v42);
  v43 = printf("</td>");
  v44 = etr(v43);
  str(v44);
  printf("<td colspan=2 class=item_td align=right>");
  printf("<input type=button name=dos_submit class=navi_bt value=\"적용\" onclick=\"submitDoS();\">");
  v45 = printf("</td>");
  v46 = etr(v45);
  print_end_content_table(v46);
  printf("</form>");
  printf("<script>");
  printf("ChangeARPProtection();");
  return printf("</script>");
}
// 10550: using guessed type int __fastcall read_dos_config(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10E20: using guessed type int __fastcall get_arp_protection(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003A1E0) --------------------------------------------------------
int __fastcall sub_3A1E0(int a1)
{
  int v1; // r4@1

  v1 = a1;
  puts("<script language=JavaScript>");
  puts("<!--");
  printf("alert(\"%s\");\n", v1);
  puts("//-->");
  return puts("</script>");
}

//----- (0003A22C) --------------------------------------------------------
int __fastcall sub_3A22C(const char *a1, int a2)
{
  const char *v2; // r4@1
  int v3; // r5@1
  int v4; // r6@1
  int v5; // r1@1
  int v6; // r2@1
  int v7; // r7@1
  int v8; // r1@1
  int v9; // r2@1
  int v10; // r6@2
  int v11; // r0@2
  int v12; // r0@2
  int v13; // r0@2
  char *v14; // r6@5
  int v15; // r0@7
  int v16; // r5@8
  int v17; // r0@10
  int v18; // r0@10
  int v19; // r0@10
  int v20; // r0@10
  char *v21; // r0@11
  char *v22; // r1@11
  int v23; // r2@11
  int v24; // r0@13
  int v25; // r0@13
  int v26; // r0@13
  int v27; // r0@13
  int v28; // r0@13
  int v29; // r0@13
  int v30; // r0@13
  char v32; // [sp+8h] [bp-40h]@10

  v2 = a1;
  v3 = a2;
  v4 = check_valid_account(a1);
  v7 = get_remote_mgmt_port(v4, v5, v6);
  get_remote_mgmt_flag(v7, v8, v9);
  printf("<form name=\"%s_ipform\" method=post action=\"timepro.cgi\">\n", v2);
  puts("<input type=hidden name=\"tmenu\" value=\"firewallconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"accesslist\">");
  puts("<input type=\"hidden\" name=\"act\" value=\"\">");
  printf("<input type=\"hidden\" name=\"nopassword\" value=\"%d\">\n");
  printf("<table width=100%% cellspacing=0px cellpadding=0px>\n");
  if ( !strcmp(v2, "ext") )
  {
    v10 = strcmp((const char *)v3, "run") == 0;
    v11 = print_sub_title("외부 접속 보안", 0);
    str(v11);
    printf("<td class=itemdesc_td width=200>");
    printf("<input type=checkbox class=navi_chk name=rmgmt_chk %s  onclick=\"disableFormAccessList();\"> %s");
    puts("</td>");
    puts("<td class=item_td align=left>");
    printf("<input type=text name=rmgmt_port maxlength=5 size=5 value=%d style=\"width:45\">\n", v7);
    v12 = puts("</td>");
    v13 = etr(v12);
  }
  else
  {
    v10 = strcmp((const char *)(v3 + 36), "run") == 0;
    v13 = print_sub_title("내부 접속 보안", 0);
  }
  str(v13);
  puts("<td class=itemdesc_td width=180>");
  if ( v10 )
    v14 = "checked";
  else
    v14 = "";
  strcmp(v2, "ext");
  printf("<input type=checkbox class=navi_chk name=%s_chk %s onclick=\"disableFormAccessList();\"> %s", v2, v14);
  puts("</td>");
  printf("<td class=itemdesc_td align=right>");
  v15 = strcmp(v2, "ext");
  if ( v15 )
    v16 = *(_DWORD *)(v3 + 68);
  else
    v16 = *(_DWORD *)(v3 + 32);
  v17 = get_remote_addr(v15);
  printf(
    "<input class=navi_bt type=button name=%s_bt value=\"적용\" onclick=\"%s_RemoteConn(%d, '%s');\">\n",
    v2,
    v2,
    v16,
    v17);
  v18 = puts("</td>");
  etr(v18);
  v19 = puts("</table>");
  br(v19);
  v20 = printf("<table width=100%% class=\"menu_content_list_table\" cellspacing=0px cellpadding=0px>\n");
  str(v20);
  print_item_desc("허용 할 IP 주소");
  puts("<td class=item_td colspan=2>");
  snprintf(&v32, 0x20u, "%s_regip", v2, "");
  if ( !strcmp(v2, "ext") )
  {
    v21 = &v32;
    v22 = "";
    v23 = 1;
  }
  else
  {
    v21 = &v32;
    v22 = "";
    v23 = 3;
  }
  sub_157CC((int)v21, v22, v23);
  v24 = puts("</td>");
  v25 = etr(v24);
  str(v25);
  print_item_desc("설명");
  puts("<td class=itemd_td>");
  print_nbsp(3);
  printf("<input type=text name=\"%s_ipexplan\" size=12 maxlength=12>\n", v2);
  puts("</td>");
  puts("<td class=itemd_td align=left>");
  printf("<input class=navi_br type=button name=\"%s_ipadd\" value=\"추가\" onclick=\"%s_IPadd();\">\n", v2, v2);
  v26 = puts("</td>");
  v27 = etr(v26);
  str(v27);
  puts("<td class=itemd_td colspan=3>");
  v28 = puts("</td>");
  v29 = etr(v28);
  str(v29);
  printf("<td class=item_td colspan=3><font color='gray'>");
  printf("추가 가능한 최대 주소는 %d개 입니다.", 10);
  v30 = printf("</td>");
  etr(v30);
  puts("</table>");
  return printf("</form>");
}
// 10148: using guessed type int __fastcall get_remote_addr(_DWORD);
// 106A0: using guessed type int __cdecl get_remote_mgmt_port(_DWORD, _DWORD, _DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 1145C: using guessed type int __cdecl get_remote_mgmt_flag(_DWORD, _DWORD, _DWORD);

//----- (0003A5B4) --------------------------------------------------------
int __fastcall sub_3A5B4(const char *a1, int a2)
{
  const char *v2; // r4@1
  int v3; // r5@1
  int v4; // r5@2
  int v5; // r5@3
  int v6; // r0@4
  int v7; // r5@4
  int v8; // r0@4
  int v9; // r0@4
  int v10; // r0@5
  int v11; // r0@6
  int v13; // [sp+4h] [bp+0h]@5
  char v14; // [sp+84h] [bp+80h]@5

  v2 = a1;
  v3 = a2;
  if ( !strcmp(a1, "ext") )
    v4 = *(_BYTE *)(v3 + 32);
  else
    v5 = *(_BYTE *)(v3 + 68);
  printf("<form name=\"%s_ipform_list\" method=post action=\"timepro.cgi\">\n", v2);
  puts("<input type=hidden name=\"tmenu\" value=\"firewallconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"accesslist\">");
  puts("<input type=\"hidden\" name=\"act\" value=\"\">");
  v6 = printf("<table width=100%% class=\"menu_content_list_table\" cellspacing=0px cellpadding=0px>\n");
  str(v6);
  printf("<td class=slim_itemdesc_td></td>");
  printf("<td class=itemdesc_td width=100>%s</td>", "IP 주소");
  printf("<td class=slim_itemdesc_td width=150>%s</td>", "설명");
  puts("<td class=\"slim_itemdesc_td\" align=left>");
  v7 = 0;
  v8 = printf("<input class=navi_bt type=button name=\"%s_ipdel\" %s value=\"삭제\" onclick=\"%s_IPdel();\">", v2);
  br(v8);
  printf(
    "<input type=checkbox name=\"%s_allcheck\" onclick=\"CheckAllCheckBox(document, this, '%s_delchk');\">\n",
    v2,
    v2);
  v9 = puts("</td>");
  etr(v9);
  do
  {
    v10 = accesslist_get_ip(v2, v7, &v14, &v13);
    if ( !v10 )
      break;
    ++v7;
    str(v10);
    printf("<td class=\"slim_item_td\" >%d</td>\n", v7);
    printf("<td class=\"item_td\">");
    puts(&v14);
    printf("</td>");
    printf("<td class=\"slim_item_td\">");
    printf("<font color='gray'>%s</font>", &v13);
    printf("</td>");
    puts("<td class=\"slim_item_td\" align=left width=60>");
    printf("<input type=checkbox name=\"%s_delchk\" value=\"%s\">\n", v2, &v14);
    v11 = puts("</td>");
    etr(v11);
  }
  while ( v7 != 10 );
  puts("</table>");
  return puts("</form>");
}
// 10460: using guessed type int __fastcall accesslist_get_ip(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (0003A788) --------------------------------------------------------
int __fastcall sub_3A788(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1

  v1 = a1;
  print_start_main_table(a1);
  v2 = print_blank_line(1, 10);
  v3 = print_start_content_table(v2);
  str(v3);
  puts("<td class=item_td valign=top width=305>");
  sub_3A22C("ext", v1);
  sub_3A5B4("ext", v1);
  printf("</td>");
  printf("<td class=item_leftline_td valign=top width=305>");
  sub_3A22C("int", v1);
  sub_3A5B4("int", v1);
  puts("<br>");
  v4 = printf("</td>");
  v5 = etr(v4);
  v6 = print_end_content_table(v5);
  print_end_main_table(v6);
  puts("<script language=JavaScript>");
  printf("disableFormAccessList();");
  return puts("</script>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10E44: using guessed type int __fastcall print_start_main_table(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11180: using guessed type int __fastcall print_end_main_table(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003ADA8) --------------------------------------------------------
int __fastcall sub_3ADA8(int a1, int a2, int a3)
{
  signed int v3; // r7@1
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r6@1
  void *v7; // r0@1
  int v8; // r3@1
  unsigned int v9; // r1@4
  int v10; // r1@5
  bool v11; // cf@6
  bool v12; // zf@6
  int v13; // r9@7
  const char *v14; // r0@9
  const char *v15; // r0@11
  int *v16; // r0@12
  const char *v17; // r1@12
  signed int v18; // r2@15
  const char *v19; // r10@20
  int v20; // r3@24
  const char *v21; // r0@25
  int v22; // r3@32
  int v23; // r2@32
  int v24; // r3@32
  int v25; // r1@37
  int v26; // r3@39
  const char *v27; // r1@42
  int v28; // r2@52
  int v29; // r3@54
  int v30; // r0@55
  int v32; // [sp+0h] [bp-60h]@1
  char s; // [sp+4h] [bp-5Ch]@1

  v3 = 0;
  v4 = a3;
  v5 = a1;
  v6 = a2;
  v32 = 0;
  v7 = memset(&s, 0, 0x3Cu);
  v8 = *(_DWORD *)(v4 + 52);
  if ( !(v8 & 1) )
  {
    if ( !(v8 & 2) )
      return 0;
    v3 = 1;
  }
  str(v7);
  printf("<td class=\"item_td\" width=10>%d</td>\n", dword_91758);
  puts("<td class=\"item_td\" width=100>");
  v9 = *(_DWORD *)(v4 + 96 * v3 + 112);
  if ( (v9 & 0x80000000) != 0 )
  {
    v10 = v3 + 1;
LABEL_8:
    printf("%s<br>%s\n", v4 + 96 * v10, v4 + 96 * v3 + 120);
    goto LABEL_19;
  }
  v11 = v9 >= 0x20;
  v12 = v9 == 32;
  v10 = v3 + 1;
  if ( !v12 && v11 )
    goto LABEL_8;
  v13 = 96 * v10;
  v14 = (const char *)get_twinip_wan_virtual_ip("wan1");
  if ( strcmp((const char *)(v4 + v13), v14) )
  {
    v15 = (const char *)get_twinip_wan_virtual_ip("wan2");
    if ( !strcmp((const char *)(v4 + v13), v15) )
    {
      v16 = &v32;
      v17 = (const char *)&unk_7603A;
    }
    else
    {
      v16 = &v32;
      if ( !*(_BYTE *)(v4 + v13) )
      {
        v17 = "모든 IP 주소";
        v16 = &v32;
        v18 = 64;
        goto LABEL_17;
      }
      v17 = (const char *)(v4 + v13);
    }
    v18 = 16;
LABEL_17:
    sf_strncpy(v16, v17, v18);
    goto LABEL_18;
  }
  strcpy((char *)&v32, "Twin IP");
LABEL_18:
  puts((const char *)&v32);
LABEL_19:
  puts("</td>");
  puts("<td class=\"item_td\" width=100>");
  if ( !v5 || (v19 = (const char *)(v5 + 8), !strcmp((const char *)(v5 + 8), "USER_TYPE")) )
  {
    if ( !v6 || (v19 = (const char *)(v6 + 8), !strcmp((const char *)(v6 + 8), "USER_TYPE")) )
    {
      v20 = *(_DWORD *)(v4 + 96 * v3 + 92);
      if ( v20 == 6 )
      {
        v21 = "TCP";
      }
      else if ( v20 == 17 )
      {
        v21 = "UDP";
      }
      else
      {
        if ( v20 != 255 )
        {
          putchar(32);
LABEL_32:
          print_nbsp(1);
          v22 = v4 + 96 * v3;
          v23 = *(_WORD *)(v22 + 142);
          v24 = v22 + 136;
          if ( v23 )
          {
            printf((const char *)&unk_7606E, *(_WORD *)(v24 + 4));
          }
          else if ( *(_WORD *)(v24 + 4) )
          {
            printf("%d");
          }
          goto LABEL_36;
        }
        v21 = "TCP/UDP";
      }
      printf(v21);
      goto LABEL_32;
    }
  }
  puts(v19);
LABEL_36:
  puts("</td>");
  puts("<td class=\"item_td\" width=110>");
  if ( v5 )
    v25 = *(_BYTE *)(v5 + 45);
  else
    v25 = *(_BYTE *)(v6 + 45);
  printf("%s", (char *)&unk_8FAE0 + 32 * v25);
  v26 = v4 + 96 * v3;
  if ( *(_BYTE *)(v26 + 120) || *(_DWORD *)(v26 + 112) )
  {
    if ( *(_DWORD *)(v4 + 96 * v3 + 112) < 0 )
      v27 = "대역폭 개별할당";
    else
      v27 = "대역폭 통합할당";
    printf("<br>%s\n", v27);
  }
  puts("</td>");
  puts("<td class=\"item_td\" width=60>");
  if ( v5 )
  {
    *(_BYTE *)(v5 + 44);
    printf("%d %s", *(_DWORD *)(v5 + 40));
  }
  else
  {
    printf("------");
  }
  puts("</td>");
  puts("<td class=\"item_td\" width=60>");
  if ( v6 )
  {
    *(_BYTE *)(v6 + 44);
    printf("%d %s", *(_DWORD *)(v6 + 40));
  }
  else
  {
    printf("------");
  }
  puts("</td>");
  puts("<td class=\"item_td\" align=right >");
  if ( v5 )
    v28 = *(_DWORD *)v5;
  if ( v6 )
    v29 = *(_DWORD *)v6;
  printf("<input type=checkbox name=\"%s_del\" value=\"%d %d\"\n");
  v30 = puts("</td>");
  etr(v30);
  return 0;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 91758: using guessed type int dword_91758;

//----- (0003B188) --------------------------------------------------------
int __fastcall sub_3B188(int a1)
{
  int v1; // r6@1
  int v2; // r5@1
  int v3; // r0@1
  const char *v4; // r4@1
  int v5; // r0@3
  int v6; // r0@4
  int v7; // r1@4
  int v8; // r2@4
  int v9; // r7@4
  char v10; // r3@6
  int v11; // r0@6
  int v12; // r1@9
  int v13; // r2@9

  v1 = a1;
  v2 = 0;
  class_id_list_get(0);
  v3 = printf("<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">");
  str(v3);
  print_item_desc("");
  print_item_desc("IP 주소");
  print_item_desc("조건");
  print_item_desc("동작 방법");
  print_item_desc("다운로드");
  print_item_desc("업로드");
  printf("<td align=right class=\"itemdesc_td\">");
  v4 = "gr";
  if ( v1 == 2 )
    v4 = "lr";
  printf(
    "<input type=button class=navi_bt name=\"del_ip\" value=\"삭제\" onclick=\"deleteIpType('%s_del');\">\t\n",
    v4);
  printf("<input type=checkbox name=\"allchk\" onclick=\"CheckAllCheckBox(document, this, '%s_del');\">\n", v4);
  v5 = puts("</td>");
  etr(v5);
  do
  {
    v6 = class_get(v2);
    v9 = v6;
    if ( !*(_DWORD *)v6 )
      break;
    if ( *(_BYTE *)(v6 + 45) == v1 )
    {
      v10 = *(_BYTE *)(v6 + 38);
      v11 = *(_DWORD *)(v6 + 248);
      if ( (unsigned __int8)(v10 - 2) <= 1u )
      {
        ++dword_91758;
        if ( v11 )
          v11 = class_find(v11, v7, v8);
        v12 = v11;
        v13 = v9;
        v11 = v9;
        goto LABEL_12;
      }
      if ( !v11 )
      {
        v12 = v9;
        v13 = v9;
        ++dword_91758;
LABEL_12:
        sub_3ADA8(v11, v12, v13);
        goto LABEL_13;
      }
    }
LABEL_13:
    ++v2;
  }
  while ( v2 != 62 );
  return puts("</table>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10F4C: using guessed type int __cdecl class_find(_DWORD, _DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11558: using guessed type int __fastcall class_id_list_get(_DWORD);
// 11A68: using guessed type int __fastcall class_get(_DWORD);
// 91758: using guessed type int dword_91758;

//----- (0003C39C) --------------------------------------------------------
signed int __fastcall sub_3C39C(int a1, signed int *a2)
{
  int v2; // r4@1
  int v3; // r0@1
  signed int v4; // r4@4
  int v5; // r6@5
  int v6; // r0@7
  int v7; // r0@9
  int v8; // r0@11
  unsigned __int8 v9; // r9@11
  int v10; // r0@13
  signed int v11; // r5@20
  signed int v12; // r4@22
  int v13; // r0@24
  int v14; // r0@27
  int v15; // r10@29
  signed int v16; // r3@37
  signed int v17; // r11@39
  int v18; // r4@46
  signed int v19; // r0@47
  int v20; // r8@52
  signed int v21; // r2@54
  signed int v22; // r7@59
  signed int v23; // r2@61
  bool v24; // zf@65
  bool v25; // nf@65
  signed int v26; // r0@69
  int v27; // r5@77
  const char *v28; // r10@78
  char *v29; // r9@78
  int v30; // r0@79
  int v31; // r0@81
  int v32; // r1@85
  int v33; // r1@92
  int v34; // r2@92
  const char *v35; // r0@92
  int v37; // [sp+14h] [bp-10Ch]@5
  int v38; // [sp+18h] [bp-108h]@6
  int v39; // [sp+1Ch] [bp-104h]@9
  int v40; // [sp+20h] [bp-100h]@11
  signed int *v41; // [sp+24h] [bp-FCh]@1
  char v42; // [sp+28h] [bp-F8h]@7
  char v43; // [sp+A8h] [bp-78h]@1
  char dest[4]; // [sp+C8h] [bp-58h]@5
  char v45; // [sp+CCh] [bp-54h]@5
  int v46; // [sp+DCh] [bp-44h]@5
  char s; // [sp+E0h] [bp-40h]@5
  int v48; // [sp+ECh] [bp-34h]@35
  __int16 v49; // [sp+F0h] [bp-30h]@5
  __int16 v50; // [sp+F2h] [bp-2Eh]@5
  __int16 v51; // [sp+F4h] [bp-2Ch]@5
  __int16 v52; // [sp+F6h] [bp-2Ah]@5

  v2 = a1;
  v41 = a2;
  tc_open(a1);
  v3 = get_value(v2, "act", &v43, 32);
  if ( v3 )
  {
    if ( !strcmp(&v43, "add_user_type") )
    {
      v3 = get_value(v2, "eid", &v43, 32);
      if ( !v3 )
      {
        v4 = 0;
LABEL_90:
        v5 = 1;
        goto LABEL_92;
      }
      v5 = atoi(&v43);
      v46 = 0;
      memset(&s, 0, 0xCu);
      *(_DWORD *)dest = 0;
      memset(&v45, 0, 0xCu);
      v51 = 0;
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v3 = sub_1535C(v2, 0, (int)"dn");
      v37 = v3;
      if ( v3 < 0 || (v3 = sub_1535C(v2, 0, (int)"up"), v38 = v3, v3 < 0) )
      {
        v12 = -7;
        goto LABEL_72;
      }
      v6 = get_value(v2, "dnu", &v42, 32);
      if ( v6 )
        v6 = (unsigned __int8)atoi(&v42);
      v39 = v6;
      v7 = get_value(v2, "upu", &v42, 32);
      if ( v7 )
        v7 = (unsigned __int8)atoi(&v42);
      v40 = v7;
      v8 = get_value(v2, "pty", &v42, 32);
      v9 = v8;
      if ( v8 )
        v9 = atoi(&v42);
      get_value(v2, "sel_addr", &v42, 32);
      v10 = atoi(&v42);
      if ( v10 )
      {
        if ( v10 == 1 )
        {
          v13 = get_twinip_wan_virtual_ip("wan1");
          sf_strncpy(&v46, v13, 16);
        }
        v11 = 0;
      }
      else
      {
        get_ip_value(v2, "sip", &v46);
        get_ip_value(v2, "eip", dest);
        if ( !strcmp((const char *)&v46, dest) )
          strcpy(dest, "");
        if ( dest[0] && check_ippool_range(&v46, dest) )
        {
          if ( get_value(v2, "bpi_chk", &v42, 32) && !strcmp(&v42, "on") )
          {
            inet_addr((const char *)&v46);
            v11 = 2147483648;
          }
          else
          {
            v11 = 33;
          }
        }
        else
        {
          v11 = (unsigned __int8)dest[0];
          if ( dest[0] )
          {
            v12 = -1;
            puts("<script>");
            puts("\t\talert(\"IP 주소가 잘못 되었습니다\");");
            v3 = puts("</script>");
LABEL_72:
            *v41 = v12;
            v4 = 0;
            goto LABEL_92;
          }
        }
      }
      v14 = get_value(v2, "app_port0", &v42, 32);
      if ( v14 )
        LOWORD(v14) = atoi(&v42);
      v51 = v14;
      v15 = get_value(v2, "app_port1", &v42, 32);
      if ( v15 )
        v15 = (unsigned __int16)atoi(&v42);
      v52 = v15;
      if ( v51 || v15 )
      {
        v15 = get_value(v2, "protocol", &v42, 32);
        if ( v15 )
          v15 = atoi(&v42);
      }
      v3 = tc_count_file_read(&v48);
      if ( v48 > 30 )
      {
        v12 = -2;
        goto LABEL_72;
      }
      v16 = v37;
      if ( v37 )
        v16 = 1;
      v17 = v38;
      if ( v38 )
        v17 = 1;
      if ( v17 & v16 )
      {
        if ( v5 != 1 )
          v3 = 3;
        if ( v5 == 1 )
          v3 = 2;
        v18 = check_bandwidth_limitation(v3, v37, v39, v9);
        if ( v5 == 1 )
          v19 = 4;
        else
          v19 = 5;
        v3 = check_bandwidth_limitation(v19, v38, v40, v9);
        if ( (v3 | v18) < 0 )
        {
          v12 = -3;
          goto LABEL_72;
        }
      }
      else if ( !v16 )
      {
        v12 = -2;
        v20 = -2;
        goto LABEL_58;
      }
      if ( v5 == 1 )
        v21 = 2;
      else
        v21 = 3;
      v3 = class_create("USER_TYPE", 0, v21, v37);
      v12 = v3;
      if ( v3 < 0 )
        goto LABEL_72;
      v20 = filter_add_to_class(v3, v15, &v46, v11);
LABEL_58:
      if ( v17 )
      {
        if ( v5 == 1 )
          v23 = 4;
        else
          v23 = 5;
        v3 = class_create("USER_TYPE", 0, v23, v38);
        v22 = v3;
        if ( v3 < 0 )
        {
          v12 = v3;
          goto LABEL_72;
        }
        v20 = filter_add_to_class(v3, v15, &v46, v11);
      }
      else
      {
        v22 = -2;
      }
      v24 = v22 == 0;
      v25 = v22 < 0;
      if ( v22 > 0 )
      {
        v24 = v12 == 0;
        v25 = v12 < 0;
      }
      if ( !v25 && !v24 )
        class_make_couple(v12, v22);
      tc_count_file_write(++v48);
      v26 = v12;
      v12 = v20;
      v3 = class_priority_order_write(v26, v22, 0);
      goto LABEL_72;
    }
    v3 = strcmp(&v43, "del");
    if ( !v3 )
    {
      if ( get_value(v2, "pty", &v42, 128) )
      {
        atoi(&v42);
        snprintf(dest, 0x14u, "%s_del");
      }
      else
      {
        strcpy(dest, "");
        printf("Property : %s <br>", "None");
      }
      v27 = 0;
      tc_count_file_read(&v48);
      while ( get_value_array(v2, dest, v27, &v42) )
      {
        v28 = strtok(&v42, " ");
        v29 = strtok(0, " ");
        if ( v28 )
        {
          v30 = atoi(v28);
          class_destroy(v30);
        }
        if ( v29 )
        {
          v31 = atoi(v29);
          class_destroy(v31);
        }
        ++v27;
        --v48;
        if ( v28 )
          v28 = (const char *)atoi(v28);
        if ( v29 )
          v32 = atoi(v29);
        else
          v32 = 0;
        class_priority_order_write(v28, v32, -1);
      }
      v4 = 0;
      v3 = tc_count_file_write(v48);
      *v41 = 0;
      goto LABEL_90;
    }
  }
  v4 = 1;
  v5 = 1;
LABEL_92:
  tc_close(v3);
  v35 = "wan2";
  if ( v5 == 1 )
    v35 = "wan1";
  tc_reconfig(v35, v33, v34, "wan1");
  return v4;
}
// 101E4: using guessed type int __fastcall tc_count_file_read(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1067C: using guessed type int __fastcall class_make_couple(_DWORD, _DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 10E68: using guessed type int __fastcall class_create(_DWORD, _DWORD, _DWORD, _DWORD);
// 1109C: using guessed type int __cdecl filter_add_to_class(_DWORD, _DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11258: using guessed type int __cdecl tc_reconfig(_DWORD, _DWORD, _DWORD, _DWORD);
// 113CC: using guessed type int __fastcall class_destroy(_DWORD);
// 11408: using guessed type int __fastcall tc_count_file_write(_DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 1166C: using guessed type int __fastcall class_priority_order_write(_DWORD, _DWORD, _DWORD);
// 116CC: using guessed type int __fastcall check_ippool_range(_DWORD, _DWORD);
// 119F0: using guessed type int __fastcall check_bandwidth_limitation(_DWORD, _DWORD, _DWORD, _DWORD);
// 11AB0: using guessed type int __fastcall tc_close(_DWORD);
// 11BA0: using guessed type int __cdecl tc_open(_DWORD);

//----- (0003CB10) --------------------------------------------------------
int __fastcall sub_3CB10(int a1)
{
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1

  tc_open(a1);
  v1 = puts("<table width=600 style=\"border-collapse:collapse;\" cellspacing=0>");
  str(v1);
  print_item_desc("프로토콜");
  puts("<td class=\"item_td\">");
  puts("<select name=\"protocol\" style=\"font-size:9pt;\">");
  puts("<option value=\"0\">---------");
  printf("<option value=\"%d\" > TCP\n", 6);
  printf("<option value=\"%d\" > UDP\n", 17);
  printf("<option value=\"%d\" > TCP/UDP\n", 255);
  puts("</select>");
  puts("</td>");
  print_item_desc("외부포트");
  puts("<td colspan=3 class=\"item_td\">");
  puts((const char *)&unk_774DC);
  puts("<input type=text name=\"app_port1\" maxlength=5 size=5 value=\"\">");
  v2 = puts("</td>");
  v3 = etr(v2);
  str(v3);
  puts("<td colspan=5 class=\"item_td\"><span class=gray_text>");
  printf("최대 %d개의 규칙이 설정 가능합니다.", 31);
  puts("</span></td>");
  puts("<td class=\"item_td\" align=right >");
  puts("<input type=button name=\"set_user_type\" value=\"적용\" onclick=\"setupIpType(90,1,100);\">");
  v4 = puts("</td>");
  etr(v4);
  v5 = puts("</table>");
  tc_close(v5);
  return 0;
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11AB0: using guessed type int __fastcall tc_close(_DWORD);
// 11BA0: using guessed type int __cdecl tc_open(_DWORD);

//----- (0003CC70) --------------------------------------------------------
int __fastcall sub_3CC70(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // r4@1
  int v7; // r11@1
  int v8; // r5@1
  int v9; // r0@1
  int v10; // r6@1
  int v11; // r1@4
  int v12; // r1@7
  int v13; // r1@9
  char v15; // [sp+14h] [bp-34h]@1
  __int16 v16; // [sp+1Ch] [bp-2Ch]@1
  __int16 v17; // [sp+1Eh] [bp-2Ah]@1

  v6 = a4;
  v7 = 38 * a5;
  v8 = a2;
  v15 = a1;
  v16 = 0;
  v17 = 0;
  v9 = class_create(&dword_8FE74[38 * a5 + 17], 0, a1, a6);
  v10 = v9;
  if ( v9 >= 0 )
  {
    if ( dword_8FE74[v7 + 33] && (unsigned __int8)(v15 - 4) <= 1u )
    {
      v11 = dword_8FE74[v7 + 34];
      if ( v11 > 0 )
      {
        filter_add_to_class(v9, v11, v8, v6);
        if ( dword_8FE74[38 * a5] == 2 )
          filter_add_to_class(v10, dword_8FE74[38 * a5 + 34], v8, v6);
      }
      v12 = dword_8FE74[38 * a5 + 36];
      if ( v12 > 0 )
      {
LABEL_13:
        filter_add_to_class(v10, v12, v8, v6);
        return v10;
      }
    }
    else
    {
      v13 = dword_8FE74[38 * a5 + 34];
      if ( v13 > 0 )
      {
        filter_add_to_class(v9, v13, v8, v6);
        if ( dword_8FE74[38 * a5] == 4 )
          filter_add_to_class(v10, dword_8FE74[38 * a5 + 34], v8, v6);
      }
      v12 = dword_8FE74[38 * a5 + 36];
      if ( v12 > 0 )
        goto LABEL_13;
    }
  }
  return v10;
}
// 10E68: using guessed type int __fastcall class_create(_DWORD, _DWORD, _DWORD, _DWORD);
// 1109C: using guessed type int __cdecl filter_add_to_class(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003CF78) --------------------------------------------------------
signed int __fastcall sub_3CF78(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r11@1
  int v5; // r0@1
  signed int v6; // r4@10
  int v7; // r0@12
  int v8; // r0@14
  int v9; // r9@16
  int v10; // r0@18
  unsigned __int8 v11; // r7@18
  int v12; // r8@20
  int v13; // r10@23
  int v14; // r0@25
  signed int v15; // r3@27
  int v16; // r4@34
  signed int v17; // r0@35
  int v18; // r0@42
  signed int v19; // r5@46
  int v20; // r0@51
  bool v21; // zf@52
  bool v22; // nf@52
  signed int v23; // r0@56
  int v25; // [sp+1Ch] [bp-7Ch]@16
  int v26; // [sp+20h] [bp-78h]@17
  char v27; // [sp+2Ch] [bp-6Ch]@1
  int v28; // [sp+4Ch] [bp-4Ch]@1
  char v29; // [sp+50h] [bp-48h]@1
  int v30; // [sp+5Ch] [bp-3Ch]@1
  char s; // [sp+60h] [bp-38h]@1
  int v32; // [sp+6Ch] [bp-2Ch]@25

  v2 = 0;
  v3 = a1;
  v4 = a2;
  v30 = 0;
  memset(&s, 0, 0xCu);
  v28 = 0;
  memset(&v29, 0, 0xCu);
  get_value(v3, "sel_addr", &v27, 32);
  v5 = atoi(&v27);
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      v7 = get_twinip_wan_virtual_ip("wan1");
      sf_strncpy(&v30, v7, 16);
    }
  }
  else
  {
    get_ip_value(v3, "sip", &v30);
    get_ip_value(v3, "eip", &v28);
    if ( !strcmp((const char *)&v30, (const char *)&v28) )
      strcpy((char *)&v28, "");
    if ( (_BYTE)v28 && check_ippool_range(&v30, &v28) )
    {
      if ( get_value(v3, "bpi_chk", &v27, 32) && !strcmp(&v27, "on") )
      {
        inet_addr((const char *)&v30);
        v2 = 2147483648;
      }
      else
      {
        v2 = 33;
      }
    }
    else
    {
      v2 = (unsigned __int8)v28;
      if ( (_BYTE)v28 )
      {
        v6 = -1;
        puts("<script>");
        puts("\t\talert(\"IP 주소가 잘못 되었습니다\");");
        puts("</script>");
        return v6;
      }
    }
  }
  v8 = get_value(v3, "app_id", &v27, 32);
  if ( v8 )
    v8 = atoi(&v27);
  v25 = v8;
  v9 = sub_1535C(v3, 0, (int)"dn");
  if ( v9 < 0 )
    return -7;
  v26 = sub_1535C(v3, 0, (int)"up");
  if ( v26 < 0 )
    return -7;
  v10 = get_value(v3, "pty", &v27, 32);
  v11 = v10;
  if ( v10 )
    v11 = atoi(&v27);
  v12 = get_value(v3, "dnu", &v27, 32);
  if ( v12 )
    v12 = (unsigned __int8)atoi(&v27);
  if ( get_value(v3, "upu", &v27, 32) )
    v13 = (unsigned __int8)atoi(&v27);
  else
    v13 = 0;
  v14 = tc_count_file_read(&v32);
  if ( v32 > 30 )
    return -2;
  v15 = v9;
  if ( v9 )
    v15 = 1;
  if ( (v26 != 0) & (unsigned __int8)v15 )
  {
    if ( v4 != 1 )
      v14 = 3;
    if ( v4 == 1 )
      v14 = 2;
    v16 = check_bandwidth_limitation(v14, v9, v12, v11);
    if ( v4 == 1 )
      v17 = 4;
    else
      v17 = 5;
    if ( (check_bandwidth_limitation(v17, v26, v13, v11) | v16) < 0 )
      return -3;
LABEL_41:
    if ( v4 == 1 )
      v18 = 2;
    else
      v18 = 3;
    v14 = sub_3CC70(v18, (int)&v30, (int)&v28, v2, v25, v9);
    v6 = v14;
    if ( v14 < 0 )
      return v6;
    goto LABEL_45;
  }
  if ( v15 )
    goto LABEL_41;
  v6 = -2;
LABEL_45:
  if ( v26 != 0 )
  {
    if ( v4 != 1 )
      v14 = 5;
    if ( v4 == 1 )
      v14 = 4;
    v20 = sub_3CC70(v14, (int)&v30, (int)&v28, v2, v25, v26);
    v19 = v20;
    if ( v20 < 0 )
      return v20;
  }
  else
  {
    v19 = -2;
  }
  v21 = v19 == 0;
  v22 = v19 < 0;
  if ( v19 > 0 )
  {
    v21 = v6 == 0;
    v22 = v6 < 0;
  }
  if ( !v22 && !v21 )
    class_make_couple(v6, v19);
  tc_count_file_write(++v32);
  v23 = v6;
  v6 = 0;
  class_priority_order_write(v23, v19, 0);
  return v6;
}
// 101E4: using guessed type int __fastcall tc_count_file_read(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1067C: using guessed type int __fastcall class_make_couple(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11408: using guessed type int __fastcall tc_count_file_write(_DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 1166C: using guessed type int __fastcall class_priority_order_write(_DWORD, _DWORD, _DWORD);
// 116CC: using guessed type int __fastcall check_ippool_range(_DWORD, _DWORD);
// 119F0: using guessed type int __fastcall check_bandwidth_limitation(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003D4B4) --------------------------------------------------------
signed int __fastcall sub_3D4B4(int a1, signed int *a2)
{
  int v2; // r5@1
  signed int *v3; // r7@1
  signed int v4; // r0@1
  signed int v5; // r6@2
  signed int v6; // r4@4
  int v7; // r0@5
  int v8; // r1@7
  int v9; // r2@7
  const char *v10; // r0@7
  int v12; // [sp+0h] [bp-38h]@1

  v2 = a1;
  v3 = a2;
  tc_open(a1);
  v4 = get_value(v2, "act", &v12, 32);
  if ( !v4 || (v4 = strcmp((const char *)&v12, "add_apps_type"), (v5 = v4) != 0) )
  {
    v5 = 1;
    v6 = 1;
  }
  else
  {
    v4 = get_value(v2, "eid", &v12, 32);
    if ( v4 )
    {
      v7 = atoi((const char *)&v12);
      v6 = v7;
      v4 = sub_3CF78(v2, v7);
      *v3 = v4;
    }
    else
    {
      v5 = 0;
      v6 = 1;
    }
  }
  tc_close(v4);
  v10 = "wan2";
  if ( v6 == 1 )
    v10 = "wan1";
  tc_reconfig(v10, v8, v9, "wan1");
  return v5;
}
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11258: using guessed type int __cdecl tc_reconfig(_DWORD, _DWORD, _DWORD, _DWORD);
// 11AB0: using guessed type int __fastcall tc_close(_DWORD);
// 11BA0: using guessed type int __cdecl tc_open(_DWORD);

//----- (0003D57C) --------------------------------------------------------
int sub_3D57C()
{
  int v0; // r5@1
  int v1; // r4@1
  int v2; // r0@1
  _DWORD *v3; // r2@2
  int v4; // r1@2
  int v5; // r0@3
  int v6; // r0@3
  int v7; // r0@3

  v0 = 0;
  v1 = 0;
  v2 = puts("<table width=600 style=\"border-collapse:collapse;\" cellspacing=0>");
  str(v2);
  print_item_desc("어플리케이션");
  puts("<td class=item_td>");
  puts("<select name=\"app_id\">");
  do
  {
    v3 = &dword_8FE74[38 * v1];
    v4 = dword_8FE74[v0];
    ++v1;
    v0 += 38;
    printf("<option value=\"%d\"> %s\n", v4, v3 + 17);
  }
  while ( v1 != 6 );
  puts("</select>");
  puts("</td>");
  v5 = puts("<td class=item_td></td>");
  v6 = etr(v5);
  str(v6);
  puts((const char *)&unk_77656);
  printf("최대 %d개의 규칙이 설정 가능합니다.", 31);
  puts("</span></td>");
  puts("<td class=\"item_td\" align=right>");
  puts("<input type=button name=\"set_apps_type\" value=\"적용\" onclick=\"setupAppType(90,1,100);\">");
  v7 = puts("</td>");
  etr(v7);
  return puts("</table>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);

//----- (0003D694) --------------------------------------------------------
int __fastcall sub_3D694(signed __int64 a1, char *a2)
{
  char *v2; // r6@1
  unsigned int v3; // r7@3
  int v4; // r0@3
  const char *v5; // r1@3
  int v6; // r3@3
  char *v7; // r0@3
  int v9; // r0@6

  v2 = a2;
  if ( (unsigned __int64)a1 > 0x40000000 )
  {
    v3 = a1 >> 30;
    v6 = sub_4EC48(a1 & 0x3FFFFFFF, 108003328);
    v5 = "%d.%d GB";
    v7 = v2;
    return sprintf(v7, v5, v3, v6);
  }
  if ( (unsigned int)a1 > 0x100000 )
  {
    v3 = (unsigned int)a1 >> 20;
    v4 = sub_4F2E8(a1 & 0xFFFFF, 105472LL);
    v5 = "%d.%d MB";
    v6 = v4;
    v7 = v2;
    return sprintf(v7, v5, v3, v6);
  }
  if ( (unsigned int)a1 > 0x400 )
  {
    v3 = (unsigned int)a1 >> 10;
    v9 = sub_4F2E8(a1 & 0x3FF, 103LL);
    v5 = "%d.%d KB";
    v6 = v9;
    v7 = v2;
    return sprintf(v7, v5, v3, v6);
  }
  return sprintf(a2, "%d B", (_DWORD)a1);
}

//----- (0003D780) --------------------------------------------------------
int __fastcall sub_3D780(int a1)
{
  int v1; // r5@1
  int result; // r0@1
  char s; // [sp+8h] [bp-138h]@5
  char v4; // [sp+108h] [bp-38h]@3
  char v5; // [sp+11Ch] [bp-24h]@1

  v1 = a1;
  result = get_value(a1, "act", &v5, 20);
  if ( result )
  {
    result = strcmp(&v5, "clear");
    if ( !result )
    {
      result = get_value(v1, "ip", &v4, 20);
      if ( result )
      {
        result = check_unpermitted_chars(&v4);
        if ( !result )
        {
          quote_r(&v4, 20);
          snprintf(&s, 0x100u, "echo '%s 32' >> %s", &v4, "/proc/ctproc/cleanup");
          system(&s);
          result = sleep(1u);
        }
      }
    }
  }
  return result;
}
// 10364: using guessed type int __fastcall quote_r(_DWORD, _DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003D844) --------------------------------------------------------
int __fastcall sub_3D844(_DWORD *a1, const char *a2, unsigned int **a3)
{
  _DWORD *v3; // r5@1
  const char *v4; // r10@1
  unsigned int **v5; // r8@1
  unsigned int *i; // r7@1
  int v7; // r0@7
  unsigned int v8; // r3@8
  int v9; // r3@10
  __int64 v10; // r0@13
  __int64 v11; // r2@13
  __int64 v12; // r0@13
  unsigned int *v13; // r0@16
  unsigned int *v14; // r6@16
  unsigned int *v15; // r4@16
  unsigned int v16; // r3@23
  int v17; // r3@25
  unsigned int *v18; // r3@28
  bool v19; // zf@28
  unsigned int v20; // r1@38
  unsigned int v21; // r2@38
  unsigned int v22; // r3@50

  v3 = a1;
  v4 = a2;
  v5 = a3;
  for ( i = *a3; i; i = (unsigned int *)i[13] )
  {
    if ( *i == *a1 )
    {
      if ( !strcmp(a2, "tcp") )
      {
        ++i[1];
      }
      else if ( !strcmp(v4, "udp") )
      {
        ++i[2];
      }
      else
      {
        v7 = strcmp(v4, "icmp");
        if ( v7 )
          v8 = i[4];
        else
          v8 = i[3];
        v9 = v8 + 1;
        if ( v7 )
          i[4] = v9;
        else
          i[3] = v9;
      }
      v10 = *((_QWORD *)v3 + 4);
      i[5] += v3[5];
      v11 = *((_QWORD *)i + 4) + v10;
      v12 = *((_QWORD *)v3 + 5);
      *((_QWORD *)i + 4) = v11;
      i[6] += v3[6];
      *((_QWORD *)i + 5) += v12;
      return v12;
    }
  }
  v13 = (unsigned int *)malloc(0x38u);
  v14 = v13;
  v15 = v13;
  if ( v13 )
  {
    memset(v13, 0, 0x38u);
    *v15 = *v3;
    LODWORD(v12) = strcmp(v4, "tcp");
    if ( (_DWORD)v12 )
    {
      LODWORD(v12) = strcmp(v4, "udp");
      if ( (_DWORD)v12 )
      {
        LODWORD(v12) = strcmp(v4, "icmp");
        if ( (_DWORD)v12 )
          v16 = v15[4];
        else
          v16 = v15[3];
        v17 = v16 + 1;
        if ( (_DWORD)v12 )
          v15[4] = v17;
        else
          v15[3] = v17;
      }
      else
      {
        ++v15[2];
      }
    }
    else
    {
      ++v15[1];
    }
    v15[5] = v3[5];
    *((_QWORD *)v15 + 4) = *((_QWORD *)v3 + 4);
    v15[6] = v3[6];
    *((_QWORD *)v15 + 5) = *((_QWORD *)v3 + 5);
    v18 = *v5;
    v19 = *v5 == 0;
    if ( *v5 )
    {
      v18 = v5[1];
      v15[13] = 0;
    }
    else
    {
      v15[13] = 0;
    }
    if ( v19 )
    {
      v15[12] = (unsigned int)v18;
      v5[1] = v15;
      *v5 = v15;
    }
    else
    {
      v18[13] = (unsigned int)v15;
    }
    if ( !v19 )
    {
      v15[12] = (unsigned int)v18;
      v5[1] = v15;
    }
    do
    {
      v22 = v14[12];
      if ( !v22 )
        break;
      if ( __rev(*v14) < __rev(*(_DWORD *)v22) )
      {
        v20 = v14[13];
        v21 = *(_DWORD *)(v22 + 48);
        *(_DWORD *)(v22 + 52) = v20;
        if ( v20 )
          *(_DWORD *)(v20 + 48) = v22;
        else
          v5[1] = (unsigned int *)v22;
        if ( v21 )
        {
          v14[13] = v22;
          *(_DWORD *)(v22 + 48) = v14;
        }
        else
        {
          *(_DWORD *)(v22 + 48) = v14;
        }
        if ( v21 )
        {
          v14[12] = v21;
          *(_DWORD *)(v21 + 52) = v14;
        }
        else
        {
          v14[13] = v22;
          v14[12] = 0;
        }
        if ( !v21 )
          *v5 = v14;
      }
      v14 = (unsigned int *)v14[12];
    }
    while ( v14 );
  }
  else
  {
    LODWORD(v12) = puts("Out of memory!");
  }
  return v12;
}

//----- (0003DA9C) --------------------------------------------------------
FILE *__fastcall sub_3DA9C(unsigned int **a1)
{
  unsigned int **v1; // r11@1
  const char *v2; // r0@1
  FILE *result; // r0@1
  FILE *v4; // r8@1
  char *v5; // r9@3
  char *v6; // r0@4
  const char *v7; // r6@4
  char *v8; // r0@8
  const char *v9; // r6@8
  int v10; // r6@11
  char *v11; // r0@14
  const char *v12; // r6@14
  char *v13; // r0@20
  const char *v14; // r10@20
  char *v15; // r0@23
  int *v16; // r2@24
  int *v17; // r3@24
  int *v18; // r2@31
  int *v19; // r3@31
  in_addr_t v20; // [sp+0h] [bp-2B0h]@2
  in_addr_t v21; // [sp+4h] [bp-2ACh]@1
  in_addr_t v22; // [sp+8h] [bp-2A8h]@2
  in_addr_t v23; // [sp+Ch] [bp-2A4h]@2
  char v24; // [sp+10h] [bp-2A0h]@3
  in_addr_t v25; // [sp+210h] [bp-A0h]@3
  int v26; // [sp+224h] [bp-8Ch]@25
  int v27; // [sp+228h] [bp-88h]@24
  int v28; // [sp+230h] [bp-80h]@25
  int v29; // [sp+238h] [bp-78h]@24
  char s2; // [sp+24Ch] [bp-64h]@2
  char v31; // [sp+260h] [bp-50h]@2
  char v32; // [sp+274h] [bp-3Ch]@2

  v1 = a1;
  v2 = (const char *)get_twinip_wan_virtual_ip("wan1");
  v21 = inet_addr(v2);
  system("cat /proc/net/ip_conntrack > /var/run/ip_conntrack");
  result = fopen("/var/run/ip_conntrack", "r");
  v4 = result;
  if ( result )
  {
    get_ifconfig("br0", &s2, &v31);
    v22 = inet_addr(&s2);
    v20 = inet_addr(&v31);
    get_wan_ip("wan1", &v32);
    v23 = inet_addr(&v32);
    while ( fgets(&v24, 512, v4) )
    {
      memset(&v25, 0, 0x38u);
      v5 = strtok(&v24, " ");
      if ( strcmp(v5, "EXPECTING:") )
      {
        do
        {
          v6 = strtok(0, " ");
          v7 = v6;
        }
        while ( v6 && strncmp(v6, "src=", 4u) );
        sscanf(v7, "src=%s", &v32);
        v25 = inet_addr(&v32);
        if ( v25 == -1 )
        {
          puts("Data format is wrong!<BR>");
        }
        else
        {
          do
          {
            v8 = strtok(0, " ");
            v9 = v8;
          }
          while ( v8 && strncmp(v8, "dst=", 4u) );
          sscanf(v9, "dst=%s", &v32);
          if ( strcmp(&v32, &s2) )
          {
            v10 = (v22 ^ v25) & v20;
            if ( !v10 )
              goto LABEL_20;
            if ( v23 == v25 || v21 == v25 )
            {
              v10 = 0;
LABEL_20:
              while ( 1 )
              {
                v13 = strtok(0, " ");
                v14 = v13;
                if ( !v13 )
                  break;
                if ( !strncmp(v13, "org=", 4u) )
                {
                  if ( v10 )
                  {
                    v18 = &v26;
                    v19 = &v28;
                  }
                  else
                  {
                    v18 = &v27;
                    v19 = &v29;
                  }
                  sscanf(v14, (const char *)&unk_777B1, v18, v19, v20);
                  v15 = strtok(0, " ");
                  if ( v10 )
                  {
                    v16 = &v27;
                    v17 = &v29;
                  }
                  else
                  {
                    v16 = &v26;
                    v17 = &v28;
                  }
                  sscanf(v15, "rpl=%d:%llu", v16, v17);
                  break;
                }
              }
              sub_3D844(&v25, v5, v1);
            }
            else
            {
              do
              {
                v11 = strtok(0, " ");
                v12 = v11;
              }
              while ( v11 && strncmp(v11, "src=", 4u) );
              sscanf(v12, "src=%s", &v32);
              v25 = inet_addr(&v32);
              if ( v25 != -1 )
              {
                v10 = 1;
                goto LABEL_20;
              }
            }
          }
        }
      }
    }
    fclose(v4);
    result = (FILE *)unlink("/var/run/ip_conntrack");
  }
  return result;
}
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);

//----- (0003DD88) --------------------------------------------------------
int sub_3DD88()
{
  return get_file_value("/proc/sys/net/nf_conntrack_max", 1);
}
// 1097C: using guessed type int __fastcall get_file_value(_DWORD, _DWORD);

//----- (0003DD98) --------------------------------------------------------
int __fastcall sub_3DD98(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5; // r9@1
  unsigned int v6; // r7@1
  unsigned int v7; // r11@1
  unsigned int v8; // r10@1
  int v9; // r5@1
  int v10; // r4@1
  unsigned int v11; // r8@1
  unsigned int v12; // r0@1
  int v13; // r2@1
  int v14; // r3@1
  int v15; // r0@1
  int v16; // r2@1
  int v17; // r3@1
  int v18; // r0@1
  signed int v19; // r6@2
  unsigned int v20; // ST04_4@5
  unsigned int v21; // ST00_4@5
  unsigned int v22; // r0@5
  int v23; // r2@5
  unsigned int v24; // r0@5
  int v25; // r2@5
  int v26; // r0@5
  unsigned int v27; // r3@5
  int v28; // r2@5
  int v29; // r1@5
  int v30; // r0@5
  int v31; // ST0C_4@7
  unsigned int v32; // ST08_4@7
  unsigned int v33; // ST04_4@7
  unsigned int v34; // r0@7
  int v35; // r3@7
  unsigned int v36; // r0@7
  int v37; // r2@7
  int v38; // r0@8
  unsigned int v39; // ST0C_4@9
  unsigned int v40; // ST04_4@9
  unsigned int v41; // r0@9
  int v42; // r3@9
  int v43; // r0@9
  int v44; // r2@9
  int v45; // r3@9
  int v46; // r0@10
  unsigned int v47; // r0@11
  int v48; // r2@11
  int v49; // r3@11
  int v50; // ST04_4@11
  unsigned int v51; // r0@11
  int v52; // r3@11
  signed int v53; // r0@12
  unsigned int v54; // r0@15
  int v55; // r2@15
  int v56; // r3@15
  int v57; // r0@15
  int v58; // r2@15
  int v59; // r3@15
  int v60; // r0@15
  unsigned int v61; // r0@15
  unsigned int v62; // r0@17
  int v63; // r2@17
  int v64; // r3@17
  int v65; // r0@17
  int v66; // r2@17
  int v67; // r3@17
  int v68; // r0@17
  unsigned int v69; // r0@17
  unsigned int v70; // r0@19
  int v71; // r2@19
  int v72; // r3@19
  int v73; // r0@19
  int v74; // r2@19
  int v75; // r3@19
  int v76; // r0@19
  unsigned int v77; // r0@19
  unsigned int v78; // r0@21
  int v79; // r2@21
  int v80; // r3@21
  int v81; // r0@21
  int v82; // r2@21
  int v83; // r3@21
  int v84; // r0@21
  unsigned int v85; // r0@21
  int v86; // r1@22
  int v87; // r0@22
  int v89; // [sp+0h] [bp-40h]@5
  signed int v90; // [sp+Ch] [bp-34h]@14
  int v91; // [sp+10h] [bp-30h]@6
  unsigned int v92; // [sp+14h] [bp-2Ch]@1

  v5 = a2;
  v6 = a1;
  v7 = a3;
  v8 = a4;
  v9 = a2 + a1 + a3 + a4;
  v10 = sub_3DD88();
  v11 = sub_4EEE8(v9);
  v12 = sub_4EEE8(v10);
  v15 = sub_4F12C(v11, v12, v13, v14);
  v18 = sub_4EF94(v15, 0x42C80000u, v16, v17);
  v92 = sub_4F28C(v18);
  if ( a5 )
  {
    printf("<table border='0' cellpadding='0' cellspacing='0' width='%d'>\n", 410);
    v19 = 370;
    puts("<tr>");
    printf("<td width='%d'><font color='gray'>0</td>\n", 92);
    printf("<td width='%d'><font color='gray'>2</td>\n", 96);
    printf("<td width='%d'><font color='gray'>10</td>\n", 96);
    printf("<td width='%d'><font color='gray'>50</td>\n", 96);
    printf("<td width='10'><font color='gray'>100%%</td>\n");
    puts("<td width='38'></td>");
    puts("</tr>");
    puts("</table>");
  }
  else
  {
    v19 = 220;
  }
  if ( v9 > v10 / 2 )
  {
    v20 = sub_4EEE8(3 * v19 >> 2);
    v21 = sub_4EEE8(v10 / -2 + v9);
    v22 = sub_4EEE8(v10 / -2 + v10);
    v89 = sub_4F12C(v21, v22, v23, v21);
    v24 = sub_4EEE8((unsigned int)v19 >> 2);
    v26 = sub_4EF94(v89, v24, v25, v89);
    v28 = v20;
    v29 = v26;
    v30 = v20;
LABEL_10:
    v46 = sub_4ED50(v30, v29, v28, v27);
    goto LABEL_12;
  }
  v91 = sub_4EC48(v10, 10);
  if ( v9 > v91 )
  {
    v31 = sub_4EC48(v10, -10);
    v32 = sub_4EEE8((unsigned int)v19 >> 1);
    v33 = sub_4EEE8(v31 + v9);
    v34 = sub_4EEE8(v31 + v10 / 2);
    v89 = sub_4F12C(v33, v34, v33, v35);
    v36 = sub_4EEE8((unsigned int)v19 >> 2);
    v29 = sub_4EF94(v89, v36, v37, v89);
    v30 = v32;
    goto LABEL_10;
  }
  v38 = sub_4EC48(v10, 50);
  if ( v9 > v38 )
  {
    v39 = sub_4EEE8(v19 >> 2);
    v89 = sub_4EC48(v10, -50);
    v40 = sub_4EEE8(v89 + v9);
    v41 = sub_4EEE8(v89 + v91);
    v43 = sub_4F12C(v40, v41, v40, v42);
    v29 = sub_4EF94(v43, v39, v44, v45);
    v30 = v39;
    goto LABEL_10;
  }
  v89 = v19 >> 2;
  v47 = sub_4EEE8(v38);
  v50 = sub_4F12C(v11, v47, v48, v49);
  v51 = sub_4EEE8(v19 >> 2);
  v46 = sub_4EF94(v50, v51, v50, v52);
LABEL_12:
  v53 = sub_4F28C(v46);
  if ( v53 < 5 )
    v53 = 5;
  v90 = v53;
  printf(
    "<table border='0' cellpadding='0' cellspacing='0' style='border-width:1; border-style:solid;' width='%d'>\n",
    v19 + 40);
  puts((const char *)&unk_779CB);
  puts((const char *)&unk_7797F);
  printf("\t\t\t<table border='0' cellpadding='0' cellspacing='1' width='%d'>\n", v90);
  puts((const char *)&unk_779C8);
  if ( v6 )
  {
    v54 = sub_4EEE8(v6);
    v57 = sub_4F12C(v54, v11, v55, v56);
    v60 = sub_4EF94(v57, 0x42C80000u, v58, v59);
    v61 = sub_4F28C(v60);
    printf("\t\t\t\t\t<td width='%d%%' height='9' bgcolor='#4D9DCE' title='TCP %d'></td>\n", v61, v6);
  }
  if ( v5 )
  {
    v62 = sub_4EEE8(v5);
    v65 = sub_4F12C(v62, v11, v63, v64);
    v68 = sub_4EF94(v65, 0x42C80000u, v66, v67);
    v69 = sub_4F28C(v68);
    printf("\t\t\t\t\t<td width='%d%%' height='9' bgcolor='#FD8116' title='UDP %d'></td>\n", v69, v5);
  }
  if ( v7 )
  {
    v70 = sub_4EEE8(v7);
    v73 = sub_4F12C(v70, v11, v71, v72);
    v76 = sub_4EF94(v73, 0x42C80000u, v74, v75);
    v77 = sub_4F28C(v76);
    printf("\t\t\t\t\t<td width='%d%%' height='9' bgcolor='#74CA2D' title='ICMP %d'></td>\n", v77, v7);
  }
  if ( v8 )
  {
    v78 = sub_4EEE8(v8);
    v81 = sub_4F12C(v78, v11, v79, v80);
    v84 = sub_4EF94(v81, 0x42C80000u, v82, v83);
    v85 = sub_4F28C(v84);
    printf("\t\t\t\t\t<td width='%d%%' height='9' bgcolor='#F0C800' title='%s %d'></td>\n", v85, "Unknown", v8, v89);
  }
  puts((const char *)&unk_77AF5);
  puts((const char *)&unk_77AFF);
  puts((const char *)&unk_76948);
  printf("\t\t<td width='%d'></td>", v19 - v90);
  sub_4ED24(100 * v9, v10);
  v87 = sub_4EC48(100 * v86, v10);
  printf("\t\t<td width='90' align='center'><font color='gray'>%d.%02d%% (%d)</td>\n", v92, v87, v9, v89);
  puts((const char *)&unk_77AF8);
  return puts("</table>");
}

//----- (0003E240) --------------------------------------------------------
int __fastcall sub_3E240(int *a1)
{
  int *v1; // r4@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r9@2
  __int64 v6; // r0@2
  int v7; // r5@2
  int v8; // r11@2
  unsigned int v9; // r7@2
  unsigned int v10; // r10@2
  unsigned int v11; // r8@2
  unsigned int v12; // r6@2
  int v13; // r12@2
  __int64 v14; // r2@3
  char *v15; // r3@6
  int v16; // r0@8
  int v17; // r0@8
  int v18; // r0@8
  int v19; // r0@8
  int v20; // r0@11
  int v21; // r0@11
  int v22; // r0@11
  signed __int64 v24; // [sp+8h] [bp-D8h]@2
  signed __int64 v25; // [sp+10h] [bp-D0h]@2
  char v26; // [sp+18h] [bp-C8h]@11
  char s; // [sp+98h] [bp-48h]@2

  v1 = a1;
  str(a1);
  v2 = printf(
         "<td align='right'> \t\t<table><tr><td width=12 bgcolor='#4D9DCE'></td><td><font size=1 color='#4D9DCE'>TCP</td>"
         " \t\t   <td width=12 bgcolor='#FD8116'></td><td><font size=1 color='#FD8116'>UDP </td> \t\t   <td width=12 bgco"
         "lor='#74ca2d'></td><td> <font size=1 color='#74CA2D'>ICMP </td> \t\t   <td width=12 bgcolor='#F0c800'></td><td>"
         "<font size=1 color='#F0C800'> %s</td></tr> \t\t</table></td>\n",
         "Unknown");
  etr(v2);
  v3 = print_sub_title("전체 컨넥션 정보", 0);
  v4 = print_start_content_table(v3);
  if ( *v1 )
  {
    v5 = sub_3DD88();
    LODWORD(v6) = sprintf(&s, "%d", v5);
    v7 = 0;
    v24 = 0LL;
    v8 = 0;
    v25 = 0LL;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = *v1;
    while ( v13 )
    {
      v12 += *(_DWORD *)(v13 + 4);
      v11 += *(_DWORD *)(v13 + 8);
      v10 += *(_DWORD *)(v13 + 12);
      v9 += *(_DWORD *)(v13 + 16);
      v8 += *(_DWORD *)(v13 + 20);
      HIDWORD(v14) = HIDWORD(v24);
      v25 += *(_QWORD *)(v13 + 32);
      v7 += *(_DWORD *)(v13 + 24);
      v6 = *(_QWORD *)(v13 + 40);
      v13 = *(_DWORD *)(v13 + 52);
      LODWORD(v14) = v24 + v6;
      v24 = v14 + v6;
    }
    str(v6);
    if ( v5 )
      v15 = &s;
    else
      v15 = "제한 없음";
    printf(
      "<td class=itemdesc_td rowspan=2 width=420>%s (%d / %s) </td>\n",
      "현재 / 전체 컨넥션",
      v11 + v12 + v10 + v9,
      v15);
    print_item_desc("수신패킷");
    v16 = print_item_desc("수신바이트");
    v17 = etr(v16);
    str(v17);
    print_item_desc("송신패킷");
    v18 = print_item_desc("송신바이트");
    v19 = etr(v18);
    str(v19);
    puts("<td rowspan=2 height=40>");
    if ( v5 )
      sub_3DD98(v12, v11, v10, v9, 1);
    else
      printf(
        "<span style='font: normal normal normal 10px arial;'>TCP: %d, UDP: %d, ICMP: %d, %s: %d</span>",
        v12,
        v11,
        v10,
        "Unknown",
        v9);
    puts("</td>");
    printf("<td class=item_td width=100>%d</td>\n", v8);
    sub_3D694(v25, &v26);
    v20 = printf("<td class=item_td width=100>%s</td>\n", &v26);
    v21 = etr(v20);
    str(v21);
    printf("<td class=item_td width=100>%d</td>\n", v7);
    sub_3D694(v24, &v26);
    v22 = printf("<td class=item_td width=100>%s</td>\n", &v26);
    v4 = etr(v22);
  }
  return print_end_content_table(v4);
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003E4C4) --------------------------------------------------------
int __fastcall sub_3E4C4(int *a1)
{
  int *v1; // r4@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r4@1
  char v9; // r10@2
  int v10; // r8@2
  char *v11; // r0@3
  int v12; // r0@3
  char *v13; // r1@4
  const char *v14; // r0@6
  char *v15; // r0@7
  const char *v16; // r1@7
  const char *v17; // r0@8
  char *v18; // r1@18
  char *v19; // r4@24
  int v20; // r0@26
  int v21; // r0@26
  int v22; // r0@26
  int v24; // [sp+8h] [bp-158h]@1
  char v25; // [sp+10h] [bp-150h]@26
  char s; // [sp+90h] [bp-D0h]@3
  char v27; // [sp+BCh] [bp-A4h]@14
  char v28; // [sp+FCh] [bp-64h]@7
  char v29; // [sp+110h] [bp-50h]@3
  char s2; // [sp+124h] [bp-3Ch]@1

  v1 = a1;
  v24 = sub_3DD88();
  puts("<form method=get action=\"timepro.cgi\" name=\"conninfo_fm\">");
  puts("<input type=hidden name=\"tmenu\" value=\"trafficconf\">");
  puts("<input type=hidden name=\"smenu\" value=\"conninfo\">");
  puts("<input type=hidden name=\"act\" value=\"\">");
  puts("<input type=hidden name=\"ip\" value=\"\">");
  v2 = print_sub_title("IP별 컨넥션 정보", 1);
  v3 = print_start_content_table(v2);
  str(v3);
  print_item_desc("IP 주소");
  print_item_desc("컨넥션 정보");
  print_item_desc("수신패킷");
  v4 = print_item_desc("수신바이트");
  v5 = etr(v4);
  str(v5);
  print_item_desc("송신패킷");
  v6 = print_item_desc("송신바이트");
  etr(v6);
  v7 = get_wan_ip("wan1", &s2);
  v8 = *v1;
  if ( v8 )
  {
    v9 = 0;
    v10 = v8;
    while ( 1 )
    {
      v11 = inet_ntoa(*(struct in_addr *)v10);
      sf_strncpy(&v29, v11, 20);
      memset(&s, 0, 0x6Cu);
      v12 = dhcpd_get_dynamic_lease(&v29, &s);
      str(v12);
      v13 = v9 & 1 ? "style=\"background-color:#f9f6ed;\"" : "";
      printf("<td class=item_td rowspan=2 width=100 %s>\n", v13);
      v14 = (const char *)get_twinip_wan_virtual_ip("wan1");
      if ( !strcmp(&v29, v14) )
        break;
      v17 = (const char *)get_twinip_wan_virtual_ip("wan2");
      if ( !strcmp(&v29, v17) )
      {
        v16 = "Twin IP(2)";
        v15 = &v28;
        goto LABEL_10;
      }
      if ( !strcmp(&v29, &s2) )
      {
        v15 = &v28;
        v16 = "CPU(WAN1)";
        goto LABEL_10;
      }
      sf_strncpy(&v28, &v29, 20);
LABEL_14:
      if ( v27 )
        printf("%s<br>(%s)", &v28, &v27);
      else
        printf("%s", &v28);
      puts("</td>");
      if ( v9 & 1 )
        v18 = "style=\"background-color:#f9f6ed;\"";
      else
        v18 = "";
      printf("<td class=item_td rowspan=2 width=260 %s>\n", v18);
      if ( v24 )
        sub_3DD98(*(_DWORD *)(v10 + 4), *(_DWORD *)(v10 + 8), *(_DWORD *)(v10 + 12), *(_DWORD *)(v10 + 16), 0);
      else
        printf(
          "<span style='font: normal normal normal 10px arial;'>TCP: %d, UDP: %d, ICMP: %d, %s: %d</span>",
          *(_DWORD *)(v10 + 4),
          *(_DWORD *)(v10 + 8),
          *(_DWORD *)(v10 + 12),
          "Unknown",
          *(_DWORD *)(v10 + 16),
          0);
      puts("</td>");
      if ( v9 & 1 )
        v19 = "style=\"background-color:#f9f6ed;\"";
      else
        v19 = "";
      printf("<td rowspan=2 width=40 %s>\n", v19);
      printf("</td>");
      printf("<td class=item_td width=120 %s>%d</td>\n", v19, *(_DWORD *)(v10 + 20));
      sub_3D694(*(_QWORD *)(v10 + 32), &v25);
      v20 = printf("<td class=item_td width=120 %s>%s</td>\n", v19, &v25);
      v21 = etr(v20);
      str(v21);
      printf("<td class=item_td width=120 %s>%d</td>\n", v19, *(_DWORD *)(v10 + 24));
      sub_3D694(*(_QWORD *)(v10 + 40), &v25);
      v22 = printf("<td class=item_td width=120 %s>%s</td>\n", v19, &v25);
      v7 = etr(v22);
      v10 = *(_DWORD *)(v10 + 52);
      if ( !v10 )
        goto LABEL_28;
      ++v9;
    }
    v15 = &v28;
    v16 = "Twin IP(1)";
LABEL_10:
    strcpy(v15, v16);
    goto LABEL_14;
  }
LABEL_28:
  print_end_content_table(v7);
  return printf("</form>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EEC: using guessed type int __fastcall dhcpd_get_dynamic_lease(_DWORD, _DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003E8D4) --------------------------------------------------------
int __fastcall sub_3E8D4(_DWORD *a1)
{
  _DWORD *v1; // r4@1

  v1 = a1;
  *a1 = get_file_value("/proc/sys/net/nf_conntrack_max", 1);
  v1[1] = get_file_value("/proc/sys/net/netfilter/udp_conntrack_max", 1);
  v1[2] = get_file_value("/proc/sys/net/netfilter/icmp_conntrack_max", 1);
  v1[3] = get_file_value("/proc/sys/net/netfilter/max_rate_per_ip", 1);
  return 0;
}
// 1097C: using guessed type int __fastcall get_file_value(_DWORD, _DWORD);

//----- (0003E934) --------------------------------------------------------
int __fastcall sub_3E934(_DWORD *a1)
{
  _DWORD *v1; // r4@1

  v1 = a1;
  write_file_intval("/proc/sys/net/nf_conntrack_max", *a1);
  write_file_intval("/proc/sys/net/netfilter/udp_conntrack_max", v1[1]);
  write_file_intval("/proc/sys/net/netfilter/icmp_conntrack_max", v1[2]);
  write_file_intval("/proc/sys/net/netfilter/max_rate_per_ip", v1[3]);
  iconfig_set_intvalue_direct("ip_conntrack_max", *v1);
  iconfig_set_intvalue_direct("udp_conntrack_max", v1[1]);
  iconfig_set_intvalue_direct("icmp_conntrack_max", v1[2]);
  iconfig_set_intvalue_direct("max_rate_per_ip", v1[3]);
  return 0;
}
// 11768: using guessed type int __fastcall iconfig_set_intvalue_direct(_DWORD, _DWORD);
// 11BC4: using guessed type int __fastcall write_file_intval(_DWORD, _DWORD);

//----- (0003E9C4) --------------------------------------------------------
int __fastcall sub_3E9C4(int a1)
{
  int v1; // r4@1

  v1 = a1;
  *(_DWORD *)(a1 + 16) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_syn_sent", 1);
  *(_DWORD *)(v1 + 20) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_syn_recv", 1);
  *(_DWORD *)(v1 + 24) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_established", 1);
  *(_DWORD *)(v1 + 28) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_fin_wait", 1);
  *(_DWORD *)(v1 + 32) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_close_wait", 1);
  *(_DWORD *)(v1 + 36) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_last_ack", 1);
  *(_DWORD *)(v1 + 40) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_time_wait", 1);
  *(_DWORD *)(v1 + 44) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_close", 1);
  *(_DWORD *)(v1 + 48) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout", 1);
  *(_DWORD *)(v1 + 52) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream", 1);
  *(_DWORD *)(v1 + 56) = get_file_value("/proc/sys/net/ipv4/netfilter/ip_conntrack_icmp_timeout", 1);
  *(_DWORD *)(v1 + 60) = get_file_value(&unk_7834B, 1);
  return 0;
}
// 1097C: using guessed type int __fastcall get_file_value(_DWORD, _DWORD);

//----- (0003EAC4) --------------------------------------------------------
int __fastcall sub_3EAC4(int a1)
{
  int v1; // r4@1

  v1 = a1;
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_syn_sent", *(_DWORD *)(a1 + 16));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_syn_recv", *(_DWORD *)(v1 + 20));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_established", *(_DWORD *)(v1 + 24));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_fin_wait", *(_DWORD *)(v1 + 28));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_close_wait", *(_DWORD *)(v1 + 32));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_last_ack", *(_DWORD *)(v1 + 36));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_time_wait", *(_DWORD *)(v1 + 40));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_close", *(_DWORD *)(v1 + 44));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout", *(_DWORD *)(v1 + 48));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream", *(_DWORD *)(v1 + 52));
  write_file_intval("/proc/sys/net/ipv4/netfilter/ip_conntrack_icmp_timeout", *(_DWORD *)(v1 + 56));
  write_file_intval(&unk_7834B, *(_DWORD *)(v1 + 60));
  iconfig_set_intvalue_direct("tcp_timeout_syn_sent", *(_DWORD *)(v1 + 16));
  iconfig_set_intvalue_direct("tcp_timeout_syn_recv", *(_DWORD *)(v1 + 20));
  iconfig_set_intvalue_direct("tcp_timeout_eastablished", *(_DWORD *)(v1 + 24));
  iconfig_set_intvalue_direct("tcp_timeout_fin_wait", *(_DWORD *)(v1 + 28));
  iconfig_set_intvalue_direct("tcp_timeout_close_wait", *(_DWORD *)(v1 + 32));
  iconfig_set_intvalue_direct("tcp_timeout_last_ack", *(_DWORD *)(v1 + 36));
  iconfig_set_intvalue_direct("tcp_timeout_time_wait", *(_DWORD *)(v1 + 40));
  iconfig_set_intvalue_direct("tcp_timeout_close", *(_DWORD *)(v1 + 44));
  iconfig_set_intvalue_direct("udp_timeout", *(_DWORD *)(v1 + 48));
  iconfig_set_intvalue_direct("udp_timeout_stream", *(_DWORD *)(v1 + 52));
  iconfig_set_intvalue_direct("icmp_timeout", *(_DWORD *)(v1 + 56));
  iconfig_set_intvalue_direct(&unk_78375, *(_DWORD *)(v1 + 60));
  return 0;
}
// 11768: using guessed type int __fastcall iconfig_set_intvalue_direct(_DWORD, _DWORD);
// 11BC4: using guessed type int __fastcall write_file_intval(_DWORD, _DWORD);

//----- (0003EC54) --------------------------------------------------------
int __fastcall sub_3EC54(int a1)
{
  int v1; // r4@1
  int v2; // r0@3
  int v4; // [sp+0h] [bp-90h]@3
  char v5; // [sp+4h] [bp-8Ch]@3
  char v6; // [sp+8h] [bp-88h]@3
  char v7; // [sp+Ch] [bp-84h]@3
  char v8; // [sp+10h] [bp-80h]@5
  char v9; // [sp+14h] [bp-7Ch]@5
  char v10; // [sp+18h] [bp-78h]@5
  char v11; // [sp+1Ch] [bp-74h]@5
  char v12; // [sp+20h] [bp-70h]@5
  char v13; // [sp+24h] [bp-6Ch]@5
  char v14; // [sp+28h] [bp-68h]@5
  char v15; // [sp+2Ch] [bp-64h]@5
  char v16; // [sp+30h] [bp-60h]@5
  char v17; // [sp+34h] [bp-5Ch]@5
  char v18; // [sp+38h] [bp-58h]@5
  char v19; // [sp+3Ch] [bp-54h]@5
  char v20; // [sp+40h] [bp-50h]@1

  v1 = a1;
  if ( get_value(a1, "act", &v20, 64) )
  {
    if ( !strcmp(&v20, "apply") )
    {
      get_intvalue(v1, "all", &v4);
      get_intvalue(v1, "udp_max", &v5);
      get_intvalue(v1, "icmp_max", &v6);
      get_intvalue(v1, "rate_per_ip", &v7);
      v2 = sub_3E934(&v4);
    }
    else
    {
      v2 = strcmp(&v20, "apply_timeout");
      if ( !v2 )
      {
        get_intvalue(v1, "tcp_timeout_syn_sent", &v8);
        get_intvalue(v1, "tcp_timeout_syn_recv", &v9);
        get_intvalue(v1, "tcp_timeout_eastablished", &v10);
        get_intvalue(v1, "tcp_timeout_fin_wait", &v11);
        get_intvalue(v1, "tcp_timeout_close_wait", &v12);
        get_intvalue(v1, "tcp_timeout_last_ack", &v13);
        get_intvalue(v1, "tcp_timeout_time_wait", &v14);
        get_intvalue(v1, "tcp_timeout_close", &v15);
        get_intvalue(v1, "udp_timeout", &v16);
        get_intvalue(v1, "udp_timeout_stream", &v17);
        get_intvalue(v1, "icmp_timeout", &v18);
        get_intvalue(v1, &unk_78375, &v19);
        v2 = sub_3EAC4((int)&v4);
      }
    }
    signal_save(v2);
  }
  return 0;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003EE1C) --------------------------------------------------------
int sub_3EE1C()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  int v13; // r0@1
  int v15; // [sp+8h] [bp-A0h]@1
  int v16; // [sp+Ch] [bp-9Ch]@1
  int v17; // [sp+10h] [bp-98h]@1
  int v18; // [sp+14h] [bp-94h]@1
  int v19; // [sp+48h] [bp-60h]@1
  int v20; // [sp+4Ch] [bp-5Ch]@1
  int v21; // [sp+50h] [bp-58h]@1
  int v22; // [sp+54h] [bp-54h]@1

  sub_3E8D4(&v19);
  hwinfo_get_conntrack_default(&v15);
  puts("<form method=get action=timepro.cgi name=connctrl_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=connctrl>");
  puts("<input type=hidden name=act value=>");
  printf("<input type=hidden name=default_all value=%d>\n", v15);
  printf("<input type=hidden name=default_udp_max value=%d>\n", v16);
  printf("<input type=hidden name=default_icmp_max value=%d>\n", v17);
  v0 = printf("<input type=hidden name=default_rate_per_ip value=%d>\n", v18);
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("최대 컨넥션 수");
  printf("<td class=item_td colspan=3>");
  printf("<input type=text name=all size=6 maxlength=6 value=%d> %s", v19, "개");
  print_nbsp(1);
  printf("( 0 : %s, 512 ~ )", "제한 없음");
  v2 = printf("</td>");
  v3 = etr(v2);
  str(v3);
  print_item_desc("최대 UDP 컨넥션 수");
  printf("<td class=item_td colspan=3>");
  printf("<input type=text name=udp_max size=6 maxlength=6 value=%d> %s", v20, "개");
  print_nbsp(1);
  printf("( 0 : %s ,10 ~ %s )", "제한 없음", "최대 컨넥션 수");
  v4 = printf("</td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc("최대 ICMP 컨넥션 수");
  printf("<td class=item_td colspan=3>");
  printf("<input type=text name=icmp_max size=6 maxlength=6 value=%d> %s", v21, "개");
  print_nbsp(1);
  printf("( 0 : %s ,1 ~ %s )", "제한 없음", "최대 컨넥션 수");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  print_item_desc("PC별 최대 컨넥션 비율");
  printf("<td class=item_td colspan=3>");
  printf("<input type=text name=rate_per_ip size=3 maxlength=6 value=%d> %%", v22);
  print_nbsp(1);
  printf("( 0 : %s ,1 ~ 100 )", "제한 없음");
  v8 = printf("</td>");
  v9 = etr(v8);
  str(v9);
  printf("<td align=right colspan=4 class=item_td>");
  printf("<input type=button name=default_bt value=\"%s\" onclick=\"DefaultConnCtrl();\">", "초기값으로");
  print_nbsp(3);
  printf("<input type=button name=apply_bt value=\"%s\" onclick=\"ApplyConnCtrl();\">", "적용");
  v10 = printf("</td>");
  v11 = etr(v10);
  str(v11);
  printf("<td align=left colspan=4 class=item_td>");
  printf("<span class=gray_text>");
  printf("* 주의사항<br>1. 컨넥션 제어 설정는 네트워크 기술에 익숙한 전문가용 설정화면 입니다.<br>2. [ 최대 컨넥션 수 ]를 제한없음 또는 초기값보다 큰 값을 사용할 경우, 일부 환경에서 메모리 부족으로 인한 예기치 못한 오류가 발생할 수 있습니다.<br>3. [ PC별 최대 컨넥션 비율 ]을 0 이아닌 값으로 설정할 경우에는, 내부 네트워크가 C Class 또는 C Class의 서브넷으로 되어있어야 합니다.");
  printf("</span>");
  v12 = printf("</td>");
  v13 = etr(v12);
  print_end_content_table(v13);
  return printf("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11438: using guessed type int __fastcall hwinfo_get_conntrack_default(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003F0FC) --------------------------------------------------------
int sub_3F0FC()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  int v13; // r0@1
  int v14; // r0@1
  int v15; // r0@1
  char v17; // [sp+8h] [bp-98h]@1
  int v18; // [sp+18h] [bp-88h]@1
  int v19; // [sp+1Ch] [bp-84h]@1
  int v20; // [sp+20h] [bp-80h]@1
  int v21; // [sp+24h] [bp-7Ch]@1
  int v22; // [sp+28h] [bp-78h]@1
  int v23; // [sp+2Ch] [bp-74h]@1
  int v24; // [sp+30h] [bp-70h]@1
  int v25; // [sp+34h] [bp-6Ch]@1
  int v26; // [sp+38h] [bp-68h]@1
  int v27; // [sp+3Ch] [bp-64h]@1
  int v28; // [sp+40h] [bp-60h]@1
  int v29; // [sp+44h] [bp-5Ch]@1
  char v30; // [sp+48h] [bp-58h]@1
  int v31; // [sp+58h] [bp-48h]@1
  int v32; // [sp+5Ch] [bp-44h]@1
  int v33; // [sp+60h] [bp-40h]@1
  int v34; // [sp+64h] [bp-3Ch]@1
  int v35; // [sp+68h] [bp-38h]@1
  int v36; // [sp+6Ch] [bp-34h]@1
  int v37; // [sp+70h] [bp-30h]@1
  int v38; // [sp+74h] [bp-2Ch]@1
  int v39; // [sp+78h] [bp-28h]@1
  int v40; // [sp+7Ch] [bp-24h]@1
  int v41; // [sp+80h] [bp-20h]@1
  int v42; // [sp+84h] [bp-1Ch]@1

  sub_3E9C4((int)&v30);
  hwinfo_get_conntrack_default(&v17);
  print_sub_title("컨넥션 타임아웃 제어", 0);
  puts("<form method=get action=timepro.cgi name=conntimeout_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=connctrl>");
  puts("<input type=hidden name=act value=>");
  printf("<input type=hidden name=default_tcp_timeout_syn_sent value=%d>\n", v18);
  printf("<input type=hidden name=default_tcp_timeout_syn_recv value=%d>\n", v19);
  printf("<input type=hidden name=default_tcp_timeout_eastablished value=%d>\n", v20);
  printf("<input type=hidden name=default_tcp_timeout_fin_wait value=%d>\n", v21);
  printf("<input type=hidden name=default_tcp_timeout_close_wait value=%d>\n", v22);
  printf("<input type=hidden name=default_tcp_timeout_last_ack value=%d>\n", v23);
  printf("<input type=hidden name=default_tcp_timeout_time_wait value=%d>\n", v24);
  printf("<input type=hidden name=default_tcp_timeout_close value=%d>\n", v25);
  printf("<input type=hidden name=default_udp_timeout value=%d>\n", v26);
  printf("<input type=hidden name=default_udp_timeout_stream value=%d>\n", v27);
  printf("<input type=hidden name=default_icmp_timeout value=%d>\n", v28);
  v0 = printf("<input type=hidden name=default_generic_timeout value=%d>\n", v29);
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("TCP SYN SENT TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_syn_sent size=5 maxlength=6 value=%d> %s", v31, "초");
  printf("</td>");
  print_item_desc("TCP SYN RECV TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_syn_recv size=5 maxlength=6 value=%d> %s", v32, "초");
  v2 = printf("</td>");
  v3 = etr(v2);
  str(v3);
  print_item_desc("TCP ESTABLISHED TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_eastablished size=5 maxlength=6 value=%d> %s", v33, "초");
  printf("</td>");
  print_item_desc("TCP FIN WAIT TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_fin_wait size=5 maxlength=6 value=%d> %s", v34, "초");
  v4 = printf("</td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc("TCP CLOSE WAIT TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_close_wait size=5 maxlength=6 value=%d> %s", v35, "초");
  printf("</td>");
  print_item_desc("TCP LAST ACK TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_last_ack size=5 maxlength=6 value=%d> %s", v36, "초");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  print_item_desc("TCP TIME WAIT TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_time_wait size=5 maxlength=6 value=%d> %s", v37, "초");
  printf("</td>");
  print_item_desc("TCP CLOSE TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=tcp_timeout_close size=5 maxlength=6 value=%d> %s", v38, "초");
  v8 = printf("</td>");
  v9 = etr(v8);
  str(v9);
  print_item_desc("UDP TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=udp_timeout size=5 maxlength=6 value=%d> %s", v39, "초");
  printf("</td>");
  print_item_desc("UDP STREAM TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=udp_timeout_stream size=5 maxlength=6 value=%d> %s", v40, "초");
  v10 = printf("</td>");
  v11 = etr(v10);
  str(v11);
  print_item_desc("ICMP TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=icmp_timeout size=5 maxlength=6 value=%d> %s", v41, "초");
  printf("</td>");
  print_item_desc("GENERIC TIMEOUT");
  printf("<td class=item_td>");
  printf("<input type=text name=generic_timeout size=5 maxlength=6 value=%d> %s", v42, "초");
  v12 = printf("</td>");
  v13 = etr(v12);
  str(v13);
  printf("<td align=right colspan=4 class=item_td>");
  printf("<input type=button name=default_bt value=\"%s\" onclick=\"DefaultConnTimeout();\">", "초기값으로");
  print_nbsp(3);
  printf("<input type=button name=apply_bt value=\"%s\" onclick=\"ApplyConnTimeout();\">", "적용");
  v14 = printf("</td>");
  v15 = etr(v14);
  print_end_content_table(v15);
  return printf("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11438: using guessed type int __fastcall hwinfo_get_conntrack_default(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003F604) --------------------------------------------------------
int __fastcall sub_3F604(int a1)
{
  int v1; // r5@1
  int v2; // r0@6
  int v3; // r0@9
  int v4; // r0@9
  int v5; // r0@9
  int v6; // r0@9
  int v7; // r0@9
  char v9; // [sp+4h] [bp-3ACh]@1
  int v10; // [sp+268h] [bp-148h]@9
  char v11; // [sp+380h] [bp-30h]@1

  v1 = a1;
  get_si("hw", &v9);
  if ( get_value(v1, "act", &v11, 32) && !strcmp(&v11, "apply_mirror") )
  {
    if ( !get_value(v1, "mirror_chk", &v11, 32) || strcmp(&v11, "on") )
    {
      v2 = 0;
      goto LABEL_8;
    }
    if ( get_value(v1, "portmirror", &v11, 32) )
    {
      v2 = atoi(&v11);
LABEL_8:
      set_sniff_port(v2);
      goto LABEL_9;
    }
  }
LABEL_9:
  puts("<form method=get action=timepro.cgi name=portmirror_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=switch>");
  puts("<input type=hidden name=act value=>");
  printf("<input type=hidden name=portmirror value=%d>\n", v10);
  v3 = print_sub_title("포트미러링", 1);
  v4 = print_start_content_table(v3);
  str(v4);
  v5 = printf("<td width=80%% class=item_td>");
  get_sniff_port(v5);
  printf("<input type=checkbox name=mirror_chk %s> ");
  printf((const char *)&unk_792FC, v10);
  printf("</td>");
  puts("<td class=item_td align=right>");
  printf("<input class=navi_bt type=button name=apply_bt value=\"적용\" onclick=\"ApplyPortMirror();\" >");
  v6 = printf("</td>");
  v7 = etr(v6);
  print_end_content_table(v7);
  return puts("</form>");
}
// 10124: using guessed type int __fastcall get_si(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10B8C: using guessed type int __fastcall get_sniff_port(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11AA4: using guessed type int __fastcall set_sniff_port(_DWORD);

//----- (0003F7AC) --------------------------------------------------------
const char *__fastcall sub_3F7AC(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  int v3; // r0@3
  int v4; // [sp+4h] [bp-Ch]@1

  v1 = a1;
  v4 = 0;
  result = (const char *)get_pvalue(a1, "act");
  if ( result )
  {
    result = (const char *)strcmp(result, "jumbo");
    if ( !result )
    {
      get_intvalue(v1, "enable", &v4);
      set_jumbo_frame_control(v4);
      v3 = apply_jumbo_frame_control(v4);
      result = (const char *)signal_save(v3);
    }
  }
  return result;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10904: using guessed type int __fastcall set_jumbo_frame_control(_DWORD);
// 10F94: using guessed type int __cdecl get_intvalue(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11918: using guessed type int __fastcall apply_jumbo_frame_control(_DWORD);

//----- (0003F810) --------------------------------------------------------
int __fastcall sub_3F810(int a1)
{
  const char *v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1

  v1 = sub_3F7AC(a1);
  get_jumbo_frame_control(v1);
  puts("<form method=get action=timepro.cgi name=jumbo_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=switch>");
  puts("<input type=hidden name=act value=jumbo>");
  v2 = print_sub_title("점보 프레임 기능", 0);
  v3 = print_start_content_table(v2);
  str(v3);
  printf("<td class=item_td>");
  printf("<input type=checkbox name=enable value=1 %s>");
  print_nbsp(2);
  printf("%s", "모든 랜포트에 대하여 점보프레임을 허용합니다.");
  printf("</td>");
  puts("<td class=item_td align=right>");
  printf("<input class=navi_bt type=button name=apply_bt value=\"적용\" onclick=\"document.jumbo_fm.submit();\">");
  v4 = printf("</td>");
  v5 = etr(v4);
  print_end_content_table(v5);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11AEC: using guessed type int __fastcall get_jumbo_frame_control(_DWORD);

//----- (0003F8F8) --------------------------------------------------------
int __fastcall sub_3F8F8(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r6@1
  int v4; // r0@1
  int v6; // [sp+0h] [bp-30h]@1

  v2 = a2;
  v3 = a1;
  v4 = get_value(a1, "act", &v6, 32);
  if ( v4 )
  {
    v4 = strcmp((const char *)&v6, "apply_trunk");
    if ( !v4 )
    {
      if ( get_value(v3, "trunk_chk", &v6, 32) && !strcmp((const char *)&v6, "on") )
        v4 = trunk_add_config("TRUNK", v2);
      else
        v4 = trunk_remove_config("TRUNK", -1);
    }
  }
  return signal_save(v4);
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10700: using guessed type int __fastcall trunk_add_config(_DWORD, _DWORD);
// 10C88: using guessed type int __fastcall trunk_remove_config(_DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003F9A4) --------------------------------------------------------
int __fastcall sub_3F9A4(int a1)
{
  int v1; // r4@1
  signed int i; // r4@1
  int v3; // r0@8
  int v4; // r0@8
  char *v5; // r1@9
  int v6; // r0@11
  int v7; // r0@11
  int v8; // r0@11
  int v9; // r0@11
  int v11; // [sp+0h] [bp-4A8h]@1
  int v12; // [sp+258h] [bp-250h]@7
  int v13; // [sp+378h] [bp-130h]@1
  char v14; // [sp+37Ch] [bp-12Ch]@1
  int v15; // [sp+47Ch] [bp-2Ch]@8
  int v16; // [sp+494h] [bp-14h]@8

  v1 = a1;
  get_si("hw", &v11);
  sub_3F8F8(v1, v13);
  strcpy(&v14, "");
  for ( i = 1; i <= v12; ++i )
  {
    if ( (v13 >> (i - 1)) & 1 )
    {
      if ( v14 )
        sprintf(&v14, "%s,%d", &v14, i);
      else
        sprintf(&v14, "%d", i);
    }
  }
  trunk_read_config(0, &v15, &v16);
  puts("<form method=get action=timepro.cgi name=trunk_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=switch>");
  puts("<input type=hidden name=act value=apply_trunk>");
  v3 = print_sub_title("포트트렁킹", 0);
  v4 = print_start_content_table(v3);
  str(v4);
  printf("<td width=80%% class=item_td>");
  if ( v16 )
    v5 = "checked";
  else
    v5 = "";
  printf("<input type=checkbox name=trunk_chk %s> ", v5, "");
  printf("포트 %s번을 Trunk 그룹으로 설정합니다.", &v14);
  printf("</td>");
  puts("<td class=item_td align=right>");
  printf("<input class=navi_bt type=submit name=apply_bt value=\"적용\">");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  printf((const char *)&unk_79625);
  print_nbsp(3);
  printf("Loop 방지를 위해 Trunk 설정이 완료된 후 랜선을 연결하세요.");
  v8 = puts("</td>");
  v9 = etr(v8);
  print_end_content_table(v9);
  return puts("</form>");
}
// 10124: using guessed type int __fastcall get_si(_DWORD, _DWORD);
// 10298: using guessed type int __fastcall trunk_read_config(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0003FB98) --------------------------------------------------------
int __fastcall sub_3FB98(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r6@1
  int v4; // r5@2
  int result; // r0@6
  char *v6; // r1@8
  char *v7; // r1@11
  char *v8; // r1@18
  char *v9; // r1@21
  char *v10; // r1@24
  char *v11; // r1@27
  int v12; // r0@29
  char s; // [sp+8h] [bp-58h]@2
  char v14; // [sp+28h] [bp-38h]@7
  char s1; // [sp+32h] [bp-2Eh]@14
  int v16; // [sp+3Ch] [bp-24h]@14

  v2 = a2;
  v3 = a1;
  printf("<tr>");
  if ( v2 <= 0x10000 )
  {
    snprintf(&s, 0x20u, "%d", v2);
    v4 = *(_DWORD *)(v3 + 4 * v2 + 748);
  }
  else
  {
    snprintf(&s, 0x20u, "WAN%d", v2 - 0x10000);
    v4 = *(_DWORD *)(v3 + 4 * (v2 - 65319) + 8);
  }
  print_item_desc(&s);
  if ( v2 == 1 || v2 != *(_DWORD *)(v3 + 600) )
  {
    read_portconfig(v2, &v14);
    puts("<td class=item_td>");
    printf("<select name=mode%d onchange=\"SelectLinkMode(%d);\">\n", v2, v2);
    if ( !strcmp(&v14, "auto") )
      v6 = "selected";
    else
      v6 = "";
    printf((const char *)&unk_7971E, v6);
    if ( !strcmp(&v14, "forced") )
      v7 = "selected";
    else
      v7 = "";
    printf("<option value=forced %s>수동</option>", v7);
    printf("</select>");
    printf("</td>");
    puts("<td class=item_td>");
    printf("<select name=speed%d onchange=\"SelectLinkMode(%d);\">\n", v2, v2);
    if ( !strcmp(&v14, "auto") )
    {
      sprintf(&s1, "%d", v4);
      strcpy((char *)&v16, "full");
    }
    if ( v4 == 1000 )
    {
      strcmp(&s1, "1000");
      printf("<option value=1000 %s>1Gbps</option>\n");
    }
    if ( !strcmp(&s1, "100") )
      v8 = "selected";
    else
      v8 = "";
    printf("<option value=100 %s>100Mbps</option>\n", v8);
    if ( !strcmp(&s1, "10") )
      v9 = "selected";
    else
      v9 = "";
    printf("<option value=10 %s>10Mbps</option>\n", v9);
    printf("</select>");
    printf("</td>");
    puts("<td class=item_td>");
    printf("<select name=duplex%d>\n", v2);
    if ( !strcmp((const char *)&v16, "full") )
      v10 = "selected";
    else
      v10 = "";
    printf("<option value=full %s>FULL</option>\n", v10);
    if ( !strcmp((const char *)&v16, "half") )
      v11 = "selected";
    else
      v11 = "";
    printf("<option value=half %s>HALF</option>\n", v11);
    printf("</select>");
    printf("</td>");
    puts("<td class=item_td>");
    v12 = printf(
            "<input class=navi_bt type=button name=\"port%d_bt\" value=\"적용\" onclick=\"ApplyLinkSetup(%d);\"\"></td>\n",
            v2,
            v2);
    result = etr(v12);
  }
  else
  {
    puts("<td colspan=3 class=item_td>");
    puts("자동으로 고정</td>");
    result = printf("</tr>");
  }
  return result;
}
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11054: using guessed type int __fastcall read_portconfig(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);

//----- (0003FE94) --------------------------------------------------------
int __fastcall sub_3FE94(int a1)
{
  int v1; // r5@1
  int v2; // r4@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int i; // r0@1
  signed int v7; // r4@4
  int v8; // r1@5
  signed int v9; // r4@7
  int v10; // r1@8
  signed int v11; // r4@10
  signed int v12; // r1@11

  v1 = a1;
  v2 = 0;
  print_sub_title("", 1);
  print_sub_title("링크 설정", 1);
  puts("<form method=get action=timepro.cgi name=linksetup_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=linksetup>");
  puts("<input type=hidden name=act value=>");
  v3 = puts("<input type=hidden name=port value=>");
  v4 = print_start_content_table(v3);
  str(v4);
  print_item_desc("포트 번호");
  print_item_desc("동작 모드");
  print_item_desc("속도");
  print_item_desc("Duplex");
  v5 = print_item_desc("");
  for ( i = etr(v5); ++v2 <= *(_DWORD *)(v1 + 604); i = sub_3FB98(v1, v2 + 0x10000) )
    ;
  v7 = 1;
  while ( v7 <= *(_DWORD *)(v1 + 600) )
  {
    v8 = v7++;
    i = sub_3FB98(v1, v8);
  }
  print_end_content_table(i);
  v9 = 1;
  puts("</form>");
  puts("<script>");
  while ( v9 <= *(_DWORD *)(v1 + 604) )
  {
    v10 = v9++ + 0x10000;
    printf("SelectLinkMode(%d);\n", v10);
  }
  v11 = 1;
  while ( v11 <= *(_DWORD *)(v1 + 600) )
  {
    v12 = v11++;
    printf("SelectLinkMode(%d);\n", v12);
  }
  return puts("</script>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00040050) --------------------------------------------------------
signed int __fastcall sub_40050(signed int result, int a2, _QWORD *a3)
{
  __int64 v3; // r0@12

  if ( result == 128 )
  {
    v3 = *(_QWORD *)(a2 + 56);
    goto LABEL_34;
  }
  if ( result > 128 )
  {
    if ( result == 2048 )
    {
      v3 = *(_QWORD *)(a2 + 88);
      goto LABEL_34;
    }
    if ( result > 2048 )
    {
      if ( result == 0x2000 )
      {
        v3 = *(_QWORD *)(a2 + 104);
        goto LABEL_34;
      }
      if ( result == 0x4000 )
      {
        v3 = *(_QWORD *)(a2 + 112);
        goto LABEL_34;
      }
      if ( result == 4096 )
      {
        v3 = *(_QWORD *)(a2 + 96);
        goto LABEL_34;
      }
    }
    else
    {
      if ( result == 512 )
      {
        v3 = *(_QWORD *)(a2 + 72);
        goto LABEL_34;
      }
      if ( result == 1024 )
      {
        v3 = *(_QWORD *)(a2 + 80);
        goto LABEL_34;
      }
      if ( result == 256 )
      {
        v3 = *(_QWORD *)(a2 + 64);
        goto LABEL_34;
      }
    }
  }
  else
  {
    if ( result == 8 )
    {
      v3 = *(_QWORD *)(a2 + 24);
      goto LABEL_34;
    }
    if ( result <= 8 )
    {
      if ( result == 2 )
      {
        v3 = *(_QWORD *)(a2 + 8);
      }
      else
      {
        if ( result != 4 )
        {
          if ( result == 1 )
          {
            *a3 = *(_QWORD *)a2;
            return result;
          }
          return 0;
        }
        v3 = *(_QWORD *)(a2 + 16);
      }
LABEL_34:
      *a3 = v3;
      return 1;
    }
    if ( result == 32 )
    {
      v3 = *(_QWORD *)(a2 + 40);
      goto LABEL_34;
    }
    if ( result == 64 )
    {
      v3 = *(_QWORD *)(a2 + 48);
      goto LABEL_34;
    }
    if ( result == 16 )
    {
      v3 = *(_QWORD *)(a2 + 32);
      goto LABEL_34;
    }
  }
  return 0;
}

//----- (00040174) --------------------------------------------------------
int __fastcall sub_40174(int a1, signed int a2, int a3, signed int a4)
{
  int result; // r0@1
  signed int v5; // r4@1
  int v6; // r6@1
  signed int v7; // r7@1
  char *v8; // r0@9
  const char *v9; // r2@9
  signed int v10; // r5@35
  char s; // [sp+8h] [bp-F0h]@9
  char v12; // [sp+88h] [bp-70h]@37
  __int64 v13; // [sp+C8h] [bp-30h]@37

  result = a2 & a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( result )
  {
    if ( a2 == 128 )
    {
      v8 = &s;
      v9 = "Rx-Error(Frag)";
    }
    else if ( a2 > 128 )
    {
      if ( a2 == 2048 )
      {
        v8 = &s;
        a2 = 128;
        v9 = "Tx-Broadcast";
      }
      else if ( a2 > 2048 )
      {
        if ( a2 == 0x2000 )
        {
          v8 = &s;
          a2 = 128;
          v9 = "Tx-Collision";
        }
        else if ( a2 == 0x4000 )
        {
          v9 = "Tx-Pause";
          v8 = &s;
          a2 = 128;
        }
        else
        {
          if ( a2 != 4096 )
            goto LABEL_36;
          v8 = &s;
          a2 = 128;
          v9 = "Tx-Multicast";
        }
      }
      else if ( a2 == 512 )
      {
        v8 = &s;
        a2 = 128;
        v9 = "Tx-Packets";
      }
      else if ( a2 == 1024 )
      {
        v8 = &s;
        a2 = 128;
        v9 = "Tx-Bytes";
      }
      else
      {
        if ( a2 != 256 )
          goto LABEL_36;
        v8 = &s;
        a2 = 128;
        v9 = "Rx-Pause";
      }
    }
    else if ( a2 == 8 )
    {
      v8 = &s;
      a2 = 128;
      v9 = "Rx-Multicast";
    }
    else if ( a2 > 8 )
    {
      if ( a2 == 32 )
      {
        v8 = &s;
        a2 = 128;
        v9 = "Rx-Error(Drop)";
      }
      else if ( a2 == 64 )
      {
        v8 = &s;
        a2 = 128;
        v9 = "Rx-Error(CRC)";
      }
      else
      {
        if ( a2 != 16 )
          goto LABEL_36;
        v8 = &s;
        a2 = 128;
        v9 = "Rx-Error";
      }
    }
    else if ( a2 == 2 )
    {
      v8 = &s;
      a2 = 128;
      v9 = "Rx-Bytes";
    }
    else
    {
      if ( a2 != 4 )
      {
        if ( a2 == 1 )
        {
          v8 = &s;
          a2 = 128;
          v9 = "Rx-Packets";
          goto LABEL_35;
        }
LABEL_36:
        strcpy(&s, "");
        return 0;
      }
      v8 = &s;
      a2 = 128;
      v9 = "Rx-Broadcast";
    }
LABEL_35:
    v10 = 1;
    snprintf(v8, a2, v9);
    printf("<tr>");
    print_item(&s, 150);
    while ( v10 <= v7 )
    {
      ++v10;
      sub_40050(v5, v6, &v13);
      v6 += 120;
      snprintf(&v12, 0x40u, "%llu", HIDWORD(v13), v13);
      print_item(&v12, 80);
    }
    printf("</tr>");
    result = 1;
  }
  return result;
}
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);

//----- (00040428) --------------------------------------------------------
const char *__fastcall sub_40428(int a1)
{
  const char *result; // r0@1

  result = (const char *)get_pvalue(a1, "act");
  if ( result )
  {
    if ( !strcmp(result, "clear") )
    {
      clear_port_statistics();
      result = (const char *)1;
    }
    else
    {
      result = (const char *)1;
    }
  }
  return result;
}
// 10EE0: using guessed type int clear_port_statistics(void);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (0004046C) --------------------------------------------------------
int __fastcall sub_4046C(int a1)
{
  int v1; // r4@1
  signed int v2; // r6@1
  signed int v3; // r5@1
  int v4; // r0@1
  char *v5; // r3@1
  signed int v6; // r3@4
  signed int v7; // r6@6
  signed int v8; // r2@7
  void *v9; // r6@9
  void *v10; // r8@9
  signed int v11; // r7@9
  int v12; // r0@10
  void *v13; // r1@10
  signed int v14; // r7@12
  signed int v15; // r0@13
  int v16; // r1@13
  int v17; // r0@15
  int v18; // r0@16
  char *v20; // [sp+0h] [bp-40h]@3
  char s; // [sp+8h] [bp-38h]@4

  v1 = a1;
  v2 = 1;
  v3 = *(_DWORD *)(a1 + 604) + *(_DWORD *)(a1 + 600);
  print_sub_title("링크통계 정보", 0);
  puts("<form method=get action=timepro.cgi name=linkstat_fm>");
  puts("<input type=hidden name=tmenu value=trafficconf>");
  puts("<input type=hidden name=smenu value=linksetup>");
  v4 = puts("<input type=hidden name=act value=>");
  print_start_content_table(v4);
  printf("<tr>");
  v5 = "style=\"padding:0px 3px 0px 3px;\"";
  if ( v3 <= 6 )
    v5 = "";
  v20 = v5;
  print_item_desc("포트 번호");
  while ( v2 <= *(_DWORD *)(v1 + 604) )
  {
    v6 = v2++;
    snprintf(&s, 0x20u, "WAN%d", v6, v20);
    v20 = 0;
    print_item_desc(&s);
  }
  v7 = 1;
  while ( v7 <= *(_DWORD *)(v1 + 600) )
  {
    v8 = v7++;
    sprintf(&s, "%d", v8);
    print_item_desc(&s);
  }
  printf("</tr>");
  v9 = malloc(120 * v3);
  v10 = v9;
  memset(v9, 0, 120 * v3);
  v11 = 1;
  while ( v11 <= *(_DWORD *)(v1 + 604) )
  {
    v12 = v11 + 0x10000;
    v13 = v10;
    ++v11;
    v10 = (char *)v10 + 120;
    get_eport_stat(v12, v13);
  }
  v14 = 1;
  while ( v14 <= *(_DWORD *)(v1 + 600) )
  {
    v15 = v14;
    v16 = *(_DWORD *)(v1 + 604) - 1 + v14++;
    get_eport_stat(v15, (char *)v9 + 120 * v16);
  }
  sub_40174(*(_DWORD *)(v1 + 200), 1, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 2, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 4, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 8, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 16, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 32, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 64, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 128, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 256, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 512, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 1024, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 2048, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 4096, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 0x2000, (int)v9, v3);
  sub_40174(*(_DWORD *)(v1 + 200), 0x4000, (int)v9, v3);
  free(v9);
  if ( *(_DWORD *)(v1 + 200) < 0 )
  {
    str(v17);
    printf("<td class=item_td colspan=%d align=right>\n", 20);
    puts("<input class=navi_bt type=button name=clear_sub value=\" 통계정보 초기화 \" onclick=\"ClearLinkStat();\">");
    v18 = printf("</td>");
    v17 = etr(v18);
  }
  print_end_content_table(v17);
  return printf("</form>");
}
// 10568: using guessed type int __fastcall get_eport_stat(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00041844) --------------------------------------------------------
int __fastcall sub_41844(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r4@1
  signed int v4; // r4@4
  int v5; // r0@8
  int v6; // r0@8
  int v7; // r0@8
  const char *v8; // r0@9
  int v9; // r0@13
  char *v11; // r0@14
  char v12; // [sp+8h] [bp-130h]@12
  char v13; // [sp+108h] [bp-30h]@12
  char v14; // [sp+118h] [bp-20h]@14

  v1 = a1;
  puts("<script language=JavaScript>");
  puts("<!--");
  puts("function SelectMenu(menu)");
  puts("{");
  puts("\tvar F = document.menu_fm;");
  printf("\tif(menu == 'report')");
  puts("\t\tF.act.value = \"report\"");
  printf("\telse if(menu == 'scan')");
  puts("\t\tF.act.value = \"scan\"");
  printf("\telse if(menu == 'remedy')");
  puts("\t\tF.act.value = \"remedy\"");
  puts("\tF.flag.value = \"nd-warning\"");
  puts("\tF.submit();");
  puts("}");
  puts("-->");
  puts("</script>");
  v2 = (const char *)get_pvalue(v1, "act");
  v3 = v2;
  if ( !v2 || !strcmp(v2, "report") )
    goto LABEL_7;
  if ( strcmp(v3, "scan") )
  {
    if ( !strcmp(v3, "remedy") )
    {
      v4 = 3;
      goto LABEL_14;
    }
LABEL_7:
    v4 = 1;
    goto LABEL_8;
  }
  v4 = 2;
LABEL_14:
  v11 = getenv("REMOTE_ADDR");
  sf_strncpy(&v14, v11, 16);
  netdetect_set_option_rule(68, &v14);
LABEL_8:
  puts("<BODY BOTTOMMARGIN=0 RIGHTMARGIN=0 LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0 >");
  printf("<form method=get action=\"netdetect.cgi\" name=\"menu_fm\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  printf("<input type=hidden name=\"flag\" value=\"\">");
  puts("<table>");
  v5 = print_blank_line(2, 10);
  str(v5);
  printf("<td></td>");
  printf("<td align=right valign=middle>");
  printf("<input type=button name=\"ndwarning\" value=\"창닫기\" onclick=\"javascrip:parent.close()\">");
  v6 = printf("</td>");
  v7 = etr(v6);
  str(v7);
  puts("<td colspan=2 valign=middle>");
  if ( v4 == 2 )
  {
    v8 = "<iframe width=\"600\" height=\"430\" name=\"subwin\" src=\"http://efm.livecall.co.kr/virusrepair/s_scan.html\"></iframe>";
  }
  else if ( v4 == 3 )
  {
    v8 = "<iframe width=\"600\" height=\"430\" name=\"subwin\" src=\"http://efm.livecall.co.kr/virusrepair/s_remedy.html\"></iframe>";
  }
  else
  {
    get_iptime_service_network(&v13);
    snprintf(
      &v12,
      0x100u,
      "<iframe width=\"600\" height=\"430\" name=\"subwin\" src=\"http://%s.1:%d/nd-bin/netdetect.cgi?flag=nd-report\">",
      &v13,
      80);
    printf("%s", &v12);
    v8 = "</iframe>";
  }
  printf(v8);
  v9 = printf("</td>");
  etr(v9);
  printf("</table>");
  printf("</form>");
  return printf("</body>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10ACC: using guessed type int __fastcall netdetect_set_option_rule(_DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11948: using guessed type int __fastcall get_iptime_service_network(_DWORD);

//----- (00041ADC) --------------------------------------------------------
int __fastcall sub_41ADC(int a1)
{
  int v1; // r5@1
  char *v2; // r0@1
  const char *v3; // r0@1
  char *v4; // r0@4
  unsigned __int16 v5; // r0@5
  char *v6; // r0@8
  unsigned __int16 v7; // r0@9
  int v8; // r4@10
  int v9; // r0@11
  int v10; // r7@11
  int v11; // r6@11
  int v12; // r1@12
  unsigned int v13; // r1@13
  int v14; // r0@13
  int v15; // r7@16
  signed int v16; // r5@16
  int v17; // r0@16
  int v18; // r0@17
  _DWORD *v19; // r4@17
  struct in_addr v20; // r0@17
  char *v21; // r0@18
  const char *v22; // r0@20
  int v23; // r3@22
  char *v24; // r3@23
  const char *v25; // r1@26
  int v26; // r0@31
  char *v27; // r1@32
  char *v28; // r2@35
  char v30; // [sp+10h] [bp-150h]@3
  char v31; // [sp+90h] [bp-D0h]@22
  char v32; // [sp+108h] [bp-58h]@16
  char v33; // [sp+118h] [bp-48h]@16
  char v34; // [sp+128h] [bp-38h]@1

  v1 = a1;
  puts("<script language=JavaScript>");
  puts("<!--");
  puts("function Confirm()");
  puts("{");
  puts("\tvar F = document.ndwarning_fm;");
  puts("\tvar chk_ignore = false;");
  puts("\tvar chk_warn = false;");
  puts("\tfor (i=0; i < F.elements.length; i++)");
  puts("\t{");
  puts("\t\tif (F.elements[i].type == 'checkbox')");
  puts("\t\t{");
  puts("\t\t\tif (F.elements[i].checked)");
  puts("\t\t\t{");
  puts("\t\t\t\tif (chk_ignore == false)");
  puts("\t\t\t\t\tF.ignore.value = F.elements[i].value;");
  puts("\t\t\t\telse");
  puts("\t\t\t\t\tF.ignore.value += \" \" + F.elements[i].value;");
  puts("\t\t\t\tchk_ignore = true;");
  puts("\t\t\t}");
  puts("\t\t\telse");
  puts("\t\t\t{");
  puts("\t\t\t\tif (chk_warn == false)");
  puts("\t\t\t\t\tF.warn.value = F.elements[i].value;");
  puts("\t\t\t\telse");
  puts("\t\t\t\t\tF.warn.value += \" \" + F.elements[i].value;");
  puts("\t\t\t\tchk_warn = true;");
  puts("\t\t\t}");
  puts("\t\t}");
  puts("\t}");
  puts("\tF.flag.value = \"nd-report\"");
  puts("\tF.act.value = \"confirm\"");
  puts("\tF.submit();");
  puts("}");
  puts("-->");
  puts("</script>");
  v2 = getenv("REMOTE_ADDR");
  sf_strncpy(&v34, v2, 16);
  v3 = (const char *)get_pvalue(v1, "act");
  if ( v3 && !strcmp(v3, "confirm") )
  {
    if ( get_value(v1, "ignore", &v30, 128) )
    {
      v4 = strtok(&v30, " ");
      do
      {
        v5 = atoi(v4);
        netdetect_write_option(v5, 0);
        v4 = strtok(0, " ");
      }
      while ( v4 );
    }
    else if ( get_value(v1, "warn", &v30, 128) )
    {
      v6 = strtok(&v30, " ");
      do
      {
        v7 = atoi(v6);
        netdetect_write_option(v7, 0x8000);
        v6 = strtok(0, " ");
      }
      while ( v6 );
    }
    v8 = 0;
    ((void (*)(void))netdetect_read_current_history)();
    do
    {
      v9 = netdetect_get_history_by_index(v8);
      v10 = *(_DWORD *)(v9 + 4);
      v11 = v9;
      if ( v10 == inet_addr(&v34) )
      {
        v12 = *(_DWORD *)(v11 + 24);
        if ( v12 & 1 )
        {
          v13 = v12 & 0xFFFFFFFE;
          v14 = *(_WORD *)v11;
          *(_DWORD *)(v11 + 24) = v13;
          netdetect_write_option(v14, v13);
        }
      }
      ++v8;
    }
    while ( v8 != 1000 );
    netdetect_set_option_rule(68, &v34);
  }
  printf("<form method=get action=\"netdetect.cgi\" name=\"ndwarning_fm\">");
  v15 = 0;
  printf("<input type=hidden name=\"act\" value=\"\">");
  v16 = 1;
  printf("<input type=hidden name=\"ignore\" value=\"\">");
  printf("<input type=hidden name=\"warn\" value=\"\">");
  printf("<input type=hidden name=\"flag\" value=\"\">");
  printf("<table style=\"border-collapse:collapse;\" border=0>");
  puts("<tr><td></td><td colspan=4><span class=\"item_string\">");
  puts("<font color=\"crimson\" size=2pt>");
  printf("<LI>경고! 관리자가 정한 수준이상으로 인터넷을 사용하고 있습니다.<br> 또는 웜바이러스에 감염되어 있을 수 도 있습니다.");
  printf("</font>");
  printf("</span></tr></td>");
  print_blank_line(5, 10);
  get_ifconfig("br0", &v33, &v32);
  puts("<tr><td></td><td colspan=4><span class=\"item_string\">");
  puts("<font color=\"blue\" size=2>");
  printf("<LI>[경고해제/확인] 버튼을 클릭하셔야 정상적인 인터넷 사용이 가능합니다.<br><LI>[재경고해제]를 체크후 [경고해제/확인] 버튼을 클릭을 하시면  해당 이벤트 재발생시 <br>경고페이지로 접속 되지 않습니다.");
  printf("<br><br>");
  printf("<LI>현재 정보는 <b> http://%s/mypage.html</b> 에서 다시 확인하실 수 있습니다.", &v33);
  printf("</font>");
  printf("</span></tr></td>");
  print_blank_line(5, 15);
  puts("<tr>");
  printf("<td></td>");
  print_item_desc("최근감지시간");
  print_item_desc("프로토콜");
  print_item_desc("설명");
  print_item_desc("재경고<br>해&nbsp;&nbsp;&nbsp;제");
  v17 = puts("</tr>");
  netdetect_read_current_history(v17);
  do
  {
    v18 = netdetect_get_history_by_index(v15);
    v19 = (_DWORD *)v18;
    v20.s_addr = *(_DWORD *)(v18 + 4);
    if ( !v20.s_addr )
      break;
    v21 = inet_ntoa(v20);
    if ( !strcmp(&v34, v21) )
    {
      puts("<tr>");
      if ( v19[6] & 1 )
        v22 = "<td><font color=\"limegreen\" size=2pt><sup> NEW </sup></font></td>";
      else
        v22 = "<td></td>";
      printf(v22);
      conv_time(v19[5], &v31, 1);
      print_item(&v31, 140);
      v23 = v19[2];
      if ( v23 == 6 )
      {
        v24 = "TCP";
      }
      else if ( v23 == 17 )
      {
        v24 = "UDP";
      }
      else
      {
        v25 = "Multi Port";
        if ( v23 == 1 )
          v25 = "ICMP";
        v24 = (char *)v25;
      }
      snprintf(&v31, 0x78u, "%s", v24, 0);
      if ( v19[2] > 1u )
        snprintf(&v31, 0x78u, "%s/%d", &v31, v19[3]);
      v16 = 0;
      print_item(&v31, 90);
      v26 = netdetect_comment_for_specified_port(v19[2], v19[3]);
      print_item(v26, 240);
      if ( v19[6] & 0x8000 )
        v27 = "";
      else
        v27 = "checked";
      if ( v19[2] )
        v28 = "";
      else
        v28 = "disabled";
      snprintf(&v31, 0x78u, "<input type=checkbox name=\"w%d\" value=\"%d\" %s %s>", *v19, *v19, v27, v28);
      print_item(&v31, 60);
      puts("</tr>");
    }
    ++v15;
  }
  while ( v15 != 1000 );
  if ( v16 )
  {
    puts("<tr>");
    printf("<td></td>");
    print_item("No Event", 140);
    print_item("-", 90);
    print_item("-", 240);
    print_item("-", 50);
    puts("</tr>");
  }
  print_blank_line(5, 10);
  printf("<tr><td colspan=5 align=center>");
  printf("<input type=button name=\"ndwarning\" value=\"경고해제/확인\" onclick=\"Confirm()\">");
  printf("</td></tr>");
  printf("</form>");
  print_blank_line(4, 20);
  return printf("</table>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 108BC: using guessed type int __fastcall netdetect_write_option(_DWORD, _DWORD);
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);
// 10A24: using guessed type int __fastcall conv_time(_DWORD, _DWORD, _DWORD);
// 10ACC: using guessed type int __fastcall netdetect_set_option_rule(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 11210: using guessed type int __fastcall netdetect_comment_for_specified_port(_DWORD, _DWORD);
// 11294: using guessed type int __fastcall netdetect_get_history_by_index(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11900: using guessed type int __fastcall netdetect_read_current_history(_DWORD);

//----- (00042220) --------------------------------------------------------
int __fastcall sub_42220(int a1)
{
  int v1; // r4@1
  int v2; // r0@5
  int v3; // r6@7
  int v4; // r6@13
  char s; // [sp+Ch] [bp-F4h]@1
  int v7; // [sp+8Ch] [bp-74h]@5
  _BYTE v8[3]; // [sp+B5h] [bp-4Bh]@5
  char v9; // [sp+C8h] [bp-38h]@1

  v1 = a1;
  memset(&s, 0, 0xB9u);
  if ( get_value(v1, "act", &v9, 32) && !strcmp(&v9, "add") )
  {
    get_value(v1, "pcname", &s, 128);
    if ( check_unpermitted_chars(&s) )
      strcpy(&s, "");
    get_hw_value(v1, "hw", &v7);
    get_value(v1, "service", v8, 20);
    v2 = add_remotepc_config(&s);
    goto LABEL_11;
  }
  if ( get_value(v1, "act", &v9, 32) )
  {
    v3 = strcmp(&v9, "del");
    if ( !v3 )
    {
      while ( 1 )
      {
        v2 = get_value_array(v1, "delchk", v3, &v9);
        if ( !v2 )
          break;
        ++v3;
        remove_remotepc_config(&v9);
      }
LABEL_11:
      signal_save(v2);
      return 0;
    }
  }
  if ( get_value(v1, "act", &v9, 32) )
  {
    v4 = strcmp(&v9, "wake");
    if ( !v4 )
    {
      while ( get_value_array(v1, "wakeupchk", v4, &v9) )
      {
        ++v4;
        send_wol_packet(&v9);
      }
    }
  }
  return 0;
}
// 10058: using guessed type int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A84: using guessed type int __fastcall add_remotepc_config(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 111F8: using guessed type int __fastcall send_wol_packet(_DWORD);
// 115E8: using guessed type int __fastcall remove_remotepc_config(_DWORD);

//----- (000423E4) --------------------------------------------------------
int sub_423E4()
{
  int v0; // r5@1
  int v1; // r0@1
  int v2; // r0@1
  char *v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@1
  int v12; // r0@1
  int v13; // r0@1
  int v14; // r0@2
  int v15; // r0@3
  char v17; // [sp+8h] [bp-BCh]@2
  int v18; // [sp+88h] [bp-3Ch]@3
  int v19; // [sp+C4h] [bp+0h]@3
  char v20; // [sp+144h] [bp+80h]@1

  v0 = 0;
  printf("<form method=get action=timepro.cgi name=remotepc_fm>");
  printf("<input type=hidden name=tmenu value=expertconf>");
  printf("<input type=hidden name=smenu value=remotepc>");
  printf("<input type=hidden name=act value=>");
  v1 = printf("<input type=hidden name=del value=>");
  v2 = print_start_content_table(v1);
  str(v2);
  print_item_desc("MAC 주소");
  puts("<td class=item_td align=left>");
  v3 = getenv("REMOTE_ADDR");
  get_internal_pc_hardware_address(v3, &v20);
  printf("<input type=checkbox class=navi_chk name=delchk onclick=\"SetHWOnCheckNoDisable(this,'hw','%s');\"> ", &v20);
  printf("현재 접속된 PC의 MAC주소로 설정");
  printf("<br>");
  sub_15664((int)"hw", 0, 0);
  print_nbsp(5);
  print_popup_button(
    "timepro.cgi?tmenu=popup&smenu=selectmac&formname=remotepc_fm&macprefix=hw",
    "searchmac",
    "width=400px,height=250px,scrollbars=yes,menubar=no,toolbar=no,resizable=yes",
    "macbutton");
  v4 = printf("</td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc(&unk_7B066);
  puts("<td colspan=2 class=item_td>");
  v6 = puts("<input type=text name=\"pcname\" maxlength=24 size=24 value=></td>");
  v7 = etr(v6);
  str(v7);
  puts("<td class=item_td colspan=2>");
  printf("<table class=nomargin_table width=100%%><tr><td align=left><font color='gray'>\n");
  printf("최대 %d개의 설정을 추가 할 수 있습니다.", 100);
  v8 = printf("</td><td align=right>");
  get_remotepc_num(v8);
  printf("<input type=button name=remotepc_submit value=\"추가\" onclick=\"AddPC();\" %s>");
  printf("</td></tr></table>");
  v9 = printf("</td>");
  v10 = etr(v9);
  print_end_content_table(v10);
  v11 = print_blank_line(1, 20);
  v12 = print_start_content_table(v11);
  str(v12);
  print_item_desc("");
  print_item_desc("MAC 주소");
  print_item_desc(&unk_7B066);
  printf("<td width=35 class=itemdesc_td align=center>");
  printf("<input class=navi_bt type=button name=wakup_bt  value=\"%s\" onclick=\"WakeUp()\">", "PC 켜기");
  printf("</td>");
  printf("<td class=itemdesc_td align=left width=38>");
  printf("<input class=navi_bt type=button name=del_bt value=\"%s\" onclick=\"DeleteRemotePC()\">", "삭제");
  v13 = printf("</td>");
  etr(v13);
  do
  {
    v14 = get_remotepc_config(v0, &v17);
    if ( !v14 )
      break;
    ++v0;
    str(v14);
    printf("<td class=item_td width=70>%d</td>\n", v0);
    sf_strncpy(&v19, &v18, 128);
    convert_mac(&v19);
    print_item(&v19, 200);
    print_item(&v17, 300);
    printf("<td class=item_td width=50 align=right><input type=checkbox name=wakeupchk value=\"%s\"></td>", &v18);
    v15 = printf("<td class=item_td align=center ><input type=checkbox name=delchk value=\"%s\"></td>", &v18);
    v14 = etr(v15);
  }
  while ( v0 != 100 );
  print_end_content_table(v14);
  return puts("</form>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10844: using guessed type int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 116E4: using guessed type int __fastcall get_remotepc_config(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11B94: using guessed type int __fastcall get_remotepc_num(_DWORD);

//----- (00042748) --------------------------------------------------------
_BOOL4 __fastcall sub_42748(int a1)
{
  char v2; // [sp+4h] [bp-64h]@1
  int v3; // [sp+18h] [bp-50h]@1

  ddnsapi_get_status(a1, &v2);
  return time(0) - v3 <= 2;
}
// 116C0: using guessed type int __fastcall ddnsapi_get_status(_DWORD, _DWORD);

//----- (0004277C) --------------------------------------------------------
signed int __fastcall sub_4277C(int a1)
{
  int v1; // r4@1
  signed int result; // r0@2
  int v3; // r0@6
  char *v4; // r1@9
  char *v5; // r0@11
  char *v6; // r5@11
  int v7; // r0@21
  int v8; // r5@23
  int v9; // r5@27
  char s; // [sp+8h] [bp-5B8h]@6
  int v11; // [sp+Ch] [bp-5B4h]@10
  int v12; // [sp+2Ch] [bp-594h]@6
  int v13; // [sp+42Ch] [bp-194h]@17
  int v14; // [sp+46Ch] [bp-154h]@19
  int v15; // [sp+4ACh] [bp-114h]@13
  int v16; // [sp+4ECh] [bp-D4h]@9
  int v17; // [sp+508h] [bp-B8h]@9
  int v18; // [sp+588h] [bp-38h]@1

  v1 = a1;
  if ( !get_value_post(a1, "act", &v18, 32) )
    return -1;
  if ( strcmp((const char *)&v18, "addhost") )
  {
    if ( strcmp((const char *)&v18, "delhost") )
    {
      v3 = strcmp((const char *)&v18, "refreshhost");
      v9 = v3;
      if ( !v3 )
      {
        do
        {
          v3 = get_value_array_post(v1, "refreshchk", v9, &v17);
          if ( !v3 )
            break;
          if ( sub_42748((int)&v17) )
            return 0;
          ++v9;
          v3 = ddnsapi_set_refresh_flag(&v17, 1);
        }
        while ( v9 != 6 );
      }
      goto LABEL_31;
    }
    v8 = 0;
    do
    {
      v7 = get_value_array_post(v1, "delchk", v8, &v17);
      if ( !v7 )
        break;
      ++v8;
      v7 = ddnsapi_remove_host(&v17);
    }
    while ( v8 != 6 );
    goto LABEL_26;
  }
  if ( check_valid_account(0) || (result = sub_1633C(v1)) != 0 )
  {
    memset(&s, 0, 0x500u);
    v3 = get_value_post(v1, "hostname", &v12, 1024);
    if ( !v3 )
    {
LABEL_31:
      signal_update(v3);
      return 0;
    }
    result = sub_1648C((const char *)&v12);
    if ( !result )
      return result;
    if ( sub_42748((int)&v12) )
      return 0;
    get_value_post(v1, "select_ddns", &v17, 128);
    strcpy((char *)&v16, "wan1");
    v4 = strtok((char *)&v17, "_");
    if ( v4 )
      sf_strncpy(&v11, v4, 32);
    v5 = strtok(0, "");
    v6 = v5;
    if ( v5 && strcmp(v5, "null") )
      sf_strncpy(&v15, v6, 64);
    if ( !strcmp((const char *)&v11, "iptime") && sub_16404(0) )
      return 0;
    get_value_post(v1, "userid", &v13, 64);
    if ( check_unpermitted_chars(&v13) )
      return 0;
    if ( !strcmp((const char *)&v11, "iptime") )
      strcpy((char *)&v14, "iptime");
    else
      get_value_post(v1, "passwd", &v14, 64);
    v7 = ddnsapi_add_config(&s);
LABEL_26:
    v3 = signal_save(v7);
    goto LABEL_31;
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10538: using guessed type int __fastcall ddnsapi_remove_host(_DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10B2C: using guessed type int __fastcall ddnsapi_add_config(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11624: using guessed type int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A2C: using guessed type int __fastcall ddnsapi_set_refresh_flag(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (00042A70) --------------------------------------------------------
void *__fastcall sub_42A70(int a1, const char *a2)
{
  const char *v2; // r2@1
  int v3; // r5@3
  char *i; // r1@3
  int v5; // r4@7
  char *j; // r1@7
  char dest; // [sp+8h] [bp-450h]@3
  int v9; // [sp+408h] [bp-50h]@3

  v2 = "null";
  if ( *a2 )
    v2 = a2;
  snprintf((char *)&v9, 0x40u, "%s_%s", a1, v2);
  strcpy(&dest, (const char *)&unk_7B390);
  v3 = 0;
  for ( i = strtok(&dest, ","); i && strcmp((const char *)&v9, i); i = strtok(0, ",") )
    ++v3;
  strcpy(&dest, "ipTIME DDNS,dyndns.org(DynDns)");
  v5 = 0;
  for ( j = strtok(&dest, ","); j; j = strtok(0, ",") )
  {
    if ( v5 == v3 )
      sf_strncpy(&unk_9175C, j, 128);
    ++v5;
  }
  return &unk_9175C;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);

//----- (00042B80) --------------------------------------------------------
int __fastcall sub_42B80(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@2
  int v5; // r0@4
  int v6; // r0@4
  int v7; // r0@4
  int v8; // r0@4
  const char *v9; // r0@4
  char *v10; // r3@14
  char v12; // [sp+8h] [bp-E08h]@2
  int v13; // [sp+Ch] [bp-E04h]@4
  char v14; // [sp+2Ch] [bp-DE4h]@3
  int v15; // [sp+42Ch] [bp-9E4h]@4
  int v16; // [sp+46Ch] [bp-9A4h]@5
  int v17; // [sp+4ACh] [bp-964h]@4
  int v18; // [sp+508h] [bp-908h]@4
  int v19; // [sp+908h] [bp-508h]@4
  int v20; // [sp+D08h] [bp-108h]@7
  int v21; // [sp+D88h] [bp-88h]@2
  int v22; // [sp+D8Ch] [bp-84h]@14
  time_t v23; // [sp+D9Ch] [bp-74h]@6
  int v24; // [sp+DA0h] [bp-70h]@9
  int v25; // [sp+DE4h] [bp-2Ch]@11

  v1 = 0;
  v2 = print_start_content_table(a1);
  str(v2);
  print_item_desc("호스트이름");
  printf("<td width=320 class=itemdesc_td>");
  printf("접속상태");
  printf("</td>");
  printf("<td width=170 class=itemdesc_td>");
  printf("</td>");
  printf("<td class=itemdesc_td align=left width=30>");
  puts("<input class=navi_bt type=button name=refresh_bt value=\"갱신\" onclick=\"RefreshHost();\">");
  printf((const char *)&unk_7B480);
  puts("<input class=navi_bt type=button name=rm_bt value=\"삭제\" onclick=\"DelHost();\">");
  v3 = printf("</td>");
  etr(v3);
  do
  {
    memset(&v21, 0, 0x5Cu);
    memset(&v12, 0, 0x500u);
    v4 = ddnsapi_read_config(v1, &v12);
    if ( !v4 )
      break;
    if ( v14 )
    {
      v5 = ddnsapi_get_status(&v14, &v21);
      str(v5);
      sf_strncpy(&v19, &v14, 1024);
      v6 = collapse(&v19, 32);
      snprintf((char *)&v18, 0x400u, "<a href=# onclick=\"ViewDetail(%d)\">%s</a>", v1, v6);
      print_item(&v18, 0);
      printf((const char *)&unk_7B52B, &v14);
      printf("<td class=item_td align=left>");
      printf("<input type=checkbox name=refreshchk value=\"%s\">", &v14);
      printf("</td><td width=30 class=item_td align=left>");
      printf("<input type=checkbox name=delchk value=\"%s\">", &v14);
      v7 = printf("</td>");
      etr(v7);
      printf("<input type=hidden id=toggle_%d value=0>", v1);
      printf("<tr ID='detail_%d' style='display:none'>\n", v1);
      printf("<td class=item_td colspan=5>");
      printf("<span class=gray_text>");
      printf("호스트이름 : ");
      v8 = collapse(&v14, 60);
      printf("%s", v8);
      printf("<br>");
      printf("서비스 공급자 : ");
      v9 = (const char *)sub_42A70((int)&v13, (const char *)&v17);
      printf(v9);
      printf("<br>");
      printf("사용자 ID : ");
      printf((const char *)&v15);
      if ( strcmp((const char *)&v13, "iptime") )
      {
        print_nbsp(10);
        printf("사용자 암호 : ");
        printf((const char *)&v16);
      }
      printf("<br>");
      printf("마지막 등록시간 : ");
      if ( v23 )
        sub_1655C(v23, (char *)&v20, 0x80u, 0);
      else
        strcpy((char *)&v20, "---------");
      printf((const char *)&v20);
      printf("<br>");
      printf("다음 갱신시간 : ");
      if ( v24 && v23 )
      {
        time((time_t *)&v25);
        sub_1655C(v24 + v25, (char *)&v20, 0x80u, 0);
      }
      else
      {
        strcpy((char *)&v20, "---------");
      }
      printf((const char *)&v20);
      printf("<br>");
      printf("마지막 등록IP : ");
      if ( v21 )
        v10 = (char *)&v22;
      else
        v10 = "----";
      snprintf((char *)&v18, 0x400u, "%s", v10, 0);
      printf((const char *)&v18);
      printf("</span>");
      printf("</td>");
      v4 = printf("</tr>");
    }
    ++v1;
  }
  while ( v1 != 6 );
  return print_end_content_table(v4);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);
// 10A00: using guessed type int __fastcall ddnsapi_read_config(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11690: using guessed type int __fastcall collapse(_DWORD, _DWORD);
// 116C0: using guessed type int __fastcall ddnsapi_get_status(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00042F8C) --------------------------------------------------------
int sub_42F8C()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r0@1
  int v10; // r0@1
  int v11; // r0@3
  int v12; // r0@3
  int v13; // r0@3
  int v14; // r0@3
  int v15; // r0@3
  char v17; // [sp+8h] [bp-370h]@1
  char dest; // [sp+14h] [bp-364h]@1
  char v19; // [sp+208h] [bp-170h]@1
  char v20; // [sp+214h] [bp-164h]@1
  char v21; // [sp+308h] [bp-70h]@2
  char v22; // [sp+348h] [bp-30h]@2

  puts("<form method=post action=timepro.cgi name=dyndns_conf>");
  puts("<input type=hidden name=tmenu value=expertconf>");
  puts("<input type=hidden name=smenu value=ddns>");
  puts("<input type=hidden name=act value=>");
  v0 = ddnsapi_get_host_count("iptime");
  printf("<input type=hidden name=iptimecnt value=%d>\n", v0);
  v1 = ddnsapi_get_host_count("dyndns");
  v2 = printf("<input type=hidden name=dyndnscnt value=%d>\n", v1);
  v3 = print_start_content_table(v2);
  str(v3);
  print_item_desc("서비스 공급자");
  printf("<td class=item_td>");
  strcpy(&v17, "ipTIME DDNS,");
  strcpy(&v19, "iptime_null,");
  strcpy(&dest, "dyndns.org(DynDNS),");
  strcpy(&v20, "dyndns_null,");
  v4 = print_input_select(&v17, &v19, 44, "select_ddns");
  v5 = etr(v4);
  str(v5);
  print_item_desc("호스트이름");
  printf("<td class=item_td>");
  puts("<input type=text name=hostname size=32 maxlength=50 onkeyup=\"CheckHostNameValue(this);\" style=\"ime-mode:disabled;\">");
  v6 = puts("</td>");
  v7 = etr(v6);
  str(v7);
  print_item_desc("사용자 ID");
  printf("<td class=item_td>");
  puts("<input type=text name=userid size=20 maxlength=32 style=\"ime-mode:disabled;\">");
  v8 = puts("</td>");
  etr(v8);
  printf("<tr id=passwd_row>");
  print_item_desc("사용자 암호");
  printf("<td class=item_td>");
  puts("<input type=password name=passwd size=20 maxlength=32 style=\"ime-mode:disabled;\">");
  puts("</td>");
  v9 = printf("</tr>");
  v10 = check_valid_account(v9);
  if ( !v10 )
  {
    get_http_auth_method(&v21);
    hwinfo_get_language_postfix(&v22);
    printf(
      "<input type=hidden name=default_captcha_desc value='%s'>\n",
      "보안문자(영문 소문자 5글자)를 입력하세요.");
    puts("<input type=hidden name=captcha_file value=>");
    printf(
      "<TR><TD class=itemdesc_td>%s</TD><TD class=item_td><TABLE CELLPADDING=0 CELLSPACING=0 HEIGHT=72 >\n",
      "보안문자");
    printf(
      "<TR><TD COLSPAN=2><INPUT type=text name=captcha_code STYLE=\"width:255px; height:21px; color:#888888;\" value=\"%s"
      "\" onfocus=\"FocusCaptcha(document.dyndns_conf);\" onblur=\"BlurCaptcha(document.dyndns_conf);\"></TD></TR>\n",
      "보안문자(영문 소문자 5글자)를 입력하세요.");
    printf("<TR><TD colspan=2 HEIGHT=5></TD></TR>");
    printf(
      "<TR style=\"font: normal normal normal 12px arial; color:#000000; border:#C6C9CC 1px solid; width:181px; height:21"
      "px;\"><TD WIDTH=25><IMG SRC=\"/images2/login_bt_refresh.%s.gif\" BORDER=0 ONCLICK=\"iframe_captcha.location.reload"
      "();\" STYLE=\"cursor:pointer;\"></TD>\n",
      &v22);
    strcmp(&v21, "session");
    printf("<TD><IFRAME NAME=iframe_captcha ID=iframe_captcha SRC=\"/%s/captcha.cgi\" WIDTH=201 HEIGHT=70 FRAMEBORDER=no SCROLLING=no></IFRAME></TD></TR>\n");
    v10 = printf("</TABLE></TD></TR>");
  }
  str(v10);
  printf("<td height=70px colspan=4 class=item_td><span class=gray_text>");
  printf("<div id=iptime_null>");
  printf("<LI> ipTIME DDNS를 사용하실때에는 별도의 등록과정이 필요 없습니다. </LI> <LI> 호스트이름은  iptime.org 로 끝나야 합니다. ( 예> testtest.iptime.org )</LI>");
  printf("<LI> 사용자ID는 E-mail주소를 입력해야 합니다. </LI>");
  printf("<LI> 한 개의 호스트만 등록할 수 있습니다. </LI>");
  printf("</div>");
  printf("<div id=dyndns_null style='display:none'>");
  printf("<LI> <span class=movetomain><a href=\"http://www.dyndns.org\" target=blank><U> www.dyndns.org </U></a></span>에서 가입하신 후 사용하셔야 합니다.</LI>");
  printf("</div>");
  v11 = printf("</td>");
  v12 = etr(v11);
  str(v12);
  printf("<td class=item_td colspan=4 align=right>");
  ddnsapi_get_host_count(0);
  printf("<input class=navi_bt type=button name=add_bt value=\"추가\" %s>");
  v13 = printf("</td>");
  v14 = etr(v13);
  print_end_content_table(v14);
  v15 = print_blank_line(1, 20);
  sub_42B80(v15);
  printf("</form>");
  return printf("<script> InitDDNS();</script>");
}
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 104F0: using guessed type int __fastcall hwinfo_get_language_postfix(_DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 11138: using guessed type int __fastcall ddnsapi_get_host_count(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 1148C: using guessed type int __fastcall print_input_select(_DWORD, _DWORD, _DWORD, _DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (0004332C) --------------------------------------------------------
int sub_4332C()
{
  int v0; // r7@1
  char *v1; // r0@6
  char *v2; // r0@11
  void *v3; // r0@12
  int v5; // [sp+4h] [bp-87Ch]@2
  char v6; // [sp+28h] [bp-858h]@3
  int v7; // [sp+504h] [bp-37Ch]@11
  int v8; // [sp+704h] [bp-17Ch]@13
  int v9; // [sp+804h] [bp-7Ch]@2
  char v10; // [sp+820h] [bp-60h]@4

  v0 = 0;
  printf("<html>");
  do
  {
    memset(&v9, 0, 0x5Cu);
    memset(&v5, 0, 0x500u);
    if ( !ddnsapi_read_config(v0, &v5) )
      break;
    if ( v6 )
    {
      ddnsapi_get_status(&v6, &v9);
      if ( !v10 )
        strcpy(&v10, "등록 시도중");
      v1 = strchr(&v10, 59);
      if ( v1 )
        *v1 = 0;
      if ( ddnsapi_get_refresh_flag(&v6) )
      {
        strcpy(&v10, "등록 시도중");
        goto LABEL_12;
      }
      if ( v9 == 1 )
      {
        v2 = (char *)&v7;
      }
      else
      {
LABEL_12:
        v3 = sub_16094();
        v2 = (char *)&v7 + snprintf((char *)&v7, 0x180u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v3);
      }
      snprintf(v2, 0x80u, "%s", &v10);
      snprintf((char *)&v8, 0x100u, "ddns_status_%s", &v6);
      puts("<script>");
      printf("if(parent.document.getElementById('%s'))", &v8);
      printf("parent.document.getElementById('%s').innerHTML = '%s';", &v8, &v7);
      printf("if(parent.parent.document.getElementById('%s'))", &v8);
      printf((const char *)&unk_7BDC2, &v8, &v7);
      puts("</script>");
    }
    ++v0;
  }
  while ( v0 != 6 );
  printf("<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=iframe_ddns_status\">");
  return printf("</html>");
}
// 10388: using guessed type int __fastcall ddnsapi_get_refresh_flag(_DWORD);
// 10A00: using guessed type int __fastcall ddnsapi_read_config(_DWORD, _DWORD);
// 116C0: using guessed type int __fastcall ddnsapi_get_status(_DWORD, _DWORD);

//----- (00043540) --------------------------------------------------------
int __fastcall sub_43540(int a1)
{
  int v1; // r5@1
  int v2; // r0@7
  int v3; // r6@9
  int v4; // r6@14
  char s; // [sp+8h] [bp-C0h]@5
  int v7; // [sp+28h] [bp-A0h]@6
  int v8; // [sp+48h] [bp-80h]@6
  char v9; // [sp+70h] [bp-58h]@1

  v1 = a1;
  if ( get_value_post(a1, "act", &v9, 64) )
  {
    if ( !strcmp(&v9, "add") )
    {
      if ( check_valid_account(0) || sub_1633C(v1) )
      {
        memset(&s, 0, 0x68u);
        get_value_post(v1, "account", &s, 32);
        if ( !check_unpermitted_chars(&s) )
        {
          get_value_post(v1, "password", &v7, 32);
          get_ip_value_post(v1, "ip", &v8);
          if ( sub_164F8(&s) )
            v2 = pptpserver_add_user(&s);
          else
            v2 = sub_15324((int)"동일한 VPN접속 계정이 존재합니다.");
LABEL_19:
          signal_save(v2);
          return 0;
        }
      }
    }
    else
    {
      v3 = strcmp(&v9, "del");
      if ( !v3 )
      {
        do
        {
          v2 = get_value_array_post(v1, "delchk", v3, &v9);
          if ( v2 )
            v2 = pptpserver_remove_user(&v9);
          ++v3;
        }
        while ( v3 != 5 );
        goto LABEL_19;
      }
      v4 = strcmp(&v9, (const char *)&unk_57CFC);
      if ( !v4 )
      {
        do
        {
          if ( get_value_array_post(v1, "dischk", v4, &v9) )
            pptpserver_disconnect_user(&v9);
          ++v4;
        }
        while ( v4 != 5 );
        v2 = sleep(5u);
        goto LABEL_19;
      }
    }
  }
  return 0;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11624: using guessed type int __fastcall get_value_array_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11858: using guessed type int __fastcall pptpserver_add_user(_DWORD);
// 11888: using guessed type int __fastcall get_ip_value_post(_DWORD, _DWORD, _DWORD);
// 118F4: using guessed type int __fastcall pptpserver_disconnect_user(_DWORD);
// 11C60: using guessed type int __fastcall pptpserver_remove_user(_DWORD);

//----- (000436F8) --------------------------------------------------------
int __fastcall sub_436F8(int a1)
{
  int v1; // r5@1
  int v2; // r6@3
  int v3; // r0@3
  int v4; // r0@3
  int v5; // r0@3
  int v7; // [sp+0h] [bp-30h]@1

  v1 = a1;
  if ( get_value_post(a1, "act", &v7, 32) && !strcmp((const char *)&v7, "apply") )
  {
    get_value_post(v1, "operation", &v7, 32);
    v2 = atoi((const char *)&v7);
    get_value_post(v1, "mppe", &v7, 32);
    v3 = atoi((const char *)&v7);
    v4 = pptpserver_set_config(v2, v3);
    v5 = signal_update(v4);
    signal_save(v5);
    signal_start("vpn");
  }
  return 0;
}
// 100D0: using guessed type int __fastcall pptpserver_set_config(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 108B0: using guessed type int __fastcall signal_start(_DWORD);
// 10DB4: using guessed type int __fastcall get_value_post(_DWORD, _DWORD, _DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (000437AC) --------------------------------------------------------
__int64 __fastcall sub_437AC(int a1, int a2, int a3, int a4)
{
  int v4; // r0@1
  int v5; // r0@1
  char *v6; // r1@2
  int v7; // r0@4
  int v8; // r0@4
  char *v9; // r1@5
  char *v10; // r1@8
  int v11; // r0@10
  int v12; // r0@10
  int v13; // r0@10
  int v14; // r0@10
  __int64 v16; // [sp+0h] [bp-20h]@1
  int v17; // [sp+8h] [bp-18h]@1
  int v18; // [sp+Ch] [bp-14h]@1

  HIDWORD(v16) = a2;
  v17 = a3;
  v18 = a4;
  pptpserver_get_config(&v18, &v17);
  printf("<form method=post action=\"timepro.cgi\" name=\"pptpvpn_conf_fm\">");
  printf("<input type=hidden name=\"tmenu\" value=\"expertconf\">");
  printf("<input type=hidden name=\"smenu\" value=\"pptpvpn\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  v4 = print_sub_title("VPN(PPTP) 서버설정", 1);
  v5 = print_start_content_table(v4);
  str(v5);
  print_item_desc("동작 모드");
  puts("<td class=item_td>");
  printf("<input type=radio name=operation value=1 %s> %s");
  print_nbsp(10);
  if ( v18 )
    v6 = "";
  else
    v6 = "checked";
  printf("<input type=radio name=operation value=0 %s> %s", v6, "중단");
  v7 = puts("</td>");
  v8 = etr(v7);
  str(v8);
  LODWORD(v16) = 0;
  print_item_desc("암호화(MPPE)");
  puts("<td class=item_td>");
  if ( v17 )
    v9 = "checked";
  else
    v9 = "";
  printf("<input type=radio name=mppe value=1 %s> %s", v9, "암호화 사용함");
  print_nbsp(10);
  if ( v17 )
    v10 = "";
  else
    v10 = "checked";
  printf("<input type=radio name=mppe value=0 %s> %s", v10, "암호화 없음");
  v11 = puts("</td>");
  v12 = etr(v11);
  str(v12);
  puts("<td colspan=2 class=item_td align=right>");
  puts("<input type=button name=pptp_submit value=\"적용\" onclick=\"ApplyPPTP()\">");
  v13 = printf("</td>");
  v14 = etr(v13);
  print_end_content_table(v14);
  printf("</form>");
  return v16;
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10D54: using guessed type int __fastcall pptpserver_get_config(_DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00043960) --------------------------------------------------------
int sub_43960()
{
  int v0; // r0@1
  int v1; // r0@1
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v5; // r0@1
  int v6; // r0@1
  int v7; // r0@1
  int v8; // r0@1
  int v9; // r6@3
  int v10; // r0@3
  char *v11; // r1@4
  int v12; // r0@6
  int v13; // r0@6
  int v14; // r0@6
  int v15; // r0@6
  int v16; // r0@7
  const char *v17; // r0@8
  int v18; // r1@8
  char *v19; // r2@13
  char v21; // [sp+8h] [bp-128h]@7
  int v22; // [sp+48h] [bp-E8h]@8
  int v23; // [sp+6Ch] [bp-C4h]@8
  char v24; // [sp+70h] [bp-C0h]@2
  char v25; // [sp+B0h] [bp-80h]@2
  char v26; // [sp+D0h] [bp-60h]@1
  char v27; // [sp+F0h] [bp-40h]@1

  printf("<form method=post action=timepro.cgi name=pptpvpn_account_fm>");
  printf("<input type=hidden name=tmenu value=expertconf>");
  printf("<input type=hidden name=smenu value=pptpvpn>");
  printf("<input type=hidden name=act value=>");
  v0 = print_sub_title("VPN(PPTP) 계정 설정", 0);
  v1 = print_start_content_table(v0);
  str(v1);
  print_item_desc("VPN 접속 계정");
  puts("<td class=item_td>");
  v2 = printf("<input type=text name=account size=30 maxlength=30 style=\"ime-mode:disabled\"></td>");
  v3 = etr(v2);
  str(v3);
  print_item_desc(&unk_7C1D2);
  puts("<td class=item_td>");
  v4 = puts("<input type=password name=password size=30 maxlength=30 style=\"ime-mode:disabled\"></td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc("할당 될 IP 주소");
  puts("<td class=item_td>");
  get_ifconfig("br0", &v27, &v26);
  sub_157CC((int)"ip", &v27, 3);
  v6 = puts("</td>");
  v7 = etr(v6);
  v8 = check_valid_account(v7);
  if ( !v8 )
  {
    get_http_auth_method(&v24);
    hwinfo_get_language_postfix(&v25);
    printf(
      "<input type=hidden name=default_captcha_desc value='%s'>\n",
      "보안문자(영문 소문자 5글자)를 입력하세요.");
    puts("<input type=hidden name=captcha_file value=>");
    printf(
      "<TR><TD class=itemdesc_td>%s</TD><TD class=item_td><TABLE CELLPADDING=0 CELLSPACING=0 HEIGHT=72 >\n",
      "보안문자");
    printf(
      "<TR><TD COLSPAN=2><INPUT type=text name=captcha_code STYLE=\"width:255px; height:21px; color:#888888;\" value=\"%s"
      "\" onfocus=\"FocusCaptcha(document.pptpvpn_account_fm);\" onblur=\"BlurCaptcha(document.pptpvpn_account_fm);\"></TD></TR>\n",
      "보안문자(영문 소문자 5글자)를 입력하세요.");
    printf("<TR><TD colspan=2 HEIGHT=5></TD></TR>");
    printf(
      "<TR style=\"font: normal normal normal 12px arial; color:#000000; border:#C6C9CC 1px solid; width:181px; height:21"
      "px;\"><TD WIDTH=25><IMG SRC=\"/images2/login_bt_refresh.%s.gif\" BORDER=0 ONCLICK=\"iframe_captcha.location.reload"
      "();\" STYLE=\"cursor:pointer;\"></TD>\n",
      &v25);
    strcmp(&v24, "session");
    printf("<TD><IFRAME NAME=iframe_captcha ID=iframe_captcha SRC=\"/%s/captcha.cgi\" WIDTH=201 HEIGHT=70 FRAMEBORDER=no SCROLLING=no></IFRAME></TD></TR>\n");
    v8 = printf("</TABLE></TD></TR>");
  }
  str(v8);
  v9 = 0;
  printf("<td colspan=2 class=item_td><table class=nomargin_table width=100%%>");
  printf("<tr><td align=left><font color='gray'>최대 %d명의 사용자를 추가 할 수 있습니다.</td>\n", 5);
  v10 = puts("<td align=right>");
  if ( pptpserver_user_count(v10) > 4 )
    v11 = "disabled";
  else
    v11 = "";
  printf(
    "<input class=navi_bt type=button name=pptpvpn_conf value=\"추가\" onclick=\"AddPPTPServerUser();\" %s>",
    v11);
  puts("</td></tr>");
  v12 = printf("</table></td>");
  etr(v12);
  puts("</table></td></tr>");
  v13 = print_blank_line(1, 20);
  v14 = print_start_content_table(v13);
  str(v14);
  print_item_desc("VPN 접속 계정");
  print_item_desc("할당 될 IP 주소");
  print_item_desc("연결 상태");
  puts("<td align=left width=100 class=itemdesc_td>");
  printf("<input class=navi_bt type=button name=button_del value=\"연결끊기\" onclick=\"DisconnectPPTPUser();\">");
  printf("</td>");
  puts("<td align=left width=30 class=itemdesc_td>");
  printf("<input class=navi_bt type=button name=button_del value=\"삭제\" onclick=\"RemovePPTPUser();\">");
  v15 = printf("</td>");
  etr(v15);
  do
  {
    memset(&v21, 0, 0x68u);
    v16 = pptpserver_get_index_pptpinfo(v9, &v21);
    if ( !v16 )
      break;
    ++v9;
    str(v16);
    print_item(&v21, 0);
    v17 = (const char *)print_item(&v22, 0);
    v18 = v23;
    if ( v23 )
    {
      v18 = 0;
      v17 = "접속됨";
    }
    if ( !v23 )
      v17 = "<font color='gray'>연결되지않음</font>";
    print_item(v17, v18);
    printf("<td align=left class=item_td>");
    v19 = v23 ? "" : "disabled";
    printf("<input type=checkbox name=dischk value='%s' %s>", &v21, v19);
    printf("</td>");
    printf("<td align=left class=item_td>");
    printf("<input type=checkbox name=delchk value=\"%s\">", &v21);
    printf("</td>");
    v16 = puts("</tr>");
  }
  while ( v9 != 5 );
  print_end_content_table(v16);
  return puts("</form>");
}
// 103C4: using guessed type int __fastcall get_http_auth_method(_DWORD);
// 104F0: using guessed type int __fastcall hwinfo_get_language_postfix(_DWORD);
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);
// 10A0C: using guessed type int __fastcall check_valid_account(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10D00: using guessed type int __fastcall pptpserver_get_index_pptpinfo(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11A50: using guessed type int __fastcall pptpserver_user_count(_DWORD);

//----- (00043DD0) --------------------------------------------------------
int __fastcall sub_43DD0(int a1)
{
  int v1; // r4@1
  int v2; // r0@1
  int v3; // r5@1
  int v4; // r0@1
  int v5; // r0@1
  char *v6; // r1@7
  int v7; // r0@8
  int v8; // r4@10
  int v9; // r0@10
  int v10; // r0@10
  int v11; // r0@10
  char *v12; // r2@12
  int v13; // r1@14
  char *v14; // r3@14
  int v15; // r0@15
  int v16; // r0@15
  int v17; // r0@15
  int v18; // r0@18
  int v19; // r0@18
  int v20; // r0@19
  int v21; // r0@19
  int v23; // [sp+0h] [bp-220h]@10
  char v24; // [sp+Ch] [bp-214h]@1
  char v25; // [sp+10Ch] [bp-114h]@2
  char s1; // [sp+18Ch] [bp-94h]@1
  char v27; // [sp+1CCh] [bp-54h]@11
  char v28; // [sp+1E0h] [bp-40h]@16

  print_start_content_table(a1);
  v1 = 0;
  puts("<form method=get action=timepro.cgi name=realtime_fm>");
  puts("<input type=hidden name=tmenu value=sysconf>");
  puts("<input type=hidden name=smenu value=realtime>");
  v2 = puts("<input type=hidden name=act value=>");
  str(v2);
  print_item_desc("현재 시스템 시간");
  printf("<td class=item_td>");
  sub_167D8(&v24, 0x100u);
  v3 = 0;
  printf(&v24);
  v4 = printf("</td>");
  v5 = etr(v4);
  str(v5);
  print_item_desc("Time Server 설정");
  puts("<td class=item_td>");
  get_timeserver_conf(&s1);
  printf("<select name=server_list onchange=\"SelectTimeServer()\">");
  printf("<option value=null> %s </option>", "시간 서버 직접 입력");
  do
  {
    if ( !get_timeserver_list(v3, &v25) )
      break;
    printf("<option value=%s ", &v25);
    if ( !strcmp(&v25, &s1) )
    {
      v1 = v3;
      printf("selected");
    }
    ++v3;
    printf(">%s</option>", &v25);
  }
  while ( v3 != 15 );
  printf("</select>");
  print_nbsp(3);
  if ( v1 )
  {
    v6 = "";
  }
  else
  {
    v7 = strcmp(&s1, "null");
    v6 = "";
    if ( v7 )
      v6 = &s1;
  }
  v8 = 0;
  v9 = printf("<input type=text name=server_edit value=\"%s\" size=24 maxlength=60>", v6);
  br(v9);
  printf("<input type=checkbox name=summer_flag value=1 %s>");
  printf("일광절약시간제 적용");
  v10 = puts("</td>");
  v11 = etr(v10);
  str(v11);
  v23 = 0;
  print_item_desc("표준시간대");
  puts("<td class=item_td>");
  puts("<select name=gmtidx>");
  do
  {
    if ( !strcmp(&aGmt0[144 * v8], &v27) )
      v12 = "selected";
    else
      v12 = "";
    v13 = v8;
    v14 = &aGmt0[144 * v8++ + 8];
    printf("<option value=%d %s>%s</option>", v13, v12, v14, v23);
  }
  while ( v8 != 28 );
  puts("</select>");
  v15 = printf("</td>");
  v16 = etr(v15);
  v17 = get_timed_status(v16);
  if ( !v17 )
  {
    if ( !get_wan_ip("wan1", &v28) || (v17 = get_wan_link("wan1")) == 0 )
    {
      printf("<tr height=70>");
      printf("<td colspan=2 class=item_td align=left>");
      printf("<span class=gray_text>");
      v18 = printf("공유기가 인터넷에 연결되어있지 않아 시스템 시간을 설정할 수 없습니다.");
      br(v18);
      printf("순수 AP모드로 사용 시(WAN포트미사용)에는 <a href=\"JavaScript:MovePagetoMain('netconf','lansetup');\"><U>[내부 네트워크 설정]</U></a> 페이지로 접속하여,<br> 내부 게이트웨이 및 DNS주소를 설정하십시오.");
      v19 = printf("</span>");
      v17 = etr(v19);
    }
  }
  str(v17);
  printf("<td colspan=2 class=item_td align=right>");
  v20 = puts("<input type=button name=save VALUE=\"적용\" onclick=\"ApplyTimeServer();\"></td>");
  v21 = etr(v20);
  print_end_content_table(v21);
  puts("</form>");
  puts("<script>");
  puts("SelectTimeServer();");
  return puts("</script>");
}
// 10484: using guessed type int __fastcall get_timeserver_conf(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10AB4: using guessed type int __fastcall get_wan_link(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 11600: using guessed type int __fastcall get_timeserver_list(_DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (000444C8) --------------------------------------------------------
FILE *__fastcall sub_444C8(int a1)
{
  FILE *result; // r0@1
  FILE *v2; // r5@1
  char v3; // [sp+8h] [bp-98h]@1
  void *ptr; // [sp+88h] [bp-18h]@1
  size_t n; // [sp+8Ch] [bp-14h]@1

  n = 0;
  get_value_post_multipart_file(a1, "restore_config_file", &ptr, &v3);
  result = fopen("/var/run/rsavefs.gz", "w+");
  v2 = result;
  if ( result )
  {
    fwrite(ptr, 1u, n, result);
    fclose(v2);
    system((const char *)&unk_7CFAC);
    if ( restore_backup_config("/var/run/rsavefs") == -1 )
    {
      if ( v3 )
        syslog_msg(3, "설정 파일이 잘못되어 설정 복원 실패 - 파일 이름 : %s", &v3);
    }
    else
    {
      syslog_msg(1, "설정 복원 성공 - 파일 이름 : %s");
      istatus_set_value_direct("cfgrestore", "ok");
    }
    unlink("/var/run/rsavefs.gz");
    result = (FILE *)unlink("/var/run/rsavefs");
  }
  return result;
}
// 10C1C: using guessed type int __fastcall get_value_post_multipart_file(_DWORD, _DWORD, _DWORD, _DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 115D0: using guessed type int __fastcall istatus_set_value_direct(_DWORD, _DWORD);
// 11960: using guessed type int __fastcall restore_backup_config(_DWORD);

//----- (000445BC) --------------------------------------------------------
int __fastcall sub_445BC(int a1, int a2)
{
  int v2; // r0@1
  int v3; // r0@1
  int v4; // r0@1
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1

  v7 = a2;
  strcpy((char *)&v6, "eth0");
  wizard_api_set_status(&v6, "initial");
  puts("<form method=get action=timepro.cgi name=wizard>");
  puts("<input type=hidden name=tmenu value=wizard>");
  puts("<input type=hidden name=step>");
  puts("<input type=hidden name=start_flag>");
  printf("<input type=hidden name=ifname value=%s>\n", &v6);
  v2 = sub_1466C(
         (int)"인터넷 연결 마법사를 시작합니다.",
         (int)"마법사를 실행할 방법을 선택하십시오.");
  str(v2);
  printf("<td height=190 class=\"wizardbody_td\">");
  puts("<input type=radio name=config value=auto checked>");
  printf("%s<br>\n", "자동으로 인터넷 연결을 검색하여 설정합니다.");
  puts("</span>");
  print_nbsp(10);
  printf("%s<br>\n", "인터넷 연결 방법을 자동으로 감지하여 설정합니다.");
  print_nbsp(10);
  printf("%s<br><br>\n", "동적IP(DHCP) 또는 PPPoE 방식을 감지할 수 있습니다.");
  puts("<input type=radio name=config value=manual>");
  printf("%s<br>\n", "수동으로 인터넷연결을 설정합니다.");
  print_nbsp(10);
  printf("%s<br>\n", "모든 인터넷 연결을 수동으로 설정하실 수 있습니다.");
  puts("</td></tr>");
  v3 = print_blank_line(1, 2);
  str(v3);
  printf("<td class=wizardbottom_td align=right>");
  printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(1);\">", "  다 음 >  ");
  v4 = printf("</td>");
  etr(v4);
  return puts("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11708: using guessed type int __fastcall wizard_api_set_status(_DWORD, _DWORD);

//----- (0004473C) --------------------------------------------------------
int __fastcall sub_4473C(int a1)
{
  int v1; // r4@1
  int result; // r0@3
  int v3; // r0@6
  int v4; // r1@6
  int v5; // r1@11
  const char *v6; // r0@12
  int v7; // r0@14
  int v8; // r0@17
  int v9; // r0@17
  int v10; // r0@19
  int v11; // r4@20
  int v12; // r0@21
  int v13; // r0@22
  int v14; // r0@22
  int v15; // r0@22
  const char *v16; // r0@23
  char *v17; // r1@28
  int v18; // r0@31
  int *v19; // r2@31
  char *v20; // r1@32
  const char *v21; // r0@34
  const char *v22; // r0@39
  const char *v23; // r1@39
  const char *v24; // r1@42
  const char *v25; // r0@44
  const char *v26; // r1@44
  const char *v27; // r0@47
  int v28; // r8@49
  int v29; // r0@53
  int v30; // r0@54
  int v31; // r0@54
  int v32; // r0@54
  int v33; // r0@54
  bool v34; // zf@67
  const char *v35; // r1@67
  const char *v36; // r0@70
  int v37; // r0@72
  int v38; // r0@72
  int v39; // r0@72
  int v40; // r0@72
  int v41; // r0@72
  const char *v42; // r0@72
  const char *v43; // r1@72
  const char *v44; // r0@75
  const char *v45; // r1@75
  int v46; // r0@77
  int v47; // r0@78
  const char *v48; // r0@78
  int v49; // r0@79
  int v50; // r0@80
  int v51; // r0@80
  int v52; // r0@80
  const char *v53; // r0@80
  const char *v54; // r1@80
  unsigned int v55; // r0@82
  char *v56; // r0@82
  int v57; // r0@82
  int v58; // r0@82
  int v59; // r0@82
  int v60; // r0@82
  int v61; // r0@82
  int v62; // r0@82
  int v63; // r0@82
  int v64; // r0@82
  int v65; // r0@83
  int v66; // r0@85
  int v67; // r0@85
  int v68; // r5@85
  int v69; // r0@85
  int v70; // r0@85
  int v71; // r0@85
  int v72; // r0@85
  int v73; // r0@85
  int v74; // r0@92
  char *v75; // r1@93
  char *v76; // r1@96
  char *v77; // r1@99
  int v78; // r0@101
  int v79; // r0@101
  int v80; // r0@102
  int v81; // r0@110
  char *v82; // r1@111
  char *v83; // r1@114
  int v84; // r0@116
  char *v85; // r1@117
  int v86; // r0@119
  char *v87; // r1@120
  int v88; // r0@122
  const char *v89; // r0@129
  int v90; // r0@138
  int v91; // r0@138
  int v92; // r0@138
  int v93; // r0@138
  int v94; // r0@138
  int v95; // r0@138
  int v96; // r0@138
  int v97; // r0@138
  int v98; // r0@138
  int v99; // r0@138
  int v100; // r0@140
  int v101; // r6@143
  int v102; // r0@144
  char *v103; // r0@147
  const char *v104; // r0@150
  char *v105; // r1@150
  int v106; // r0@159
  const char *v107; // r0@160
  char *v108; // r2@160
  const char *v109; // r1@160
  int v110; // r0@163
  int v111; // r0@166
  int v112; // r0@166
  int v113; // r7@167
  signed int v114; // r5@168
  const char *v115; // r0@171
  char *v116; // r2@171
  const char *v117; // r1@171
  int v118; // r0@185
  int v119; // r0@185
  char v120; // [sp+0h] [bp-468h]@46
  char v121; // [sp+80h] [bp-3E8h]@128
  char v122; // [sp+13Ch] [bp-32Ch]@53
  char v123; // [sp+1BCh] [bp-2ACh]@53
  char v124; // [sp+278h] [bp-1F0h]@22
  char dest; // [sp+2B8h] [bp-1B0h]@19
  char v126; // [sp+2F8h] [bp-170h]@11
  char v127; // [sp+338h] [bp-130h]@104
  char v128; // [sp+378h] [bp-F0h]@8
  char v129; // [sp+3B8h] [bp-B0h]@25
  char s1; // [sp+3D8h] [bp-90h]@11
  char v131; // [sp+3F8h] [bp-70h]@6
  int v132; // [sp+418h] [bp-50h]@1
  int v133; // [sp+438h] [bp-30h]@11

  v1 = a1;
  if ( get_value(a1, "step", &v132, 32) )
  {
    if ( !strcmp((const char *)&v132, "save") )
      return sub_147EC(v1);
    if ( !strcmp((const char *)&v132, "finish") )
      return sub_1472C(v1);
  }
  v3 = get_value(v1, "config", &v131, 32);
  if ( !v3 )
    return sub_445BC(v3, v4);
  if ( strcmp(&v131, "auto") )
  {
    result = strcmp(&v131, "manual");
    if ( result )
      return result;
    result = get_value(v1, "step", &v128, 64);
    if ( !result )
      return result;
    v3 = strcmp(&v128, "0");
    if ( v3 )
    {
      if ( !strcmp(&v128, "1") )
      {
        get_value(v1, "ifname", &v129, 16);
        eth2wan(&v129, &v126);
        set_wansetup_status(&v126, 1);
        if ( !get_value(v1, "wan_type", &v133, 16) )
          strcpy((char *)&v133, "dynamic");
        puts("<form method=get action=timepro.cgi name=wizard>");
        puts("<input type=hidden name=tmenu value=wizard>");
        puts("<input type=hidden name=config value=manual>");
        puts("<input type=hidden name=step>");
        printf("<input type=hidden name=ifname value=%s>\n", &v129);
        v74 = sub_1466C((int)"인터넷 연결방식 선택", 0);
        str(v74);
        puts("<td height=190 class=wizardbody_td>");
        if ( !strcmp((const char *)&v133, "dynamic") )
          v75 = "checked";
        else
          v75 = "";
        printf("<input type=radio name=wan_type value=dynamic %s>\n", v75);
        printf("<b>%s</b><br>\n", "동적으로 IP를 할당받는 방법(DHCP)");
        print_nbsp(10);
        printf("%s<br>\n", "FTTH,광랜,케이블모뎀,VDSL,IP ADSL,LAN방식등의 서비스에 적합합니다. ");
        print_nbsp(10);
        printf(
          "%s<br>\n",
          "이 방식은 DHCP 프로토콜을 이용하여 IP를 동적으로 할당받는 방법입니다.");
        if ( !strcmp((const char *)&v133, "pppoe") )
          v76 = "checked";
        else
          v76 = "";
        printf("<input type=radio name=wan_type value=pppoe %s>\n", v76);
        printf("<b>%s</b><br>\n", "사용자 계정과 암호를 필요로 하는 인터넷 연결(PPPoe)");
        puts("</span>");
        print_nbsp(10);
        printf("%s<br>\n", "ADSL모뎀(PPPoE지원) 사용시 적합한 방식입니다.");
        print_nbsp(10);
        printf("%s<br>\n", "이 방식은 PPPoE 프로토콜을 이용하여 인터넷에 연결합니다. ");
        print_nbsp(10);
        printf("%s<br>\n", "사용자 계정 및 암호는 인터넷 서비스 회사로부터 제공받습니다. ");
        if ( !strcmp((const char *)&v133, "static") )
          v77 = "checked";
        else
          v77 = "";
        printf("<input type=radio name=wan_type value=static %s>\n", v77);
        printf("<b>%s</b><br>\n", "고정 IP를 사용하는 인터넷에 연결(Static IP)");
        print_nbsp(10);
        printf(
          "%s<br>\n",
          "인터넷 서비스 제공업체로부터 할당받은 고정IP를 설정하는 방식입니다.");
        print_nbsp(10);
        printf("%s", "IP 주소,서브넷 마스크,게이트웨이,DNS 등의 주소를 직접 입력합니다.");
        v78 = printf("</td>");
        etr(v78);
        v79 = print_blank_line(1, 2);
        str(v79);
        puts("<td class=wizardbottom_td align=right>");
        printf(
          "<input type=button class=navi_bt name=prev value='%s' onclick=\"WizardGotoPage(0);\">",
          "  < 이 전   ");
        printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(2);\">", "  다 음 >  ");
        goto LABEL_102;
      }
      if ( !strcmp(&v128, "2") )
      {
        get_value(v1, "ifname", &v129, 16);
        puts("<form method=get action=timepro.cgi name=wizard>");
        puts("<input type=hidden name=tmenu value=wizard>");
        puts("<input type=hidden name=config value=manual>");
        puts("<input type=hidden name=step>");
        printf("<input type=hidden name=ifname value=%s>\n", &v129);
        if ( get_value(v1, "wan_type", &v127, 64) )
        {
          printf("<input type=hidden name=wan_type value=%s>\n", &v127);
          if ( !strcmp(&v127, "dynamic") )
          {
            get_value(v1, "ifname", &v126, 8);
            strcpy(&v124, "");
            strcpy(&dest, "");
            get_value(v1, "hw_conf", &v124, 20);
            if ( !get_value(v1, "private", &s1, 20) )
              strcpy(&s1, "on");
            if ( !v124 )
              strcpy(&v124, "auto");
            get_value(v1, "hw_addr", &dest, 20);
            v81 = sub_1466C((int)"동적으로 IP를 할당받는 방법(DHCP)", (int)"WAN포트의 MAC 주소 입력");
            str(v81);
            puts("<td height=190 class=wizardbody_td>");
            printf("WAN포트의 MAC 주소를 변경합니다.<br><br>");
            if ( !strcmp(&v124, "auto") )
              v82 = "checked";
            else
              v82 = "";
            printf(
              "<input type=radio name=hw_conf value=auto onclick=\"DisableHW('hw');\" %s> %s<br>",
              v82,
              "현재 접속 되어 있는 PC의 MAC 주소를 자동으로 입력");
            if ( !strcmp(&v124, "manual") )
              v83 = "checked";
            else
              v83 = "";
            printf(
              "<input type=radio name=hw_conf value=manual onclick=\"EnableHW('hw');\" %s> %s<br>",
              v83,
              "PC의 MAC 주소를 수동으로 입력");
            print_nbsp(8);
            v84 = sub_15664((int)"hw", &dest, 0);
            br(v84);
            print_nbsp(10);
            printf(
              "%s<br>\n",
              "공유기를 사용하지 않고 인터넷을 사용했던 PC의 MAC 주소를 입력합니다.");
            if ( !strcmp(&v124, "noclone") )
              v85 = "checked";
            else
              v85 = "";
            v86 = printf((const char *)&unk_7F2B0, v85, "MAC 주소를 변경하지 않음. ");
            br(v86);
            if ( !strcmp(&s1, "on") )
              v87 = "checked";
            else
              v87 = "";
            printf("<input type=checkbox name=private value=on %s> %s", v87, "사설 IP할당을 허용합니다.");
            v88 = printf("</td>");
            etr(v88);
            printf("<script>");
            if ( strcmp(&v124, "manual") )
              printf("DisableHW('hw');");
            printf("</script>");
            goto LABEL_140;
          }
          if ( !strcmp(&v127, "pppoe") )
          {
            get_value(v1, "ifname", &dest, 64);
            eth2wan(&dest, &v126);
            strcpy(&v122, "");
            strcpy(&v124, "");
            get_value(v1, "userid", &v122, 128);
            get_value(v1, "passwd", &v124, 64);
            if ( !v122 && !v124 )
            {
              read_pppoe_option(&v126, &v120);
              sf_strncpy(&v122, &v120, 128);
              sf_strncpy(&v124, &v121, 64);
            }
            sub_1466C(
              (int)"사용자 계정과 암호를 필요로 하는 인터넷 연결(PPPoe)",
              (int)"사용자 계정 및 암호 입력");
            puts((const char *)&unk_7DC8B);
            printf(
              (const char *)&unk_7F2FC,
              "사용자 계정 및 암호는 인터넷 서비스 제공 업체로부터 제공받습니다. ");
            printf("<table class=navicontent_table>");
            printf("<tr><td width=100>");
            printf("%s", "사용자 ID");
            printf("</td><td>");
            printf("<input type=text name=userid style=\"width:150;\" maxlength=63 value='%s'>", &v122);
            printf("</td></tr>");
            printf("<tr><td width=100>");
            printf("%s", "사용자 암호");
            printf("</td><td>");
            printf("<input type=password name=\"passwd\" style=\"width:150;\" maxlength=32 value='%s'>", &v124);
            printf("</td></tr>");
            printf("</table>");
            printf("사용자 계정 및 암호를 분실하였을 경우에는 인터넷 서비스 제공업체로 문의합니다<br>&nbsp;&nbsp;&nbsp;&nbsp;KT : 국번없이 100<br>&nbsp;&nbsp;&nbsp;&nbsp;하나로통신 : 국번없이 106<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(하나로 통신에서는 기본계정으로 사용자이름:hanaro@hanaro, 암호:1 을 제공하고있습니다<br>");
            v89 = "</td></tr>";
LABEL_139:
            puts(v89);
            goto LABEL_140;
          }
          if ( !strcmp(&v127, "static") )
          {
            get_value(v1, "ifname", &v133, 8);
            eth2wan(&v133, &v126);
            strcpy(&s1, "");
            strcpy(&dest, "");
            strcpy(&dest, "");
            strcpy(&v124, "");
            strcpy(&v122, "");
            strcpy(&v120, "");
            get_value(v1, "ip", &s1, 20);
            get_value(v1, "sm", &dest, 20);
            get_value(v1, "gw", &v124, 20);
            get_value(v1, "fdns", &v122, 20);
            get_value(v1, "sdns", &v120, 20);
            if ( !s1 && !dest && !v124 )
              get_wan_ipinfo(&v126, &s1, &dest, &v124);
            if ( !v122 && !v120 )
              get_domain_name_server(&v122, &v120);
            sub_1466C(
              (int)"고정 IP를 사용하는 인터넷에 연결(Static IP)",
              (int)"IP 주소, 서브넷마스크, 게이트웨이 , DNS 서버를 입력");
            puts((const char *)&unk_7DC8B);
            v90 = puts("<table>");
            str(v90);
            printf("<td>%s</td>", &unk_57D9D);
            puts("<td>");
            sub_157CC((int)"ip", &s1, 1);
            v91 = printf("</td>");
            v92 = etr(v91);
            str(v92);
            printf("<td>%s</td>", "서브넷 마스크");
            puts("<td>");
            sub_157CC((int)"sm", &dest, 1);
            v93 = puts("</td>");
            v94 = etr(v93);
            str(v94);
            printf("<td>%s</td>", "기본 게이트웨이");
            puts("<td>");
            sub_157CC((int)"gw", &v124, 1);
            v95 = puts("</td>");
            v96 = etr(v95);
            str(v96);
            printf("<td>%s</td>", "기본 DNS서버");
            puts("<td>");
            sub_157CC((int)"fdns", &v122, 1);
            v97 = puts("</td>");
            v98 = etr(v97);
            str(v98);
            printf("<td>%s</td>", "보조 DNS서버");
            puts("<td>");
            sub_157CC((int)"sdns", &v120, 1);
            v99 = puts("</td>");
            etr(v99);
            v89 = "</table></td></tr>";
            goto LABEL_139;
          }
        }
LABEL_140:
        v100 = print_blank_line(1, 2);
        str(v100);
        puts("<td class=wizardbottom_td align=right>");
        printf(
          "<input type=button class=navi_bt name=prev value='%s' onclick=\"WizardGotoPage(1);\">",
          "  < 이 전   ");
        v42 = "<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(3);\">";
        v43 = "  다 음 >  ";
LABEL_141:
        printf(v42, v43);
        v80 = puts("</td>");
        goto LABEL_142;
      }
      result = strcmp(&v128, "3");
      v101 = result;
      if ( result )
        return result;
      puts("<form method=get action=timepro.cgi name=wizard>");
      puts("<input type=hidden name=tmenu value=wizard>");
      puts("<input type=hidden name=config value=manual>");
      puts("<input type=hidden name=step>");
      puts("<input type=hidden name=commit>");
      puts("<input type=hidden name=nextstep>");
      get_value(v1, "ifname", &v129, 16);
      printf("<input type=hidden name=ifname value=%s>\n", &v129);
      v102 = sub_1466C((int)"인터넷 연결 설정 확인", v101);
      str(v102);
      puts("<td height=190 class=wizardbody_td>");
      printf("%s<br><br>\n", "설정 될 내용이 다음과 같습니다.");
      if ( get_value(v1, "wan_type", &v126, 32) )
        printf("<input type=hidden name=wan_type value=%s>\n", &v126);
      printf("<table class=wizard_content_table>");
      if ( strcmp(&v126, "dynamic") )
      {
        v113 = strcmp(&v126, "pppoe");
        if ( v113 )
        {
          if ( strcmp(&v126, "static") )
            goto LABEL_185;
          if ( get_ip_value(v1, "ip", &dest) )
            printf("<input type=hidden name=ip value=\"%s\">\n", &dest);
          if ( get_ip_value(v1, "sm", &v124) )
            printf("<input type=hidden name=sm value=\"%s\">\n", &v124);
          if ( get_ip_value(v1, "gw", &v122) )
            printf("<input type=hidden name=gw value=\"%s\">\n", &v122);
          if ( get_ip_value(v1, "fdns", &v120) )
            printf("<input type=hidden name=fdns value=\"%s\">\n", &v120);
          if ( get_ip_value(v1, "sdns", &s1) )
            printf("<input type=hidden name=sdns value=\"%s\">\n", &s1);
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "연결방식", "고정IP 방식");
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", &unk_57D9D, &dest);
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "서브넷 마스크", &v124);
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "기본 게이트웨이", &v122);
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "기본 DNS 서버", &v120);
          v115 = "<tr><td width=150px >%s</td><td><b>%s</b></td></tr>";
          v116 = &s1;
          v117 = "보조 DNS 서버";
        }
        else
        {
          get_value(v1, "userid", &v122, 128);
          printf("<input type=hidden name=userid value=\"%s\">\n", &v122);
          get_value(v1, "passwd", &dest, 64);
          printf("<input type=hidden name=passwd value=\"%s\">\n", &dest);
          printf(
            "<tr><td width=150px >%s</td><td><b>%s</b></td></tr>",
            "연결방식",
            "사용자계정 및 암호입력 방식(PPPoE)");
          printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "사용자 ID", &v122);
          v114 = strlen(&dest);
          strcpy(&v124, "");
          while ( v113 < v114 )
          {
            ++v113;
            strcat(&v124, "*");
          }
          v115 = "<tr><td width=150px >%s</td><td><b>%s</b></td></tr>";
          v116 = &v124;
          v117 = "사용자 암호";
        }
        printf(v115, v117, v116);
        goto LABEL_185;
      }
      strcpy(&v122, "");
      strcpy(&v124, "");
      strcpy(&dest, "");
      v103 = getenv("REMOTE_ADDR");
      get_internal_pc_hardware_address(v103, &v124);
      if ( get_value(v1, "hw_conf", &v120, 20) )
        printf("<input type=hidden name=hw_conf value=%s>\n", &v120);
      if ( get_hw_value(v1, "hw", &v122) )
      {
        v104 = "<input type=hidden name=hw_addr value=\"%s\">\n";
        v105 = &v122;
      }
      else
      {
        if ( strcmp(&v120, "auto") )
          goto LABEL_154;
        v104 = "<input type=hidden name=hw_addr value=\"%s\">\n";
        v105 = &v124;
      }
      printf(v104, v105);
LABEL_154:
      if ( get_value(v1, "private", &dest, 20) )
        printf("<input type=hidden name=private value=%s>\n", &dest);
      else
        puts("<input type=hidden name=private value=off>");
      printf("<tr><td width=150px >%s</td><td><b>%s</b></td></tr>", "연결방식", "동적IP 방식-DHCP사용");
      if ( v122 )
        convert_mac(&v122);
      v106 = convert_mac(&v124);
      str(v106);
      printf("<td>%s</td>", "WAN포트의 MAC 주소");
      if ( !strcmp(&v120, "auto") )
      {
        v107 = "<td>%s : %s</td>";
        v108 = &v124;
        v109 = (const char *)&unk_7F83C;
      }
      else
      {
        if ( strcmp(&v120, "manual") )
        {
          v110 = strcmp(&v120, "noclone");
          if ( !v110 )
            v110 = printf("<td>%s</td>", "변경하지 않음");
          goto LABEL_166;
        }
        v107 = "<td>%s : %s</td>";
        v108 = &v122;
        v109 = "수동으로 설정";
      }
      v110 = printf(v107, v109, v108);
LABEL_166:
      v111 = etr(v110);
      str(v111);
      strcmp(&dest, "on");
      v112 = printf((const char *)&unk_694FB, "사설IP할당");
      etr(v112);
LABEL_185:
      v118 = printf("</table>");
      br(v118);
      printf(
        "%s<br>\n",
        "현재의 인터넷 설정을 적용하려면 \"설정 저장 후 마법사 종료\" 버튼을 클릭합니다.");
      v119 = print_blank_line(1, 2);
      str(v119);
      puts("<td class=wizardbottom_td align=right>");
      printf("<input type=button class=navi_bt name=prev value='%s' onclick=\"WizardGotoPage(2);\">", "  < 이 전   ");
      v25 = "<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage('save');\">";
      v26 = "설정 저장 후 마법사 종료";
LABEL_186:
      printf(v25, v26);
      puts("</td></tr>");
      goto LABEL_187;
    }
    return sub_445BC(v3, v4);
  }
  result = get_value(v1, "step", &v128, 64);
  if ( !result )
    return result;
  v3 = strcmp(&v128, "0");
  if ( !v3 )
    return sub_445BC(v3, v4);
  if ( !strcmp(&v128, "1") )
  {
    get_value(v1, "ifname", &v126, 8);
    eth2wan(&v126, &v133);
    set_wansetup_status(&v133, 1);
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    printf("<input type=hidden name=ifname value=%s>\n", &v126);
    get_link_status((char *)&off_10000 + 1, &s1);
    v5 = strcmp(&s1, "On");
    if ( v5 )
    {
      v5 = 0;
      v6 = "WAN포트 연결 실패";
    }
    else
    {
      v6 = "WAN포트 연결 성공 - 모뎀 재시작";
    }
    v7 = sub_1466C((int)v6, v5);
    str(v7);
    puts("<td height=190 class=wizardbody_td>");
    if ( !strcmp(&s1, "On") )
    {
      puts("<input type=hidden name=start_flag value=1>");
      printf("WAN포트가 정상적으로 연결되어 있습니다.<br><br>FTTH,광랜등의 서비스처럼 벽에서 직접 인터넷선(랜선)이 나오는 경우는,<br>'다음' 버튼을 눌러 계속 진행합니다.<br><br>ADSL/VDSL/케이블모뎀 서비스방식일 경우는 모뎀의 전원을 껏다 켭니다.<br>일정 시간(최대 5분이내)이 지난 후, 모뎀의 Link/Sync/Online등의 LED의 상태를 확인합니다.<br>해당 LED가 정상적으로 켜져 있으면, '다음' 버튼을 눌러 계속 진행합니다.<br><br>* 해당 LED가 지속적으로 깜박거린다면, 인터넷 서비스 제공업체에 문의합니다.<br><br>");
    }
    else
    {
      printf(
        "%s",
        "WAN포트가 정상적으로 연결되어있지 않습니다.<br>외장형모뎀 또는 벽단자등에서 나"
        " 랜선과 WAN포트를 연결한 후<br> WAN포트의  LED의 상태를 확인합니다.<br><br>WAN포트가 "
        "상적으로 연결되면, '다음' 버튼을 눌러 마법사를 계속 진행할 수 있습니다.");
      printf(
        "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=1&ifname=%s\">",
        &v126);
    }
    v8 = printf("</td>");
    etr(v8);
    v9 = print_blank_line(1, 2);
    str(v9);
    puts("<td class=wizardbottom_td align=right>");
    printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(0);\">", "  < 이 전   ");
    strcmp(&s1, "On");
    printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(2);\" %s>", "  다 음 >  ");
LABEL_102:
    v80 = printf("</td>");
LABEL_142:
    etr(v80);
LABEL_187:
    v27 = "</form>";
    return puts(v27);
  }
  if ( !strcmp(&v128, "2") )
  {
    get_value(v1, "ifname", &v133, 8);
    eth2wan(&v133, &v126);
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    printf("<input type=hidden name=ifname value=%s>\n", &v133);
    sub_1466C((int)"인터넷 연결 검색 중", 0);
    v10 = get_value(v1, "start_flag", &dest, 64);
    if ( v10 )
    {
      v10 = strcmp(&dest, "1");
      v11 = v10;
      if ( !v10 )
      {
        wizard_api_set_mode(1);
        set_dhclient_block_private_ip(&v133);
        wizard_api_set_status(&v133, "detecting");
        set_default_gateway("br0", v11);
        set_default_gateway(&v133, v11);
        set_ifconfig(&v133, "0.0.0.0", "255.255.255.0");
        set_wan_type(&v126, "pppoe");
        set_pppoe_status(&v126, v11);
        pppoe_stop(&v126);
        v12 = dhclient_stop(&v126);
        v10 = signal_update(v12);
      }
    }
    etr(v10);
    puts("<td height=190 class=wizardbody_td>");
    printf("%s<br>", "인터넷 연결을 검색하고 있습니다.");
    printf("%s<br>", "검색을 마친 후에는 자동으로 검색 결과를 보여줍니다.");
    printf("%s<br><br>", "이 과정은 최대 2분까지 소요될 수 있습니다.");
    v13 = puts("</td>");
    etr(v13);
    v14 = print_blank_line(1, 2);
    str(v14);
    puts("<td class=wizardbottom_td align=right>");
    printf("<input type=button class=navi_bt name=prev value='%s' onclick=\"WizardGotoPage(1);\">", "  < 이 전   ");
    printf("<input type=button class=navi_bt name=next value='%s' disabled>", "  다 음 >  ");
    v15 = puts("</td>");
    etr(v15);
    puts("</form>");
    wizard_api_get_status(&v133, &v124);
    if ( !strcmp(&v124, "detecting") )
    {
      v16 = "<meta http-equiv=refresh content=\"5; URL=timepro.cgi?tmenu=wizard&config=auto&step=2&ifname=%s\">";
LABEL_28:
      v17 = (char *)&v133;
      return printf(v16, v17);
    }
    if ( !strcmp(&v124, "detected") )
    {
      get_wan_type(&v126, &v129);
      if ( !strcmp(&v129, "pppoe") )
        v16 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=3&ifname=%s\">";
      else
        v16 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=5&ifname=%s\">";
      goto LABEL_28;
    }
    result = strcmp(&v124, "timeout");
    if ( result )
      return result;
    v18 = istatus_get_intvalue_direct("lanwan_samenetwork");
    v19 = &v133;
    if ( v18 == 1 )
      v20 = (char *)7;
    else
      v20 = (char *)6;
    v21 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=%d&ifname=%s\">";
    return printf(v21, v20, v19);
  }
  if ( !strcmp(&v128, "3") )
  {
    get_value(v1, "ifname", &v129, 16);
    if ( !get_value(v1, "auth", &v133, 16) )
      strcpy((char *)&v133, "success");
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    printf("<input type=hidden name=ifname value=%s>\n", &v129);
    puts("<input type=hidden name=pppoe_start value=1>");
    if ( !strcmp((const char *)&v133, "fail") )
    {
      v22 = "사용자 계정 또는 암호 오류";
      v23 = "사용자 계정 및 암호 재입력";
    }
    else
    {
      v22 = "PPPoE 방식 검색됨";
      v23 = "사용자 계정 및 암호 입력";
    }
    sub_1466C((int)v22, (int)v23);
    puts((const char *)&unk_7DC8B);
    if ( !strcmp((const char *)&v133, "fail") )
      v24 = "사용자 계정 또는 암호가 일치하지 않습니다.";
    else
      v24 = "PPPoE를 사용하는 ADSL 방식의 인터넷 연결이 검색되었습니다.";
    printf("%s<br>", v24);
    printf(
      "%s<br>",
      "이 연결 방식은 인터넷 서비스 제공업체로부터 부여받은 사용자 계정 및 암호가 필요합니다.");
    printf("%s<br><br>", "사용자 계정 및 암호를 정확히 입력한 후 '다음' 버튼을 클릭합니다.");
    printf("<table class=navicontent_table >");
    printf("<tr><td width=100>");
    printf("%s", "사용자 ID");
    printf("</td><td>");
    printf("<input type=text name=\"userid\" style=\"width:150\" maxlength=63>");
    printf("</td></tr>");
    printf("<tr><td width=100>");
    printf("%s", "사용자 암호");
    printf("</td><td>");
    printf("<input type=password name=\"passwd\" style=\"width:150\" maxlength=32>");
    printf("</td></tr>");
    printf("</table>");
    printf("<span class=gray_text>사용자 계정 및 암호를 분실하였을 경우에는 인터넷 서비스 제공업체로 문의합니다<br>&nbsp;&nbsp;&nbsp;&nbsp;KT : 국번없이 100<br>&nbsp;&nbsp;&nbsp;&nbsp;하나로통신 : 국번없이 106<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(하나로 통신에서는 기본계정으로 사용자이름:hanaro@hanaro, 암호:1 을 제공하고있습니다<br></span>");
    print_blank_line(1, 2);
    puts((const char *)&unk_7E062);
    printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(1);\">", "  < 이 전   ");
    v25 = "<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(4);\">";
    v26 = "  다 음 >  ";
    goto LABEL_186;
  }
  if ( !strcmp(&v128, "4") )
  {
    if ( !get_value(v1, "ifname", &v120, 32) )
    {
      v27 = "Debug:auto_step4: No ifname..";
      return puts(v27);
    }
    eth2wan(&v120, &v133);
    if ( get_value(v1, "count", &s1, 32) )
      v28 = atoi(&s1);
    else
      v28 = 0;
    if ( get_value(v1, "pppoe_start", &s1, 32) && !strcmp(&s1, "1") )
    {
      read_pppoe_option(&v133, &v122);
      get_value(v1, "userid", &v122, 128);
      get_value(v1, "passwd", &v123, 128);
      set_default_gateway("br0", 0);
      set_default_gateway(&v120, 0);
      set_ifconfig(&v120, "0.0.0.0", "255.255.255.0");
      save_pppoe_option(&v133, &v122);
      v29 = pppoe_stop(&v133);
      signal_update(v29);
    }
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    printf("<input type=hidden name=ifname value=%s>\n", &v120);
    v30 = sub_1466C((int)"PPPoE 방식으로 인터넷 연결중", 0);
    str(v30);
    puts("<td height=190 class=\"wizardbody_td\">");
    printf("%s<br>\n", "입력된 사용자 계정 및 암호를 이용하여, 인터넷 연결을 시도합니다.");
    printf("%s<br>\n", "이 과정은 최대 30초까지 소요될 수 있습니다.");
    printf("%s<br>\n", "잠시만 기다리십시오.");
    v31 = print_blank_line(1, 2);
    str(v31);
    puts("<td class=wizardbottom_td align=right>");
    printf("<input type=button class=navi_bt name=next value='%s' onclick=\"WizardGotoPage(3);\">", "  < 이 전   ");
    printf("<input type=button class=navi_bt name=next value='%s' disabled>", "  다 음 >  ");
    v32 = puts("</td>");
    etr(v32);
    puts("</form>");
    v33 = get_pppoe_status(&v133);
    if ( v33 == 4 )
    {
      if ( check_wan_connected(&v133) )
      {
        v16 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=5&ifname=%s\">";
LABEL_63:
        v17 = &v120;
        return printf(v16, v17);
      }
    }
    else
    {
      if ( v33 == 6 )
      {
        v16 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=3&ifname=%s&auth=fail\">";
        goto LABEL_63;
      }
      if ( v33 == 7 )
      {
LABEL_62:
        v16 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=6&ifname=%s&timeout=pppoe\">";
        goto LABEL_63;
      }
    }
    v19 = (int *)(v28 + 1);
    if ( 3 * (v28 + 1) <= 30 )
    {
      v21 = "<meta http-equiv=refresh content=\"3; URL=timepro.cgi?tmenu=wizard&config=auto&step=4&ifname=%s&count=%d\">";
      v20 = &v120;
      return printf(v21, v20, v19);
    }
    goto LABEL_62;
  }
  if ( !strcmp(&v128, "5") )
  {
    wizard_api_set_mode(0);
    get_value(v1, "ifname", &v120, 32);
    eth2wan(&v120, &v129);
    get_wan_type(&v129, &v133);
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    puts("<input type=hidden name=nextstep value=finish>");
    v34 = strcmp((const char *)&v133, "pppoe") == 0;
    v35 = "동적IP(DHCP) 방식";
    if ( v34 )
      v35 = "PPPoE 방식";
    sub_1466C((int)"인터넷 연결 성공", (int)v35);
    puts((const char *)&unk_7E3AA);
    if ( !strcmp((const char *)&v133, "pppoe") )
      v36 = "PPPoE방식으로 인터넷에 연결되었습니다.";
    else
      v36 = "동적IP방식(DHCP)으로 인터넷에 연결되었습니다.";
    v37 = printf(v36);
    br(v37);
    v38 = printf("할당된 IP정보는 아래와 같습니다.");
    v39 = br(v38);
    br(v39);
    get_wan_ipinfo(&v129, &v126, &v122, &s1);
    get_domain_name_server(&dest, &v124);
    printf("<table class=wizard_content_table>");
    printf("<tr><td width=100px >%s</td><td>%s</td></tr>", &unk_57D9D, &v126);
    printf("<tr><td>%s</td><td>%s</td></tr>", "서브넷 마스크", &v122);
    printf("<tr><td>%s</td><td>%s</td></tr>", "기본 게이트웨이", &s1);
    printf("<tr><td>%s</td><td>%s</td></tr>", "기본 DNS 서버", &dest);
    printf("<tr><td>%s</td><td>%s</td></tr>", "보조 DNS 서버", &v124);
    v40 = printf("</table>");
    br(v40);
    printf("현재의 인터넷 설정을 적용하려면 \"설정 저장 후 마법사 종료\" 버튼을 클릭합니다.");
    v41 = print_blank_line(1, 2);
    str(v41);
    puts("<td class=\"wizardbottom_td\" align=right>");
    printf("<input type=button name=retry value='%s' onclick='WizardGotoPage(0);'>\n", "마법사 재실행");
    v42 = "<input type=button name=next value='%s' onclick=\"WizardGotoPage('save');\">\n";
    v43 = "설정 저장 후 마법사 종료";
    goto LABEL_141;
  }
  if ( !strcmp(&v128, "6") )
  {
    wizard_api_set_mode(0);
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    get_value(v1, "ifname", &v126, 8);
    printf("<input type=hidden name=ifname value=%s>\n", &v126);
    strcpy(&v120, "");
    get_value(v1, "timeout", &v120, 32);
    if ( !strcmp(&v120, "pppoe") )
    {
      v44 = "PPPoE 연결 실패";
      v45 = "PPPoE 연결시간 초과";
    }
    else
    {
      v44 = "인터넷 연결 검색 실패";
      v45 = "인터넷 연결 검색 시간 초과 ";
    }
    v46 = sub_1466C((int)v44, (int)v45);
    str(v46);
    puts("<td height=190 class=\"wizardbody_td\">");
    if ( !strcmp(&v120, "pppoe") )
    {
      v47 = printf("PPPoE 연결이 검색되었으나,PPPoE서버의 응답이 없어 마법사를 계속 진행할 수 없습니다.");
      br(v47);
      v48 = "ADSL 모뎀을 상태를 확인 후 마법사를 재실행 하십시오.";
    }
    else
    {
      v49 = printf("인터넷 연결 검색이 실패하였습니다.");
      br(v49);
      v48 = "WAN포트 연결상태, 모뎀상태등을 점검한 후, 마법사를 재실행 합니다.";
    }
    v50 = printf(v48);
    br(v50);
    v51 = printf("</td>");
    etr(v51);
    v52 = print_blank_line(1, 2);
    str(v52);
    puts("<td height=190 class=wizardbottom_td align=right>");
    printf("<input type=button name=retry value='%s' onclick='WizardGotoPage(0)'>\n", "마법사 재실행");
    v53 = "<input type=button name=exit value='%s' onclick='self.close();'>\n";
    v54 = " 마법사 종료 ";
    goto LABEL_83;
  }
  if ( !strcmp(&v128, "7") )
  {
    get_localbroadaddr("br0", &v124);
    v55 = inet_addr(&v124);
    v56 = inet_ntoa((struct in_addr)__rev(__rev(v55) + 2));
    strcpy(&dest, v56);
    wizard_api_set_mode(0);
    puts("<form method=get action=timepro.cgi name=wizard>");
    puts("<input type=hidden name=tmenu value=wizard>");
    puts("<input type=hidden name=smenu value=>");
    puts("<input type=hidden name=commit value=>");
    puts("<input type=hidden name=wizard value=1>");
    puts("<input type=hidden name=config value=auto>");
    puts("<input type=hidden name=step>");
    get_value(v1, "ifname", &v126, 8);
    printf("<input type=hidden name=ifname value=%s>\n", &v126);
    get_netaddr("br0", &v129);
    printf("<input type=hidden name=\"wan1subnet\" value=\"%s\">\n", &v129);
    strcpy(&v120, "");
    get_value(v1, "timeout", &v120, 32);
    sub_1466C((int)"동일 네트워크 검색 - 내부 IP변경", 0);
    v57 = get_ifconfig("br0", &s1, &v122);
    str(v57);
    puts("<td height=190 class=\"wizardbody_td\">");
    printf("내부 네트워크와 동일한 대역의 IP주소가 검출되었습니다.<br>");
    v58 = printf("올바른 인터넷 연결을 위해서는 내부 IP주소를 변경해야 합니다.<br>");
    br(v58);
    printf(
      "<input type=checkbox onclick=\"if(this.checked == true) SetIP('ip','%s'); else SetIP('ip','%s');\">",
      &dest,
      &s1);
    printf("자동으로 내부IP주소 변경하기<br>");
    v59 = puts("<table>");
    str(v59);
    printf("<td>%s</td>", "내부 IP주소");
    puts("<td>");
    sub_157CC((int)"ip", &s1, 1);
    v60 = printf("</td>");
    v61 = etr(v60);
    str(v61);
    printf("<td>%s</td>", "서브넷 마스크");
    puts("<td>");
    sub_157CC((int)"sm", &v122, 1);
    v62 = puts("</td>");
    etr(v62);
    printf("</table>");
    v63 = printf("</td>");
    etr(v63);
    v64 = print_blank_line(1, 2);
    str(v64);
    printf("<td class=wizardbottom_td align=right>");
    printf("<input type=button class=navi_bt name=prev value='%s' onclick=\"WizardGotoPage('2');\">", "  < 이 전   ");
    v53 = "<input type=button class=navi_bt name=next value='%s' onclick=\"document.wizard.step.value=8; CheckLanIPChange"
          "(document.wizard);\">";
    v54 = "  다 음 >  ";
LABEL_83:
    printf(v53, v54);
    v65 = printf("</td>");
    return etr(v65);
  }
  result = strcmp(&v128, "8");
  if ( !result )
  {
    v66 = sub_1466C((int)"시스템 재부팅", 0);
    str(v66);
    v67 = puts("<td height=190 class=\"wizardbody_td\">");
    v68 = hwinfo_get_reboot_duration(v67) + 30;
    get_value(v1, "ifname", &v129, 32);
    get_ip_value(v1, "ip", &dest);
    printf("내부 IP 주소가 변경되어 시스템이 재부팅되고 있습니다.<br>");
    printf("아래의 진행이 완료된 후, 변경된 IP로 재접속 후 마법사를 다시 실행하여 주십시오.<br>");
    printf("잠시만 기다리십시오.<br>");
    printf("<script>RunTimer('reboot_duration',%d,'self.close();');</script>", v68);
    v69 = printf("</td>");
    etr(v69);
    v70 = print_blank_line(1, 2);
    str(v70);
    printf("<td class=wizardbottom_td align=right>");
    v71 = print_html_progress_bar(v68);
    send_system_reboot_signal(v71);
    v72 = printf("</td>");
    etr(v72);
    v73 = syslog_msg(1, "관리자가 시스템을 재시작함");
    result = syslog_save(v73);
  }
  return result;
}
// 10000: using guessed type int *off_10000;
// 10058: using guessed type int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD);
// 10070: using guessed type int __fastcall get_link_status(_DWORD, _DWORD);
// 10088: using guessed type int __fastcall syslog_save(_DWORD);
// 10154: using guessed type int __fastcall set_dhclient_block_private_ip(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10340: using guessed type int __fastcall get_wan_type(_DWORD, _DWORD);
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10598: using guessed type int __fastcall hwinfo_get_reboot_duration(_DWORD);
// 105B0: using guessed type int __fastcall wizard_api_set_mode(_DWORD);
// 10688: using guessed type int __fastcall send_system_reboot_signal(_DWORD);
// 10868: using guessed type int __fastcall pppoe_stop(_DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 10958: using guessed type int __fastcall get_netaddr(_DWORD, _DWORD);
// 109E8: using guessed type int __fastcall dhclient_stop(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10BC8: using guessed type int __fastcall istatus_get_intvalue_direct(_DWORD);
// 10BEC: using guessed type int __fastcall get_wan_ipinfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 10DA8: using guessed type int __fastcall set_wan_type(_DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EC8: using guessed type int __fastcall set_pppoe_status(_DWORD, _DWORD);
// 10FD0: using guessed type int syslog_msg(_DWORD, const char *, ...);
// 110A8: using guessed type int __fastcall print_html_progress_bar(_DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11264: using guessed type int __fastcall get_localbroadaddr(_DWORD, _DWORD);
// 112D0: using guessed type int __fastcall read_pppoe_option(_DWORD, _DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 11534: using guessed type int __fastcall check_wan_connected(_DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 115DC: using guessed type int __fastcall get_domain_name_server(_DWORD, _DWORD);
// 116A8: using guessed type int __fastcall set_wansetup_status(_DWORD, _DWORD);
// 116B4: using guessed type int __fastcall eth2wan(_DWORD, _DWORD);
// 11708: using guessed type int __fastcall wizard_api_set_status(_DWORD, _DWORD);
// 117BC: using guessed type int __fastcall wizard_api_get_status(_DWORD, _DWORD);
// 11A08: using guessed type int __fastcall set_ifconfig(_DWORD, _DWORD, _DWORD);
// 11A74: using guessed type int __fastcall set_default_gateway(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11B40: using guessed type int __fastcall save_pppoe_option(_DWORD, _DWORD);
// 11BAC: using guessed type int __fastcall get_pppoe_status(_DWORD);

//----- (000467A0) --------------------------------------------------------
int __fastcall sub_467A0(int a1)
{
  int v1; // r5@1
  int result; // r0@1
  char *v3; // r0@8
  char *v4; // r1@8
  int v5; // r0@26
  char cp; // [sp+4h] [bp-1ECh]@15
  char v7; // [sp+84h] [bp-16Ch]@15
  char v8; // [sp+140h] [bp-B0h]@3
  char v9; // [sp+180h] [bp-70h]@1
  char dest; // [sp+1A0h] [bp-50h]@13
  char v11; // [sp+1B4h] [bp-3Ch]@6
  char v12; // [sp+1C8h] [bp-28h]@6
  char v13; // [sp+1DCh] [bp-14h]@10
  char v14; // [sp+1F0h] [bp+0h]@1
  char v15; // [sp+200h] [bp+10h]@1

  v1 = a1;
  get_value(a1, "ifname", &v15, 16);
  eth2wan(&v15, &v14);
  result = get_value(v1, "wan_type", &v9, 32);
  if ( result )
  {
    if ( strcmp(&v9, "dynamic") )
    {
      if ( !strcmp(&v9, "pppoe") )
      {
        read_pppoe_option(&v14, &cp);
        get_value(v1, "userid", &cp, 128);
        get_value(v1, "passwd", &v7, 128);
        save_pppoe_option(&v14, &cp);
      }
      else if ( !strcmp(&v9, "static") )
      {
        get_value(v1, "ip", &v13, 20);
        get_value(v1, "sm", &v12, 20);
        get_value(v1, "gw", &v11, 20);
        get_value(v1, "fdns", &dest, 20);
        get_value(v1, "sdns", &cp, 20);
        set_wan_ipconfig(&v15, &v13, &v12, &v11);
        set_ifconfig(&v15, &v13, &v12);
        if ( check_default_gateway(&v11, &v13, &v12) )
        {
          set_default_gateway("br0", 0);
          set_default_gateway(&v15, 0);
        }
        else
        {
          set_default_gateway("br0", 0);
          if ( set_default_gateway(&v15, &v11) )
            set_default_gateway2(&v15, &v13, &v12, &v11);
        }
        if ( inet_addr(&dest) == -1 )
          strcpy(&dest, "");
        if ( inet_addr(&cp) == -1 )
          strcpy(&cp, "");
        dhcpd_set_dns(&dest, &cp);
        set_domain_name_server(&dest, &cp, "eth0");
        set_dns_shadow(&v15, &v9, &dest, &cp);
      }
      goto LABEL_26;
    }
    if ( !get_value(v1, "hw_conf", &v8, 64) )
    {
LABEL_26:
      set_wan_type(&v14, &v9);
      pppoe_stop(&v14);
      v5 = dhclient_stop(&v14);
      return signal_update(v5);
    }
    if ( !strcmp(&v8, "auto") || !strcmp(&v8, "manual") )
    {
      get_hwaddr_kernel(&v15, &v12);
      get_value(v1, "hw_addr", &v11, 20);
      if ( !strcmp(&v11, &v12) || check_invalid_hwaddr(&v11) )
        goto LABEL_13;
      set_hwaddr_kernel(&v15, &v11, 1);
      v3 = &v15;
      v4 = &v11;
    }
    else
    {
      if ( strcmp(&v8, "noclone") )
        goto LABEL_13;
      get_hwaddr_org(&v15, &v13);
      get_hwaddr_kernel(&v15, &v12);
      if ( !strcmp(&v13, &v12) )
        goto LABEL_13;
      set_hwaddr_kernel(&v15, &v13, 1);
      v3 = &v15;
      v4 = &v13;
    }
    set_hwaddr_cloned(v3, v4);
LABEL_13:
    strcpy(&dest, "");
    get_value(v1, "private", &dest, 8);
    strcmp(&dest, "on");
    set_dhclient_block_private_ip(&v15);
    goto LABEL_26;
  }
  return result;
}
// 10154: using guessed type int __fastcall set_dhclient_block_private_ip(_DWORD);
// 1016C: using guessed type int __fastcall dhcpd_set_dns(_DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10448: using guessed type int __fastcall get_hwaddr_org(_DWORD, _DWORD);
// 104B4: using guessed type int __fastcall set_dns_shadow(_DWORD, _DWORD, _DWORD, _DWORD);
// 1064C: using guessed type int __fastcall set_hwaddr_cloned(_DWORD, _DWORD);
// 10868: using guessed type int __fastcall pppoe_stop(_DWORD);
// 109E8: using guessed type int __fastcall dhclient_stop(_DWORD);
// 10AFC: using guessed type int __fastcall check_invalid_hwaddr(_DWORD);
// 10B74: using guessed type int __fastcall set_default_gateway2(_DWORD, _DWORD, _DWORD, _DWORD);
// 10DA8: using guessed type int __fastcall set_wan_type(_DWORD, _DWORD);
// 11078: using guessed type int __fastcall set_hwaddr_kernel(_DWORD, _DWORD, _DWORD);
// 11114: using guessed type int __fastcall get_value(_DWORD, _DWORD, _DWORD, _DWORD);
// 112D0: using guessed type int __fastcall read_pppoe_option(_DWORD, _DWORD);
// 11678: using guessed type int __fastcall set_wan_ipconfig(_DWORD, _DWORD, _DWORD, _DWORD);
// 116B4: using guessed type int __fastcall eth2wan(_DWORD, _DWORD);
// 11A08: using guessed type int __fastcall set_ifconfig(_DWORD, _DWORD, _DWORD);
// 11A74: using guessed type int __fastcall set_default_gateway(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11B28: using guessed type int __fastcall check_default_gateway(_DWORD, _DWORD, _DWORD);
// 11B40: using guessed type int __fastcall save_pppoe_option(_DWORD, _DWORD);
// 11B7C: using guessed type int __fastcall set_domain_name_server(_DWORD, _DWORD, _DWORD);

//----- (00046BC4) --------------------------------------------------------
int __fastcall sub_46BC4(int a1)
{
  int v1; // r4@1

  v1 = a1;
  puts("<body bgcolor=#dedede style=\"margin-left:0; margin-right:0; margin-top:0px; margin-bottom:0;\" >");
  puts("<table width=550 height=290 class=wizardtable_td bgcolor=#ffffff >");
  sub_4473C(v1);
  printf("</table>");
  return puts("</body>");
}

//----- (00046C0C) --------------------------------------------------------
signed int __fastcall sub_46C0C(const char *a1)
{
  const char *v1; // r6@1
  size_t v2; // r4@1
  size_t v3; // r5@1

  v1 = a1;
  v2 = 0;
  v3 = strlen(a1);
  while ( 1 )
  {
    if ( v2 >= v3 )
      return 0;
    if ( strchr("&;|`\\><\"'`", v1[v2]) )
      break;
    ++v2;
  }
  return 1;
}

//----- (00046C58) --------------------------------------------------------
const char *__fastcall sub_46C58(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  int v3; // r6@2
  const char *v4; // r7@2
  int v5; // r0@6
  const char *v6; // r0@6
  int v7; // r0@7
  const char *v8; // r0@9
  const char *v9; // r7@9
  char *v10; // r0@11
  int v11; // r0@15
  int v12; // r7@15
  char *v13; // r0@17
  int v14; // r0@21
  int v15; // r7@21
  char *v16; // r0@23
  int v17; // r0@27
  int v18; // r4@27
  char *v19; // r0@29
  int v20; // r0@33
  int v21; // [sp+0h] [bp-218h]@4
  char v22; // [sp+100h] [bp-118h]@4

  v1 = a1;
  result = (const char *)get_pvalue(a1, "url_redir");
  if ( result )
  {
    v3 = atoi(result);
    result = (const char *)get_pvalue(v1, "url_redir_url");
    v4 = result;
    if ( result )
    {
      result = (const char *)sub_46C0C(result);
      if ( !result )
      {
        sf_strncpy(&v22, v4, 63);
        sf_strncpy(&v21, &v22, 63);
        strtoupper(&v21);
        result = strstr((const char *)&v21, "<SCRIPT>");
        if ( !result )
        {
          set_url_redirect_option(v3, &v22);
          result = (const char *)get_pvalue(v1, &unk_7FB64);
          if ( result )
          {
            v5 = atoi(result);
            set_url_redirect_autoconfirm(v5);
            v6 = (const char *)get_pvalue(v1, "cycle");
            if ( v6 )
              v7 = atoi(v6);
            else
              v7 = -1;
            set_url_redirect_cycle(v7);
            v8 = (const char *)get_pvalue(v1, "whitelist");
            v9 = v8;
            if ( v8 && !sub_46C0C(v8) )
            {
              sf_strncpy(&v22, v9, 128);
              sf_strncpy(&v21, &v22, 128);
              strtoupper(&v21);
              if ( !strstr((const char *)&v21, "<SCRIPT>") )
              {
LABEL_15:
                set_url_redirect_whitelist(&v22);
                v11 = get_pvalue(v1, "btnmsg");
                v12 = v11;
                if ( v11 && !check_unpermitted_chars(v11) )
                {
                  sf_strncpy(&v22, v12, 255);
                  sf_strncpy(&v21, &v22, 255);
                  strtoupper(&v21);
                  if ( !strstr((const char *)&v21, "<SCRIPT>") )
                  {
LABEL_21:
                    set_url_redirect_btnmsg(&v22);
                    v14 = get_pvalue(v1, "usermsg");
                    v15 = v14;
                    if ( v14 && !check_unpermitted_chars(v14) )
                    {
                      sf_strncpy(&v22, v15, 255);
                      sf_strncpy(&v21, &v22, 255);
                      strtoupper(&v21);
                      if ( !strstr((const char *)&v21, "<SCRIPT>") )
                      {
LABEL_27:
                        set_url_redirect_usermsg(&v22);
                        v17 = get_pvalue(v1, "usermsg2");
                        v18 = v17;
                        if ( v17 && !check_unpermitted_chars(v17) )
                        {
                          sf_strncpy(&v22, v18, 255);
                          sf_strncpy(&v21, &v22, 255);
                          strtoupper(&v21);
                          if ( !strstr((const char *)&v21, "<SCRIPT>") )
                            goto LABEL_33;
                          v19 = &v22;
                        }
                        else
                        {
                          v19 = &v22;
                        }
                        strcpy(v19, "");
LABEL_33:
                        v20 = set_url_redirect_usermsg2(&v22);
                        result = (const char *)clear_url_redirection(v20);
                        if ( v3 )
                          result = (const char *)init_url_redirection(0);
                        return result;
                      }
                      v16 = &v22;
                    }
                    else
                    {
                      v16 = &v22;
                    }
                    strcpy(v16, "");
                    goto LABEL_27;
                  }
                  v13 = &v22;
                }
                else
                {
                  v13 = &v22;
                }
                strcpy(v13, "");
                goto LABEL_21;
              }
              v10 = &v22;
            }
            else
            {
              v10 = &v22;
            }
            strcpy(v10, "");
            goto LABEL_15;
          }
        }
      }
    }
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10760: using guessed type int __fastcall clear_url_redirection(_DWORD);
// 107A8: using guessed type int __fastcall set_url_redirect_cycle(_DWORD);
// 107F0: using guessed type int __fastcall set_url_redirect_autoconfirm(_DWORD);
// 109DC: using guessed type int __fastcall init_url_redirection(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);
// 1106C: using guessed type int __fastcall set_url_redirect_btnmsg(_DWORD);
// 1121C: using guessed type int __fastcall set_url_redirect_usermsg(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 116FC: using guessed type int __fastcall set_url_redirect_usermsg2(_DWORD);
// 11894: using guessed type int __fastcall set_url_redirect_option(_DWORD, _DWORD);
// 11B64: using guessed type int __fastcall set_url_redirect_whitelist(_DWORD);

//----- (00046F64) --------------------------------------------------------
const char *__fastcall sub_46F64(int a1)
{
  int v1; // r4@1
  const char *result; // r0@1
  const char *v3; // r5@1
  int v4; // r0@6
  int v5; // r0@7
  const char *v6; // r6@8
  char s; // [sp+8h] [bp-98h]@6
  char v8; // [sp+48h] [bp-58h]@4
  char v9; // [sp+68h] [bp-38h]@3

  v1 = a1;
  result = (const char *)get_pvalue(a1, "act");
  v3 = result;
  if ( result )
  {
    if ( !strcmp(result, "add") )
    {
      result = (const char *)get_ip_value(v1, "free_sip", &v9);
      if ( result )
      {
        if ( !get_ip_value(v1, "free_eip", &v8) )
          strcpy(&v8, "0.0.0.0");
        snprintf(&s, 0x40u, "%s-%s", &v9, &v8);
        v4 = get_pvalue(v1, "dev_desc");
        result = (const char *)check_unpermitted_chars(v4);
        if ( !result )
        {
          v5 = add_url_redir_freedevice(&s);
          return (const char *)signal_save(v5);
        }
      }
    }
    else
    {
      result = (const char *)strcmp(v3, "del");
      v6 = result;
      if ( !result )
      {
        while ( 1 )
        {
          v5 = get_value_array(v1, "delchk", v6, &v9);
          if ( !v5 )
            break;
          if ( !check_unpermitted_chars(&v9) )
          {
            ++v6;
            remove_url_redir_freedevice(&v9);
          }
        }
        return (const char *)signal_save(v5);
      }
    }
  }
  return result;
}
// 103AC: using guessed type int __fastcall get_ip_value(_DWORD, _DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 111E0: using guessed type int __fastcall remove_url_redir_freedevice(_DWORD);
// 112A0: using guessed type int __fastcall add_url_redir_freedevice(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (000470B4) --------------------------------------------------------
int __fastcall sub_470B4(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r0@3
  int v4; // r0@5

  v1 = a1;
  v2 = (const char *)get_pvalue(a1, "act");
  if ( v2 )
  {
    if ( !strcmp(v2, "url_redir") )
      v3 = sub_46C58(v1);
    else
      v3 = sub_46F64(v1);
    v4 = signal_save(v3);
    signal_update(v4);
  }
  return 0;
}
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);

//----- (000478F4) --------------------------------------------------------
int __fastcall sub_478F4(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  int v3; // r0@5
  int v4; // r0@5
  const char *v5; // r0@6
  int v6; // r0@9
  const char *v7; // r0@12
  int v8; // r0@18
  const char *v9; // r0@20
  int v10; // r0@21
  const char *v11; // r0@22
  char *v12; // r0@24
  char *v13; // r4@24
  int v14; // r0@26
  char format; // [sp+8h] [bp-240h]@3
  char s; // [sp+108h] [bp-140h]@11
  char v18; // [sp+208h] [bp-40h]@5
  char v19; // [sp+21Ch] [bp-2Ch]@10

  v1 = a1;
  puts("<html>");
  puts("<script type=\"text/javascript\">");
  puts("<!--");
  puts("function detectmob()");
  puts("{");
  puts("\tif(navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i))");
  puts("\t\treturn true;");
  puts("\telse");
  puts("\t\treturn false;");
  puts("}");
  puts("//-->");
  puts("</script>");
  v2 = (const char *)get_pvalue(v1, &unk_8083F);
  if ( v2 && !strcmp(v2, "allow") )
  {
    printf("<table width=100%%><tr><td align=center>");
    printf("<span ID='str' style='color:#1e3269; font:normal normal bold 12px arial;'>");
    get_url_redirect_usermsg2(&format);
    if ( !format )
      sf_strncpy(&format, "※ 지금부터 인터넷을 사용하실 수 있습니다.", 256);
    printf(&format);
    printf("</span>");
    printf("</td></tr></table>");
    puts("<script type=\"text/javascript\">");
    puts("<!--");
    puts("if(detectmob())");
    puts("{");
    puts("\tdocument.getElementById('str').style.fontSize='26px';");
    puts("}");
    puts("//-->");
    v3 = puts("</script>");
    v4 = get_remote_addr(v3);
    sf_strncpy(&v18, v4, 20);
    if ( !strcmp(&v18, "Twin IP (WAN2)") )
    {
      v5 = "wan2";
    }
    else
    {
      if ( strncmp(&v18, "Twin IP", 7u) )
        goto LABEL_10;
      v5 = "wan1";
    }
    v6 = get_twinip_wan_virtual_ip(v5);
    sf_strncpy(&v18, v6, 20);
LABEL_10:
    if ( get_hwaddr_by_ip(&v18, &v19) )
    {
      snprintf(&s, 0x100u, "/sbin/iptables -t nat -D url_redir -m mac --mac-source %s -j RETURN", &v19);
      system(&s);
      snprintf(&s, 0x100u, "/sbin/iptables -t nat -I url_redir -m mac --mac-source %s -j RETURN", &v19);
      system(&s);
      snprintf(&s, 0x100u, (const char *)&unk_809D6, &v19);
      system(&s);
    }
    return puts("</html>");
  }
  v7 = (const char *)get_pvalue(v1, &unk_8083F);
  if ( v7 && !strcmp(v7, "frame2") )
  {
    puts("<form method=get action=urlredir.cgi name=misc_fm>");
    puts("<input type=hidden name=page value=url_redirect>");
    puts("<input type=hidden name=subpage value=allow>");
    printf("<table width=100%%><tr><td align=center>");
    printf("<span ID='str' style='color:#1e3269; font:normal normal bold 12px arial;'>");
    get_url_redirect_usermsg(&format);
    if ( !format )
      strcpy(&format, "※ 인터넷을 사용하실려면 확인 버튼을 눌러주세요.");
    printf(&format);
    get_url_redirect_btnmsg(&format);
    if ( !format )
      strcpy(&format, "확인합니다");
    printf("</span><br>");
    printf("<input ID='bt' type=submit value='%s'>\n", &format);
    printf("</td></tr></table>");
    puts("</form>");
    puts("<script type=\"text/javascript\">");
    puts("<!--");
    puts("if(detectmob())");
    puts("{");
    puts("\tdocument.getElementById('str').style.fontSize='26px';");
    puts("\tdocument.getElementById('bt').style.fontSize='30px';");
    v8 = puts("}");
    if ( get_url_redirect_autoconfirm(v8) )
      printf("document.misc_fm.submit()");
    puts("//-->");
    v9 = "</script>";
  }
  else
  {
    get_url_redirect_option(&s);
    puts("<head>");
    v10 = puts("</head>");
    if ( get_url_redirect_autoconfirm(v10) )
      v11 = "<frameset rows='100%%,0%%' frameborder=0>\n";
    else
      v11 = "<frameset rows='90%%,10%%' frameborder=0>\n";
    printf(v11);
    v12 = strrchr(&s, 63);
    v13 = v12;
    if ( v12 && !strcmp(v12 + 1, "tx2useri2firstpage") )
    {
      *v13 = 0;
      v14 = ((int (*)(void))get_remote_addr)();
      sf_strncpy(&v19, v14, 20);
      get_hwaddr_by_ip(&v19, &v18);
      get_hwaddr_kernel("br0", &format);
      printf("<frame src='%s?umac=%s&uip=%s&apmac=%s'>\n", &s, &v18, &v19, &format);
    }
    else
    {
      printf("<frame src='%s'>\n", &s);
    }
    puts("<frame src='urlredir.cgi?page=url_redirect&subpage=frame2'>");
    v9 = "</frameset>";
  }
  puts(v9);
  return puts("</html>");
}
// 10148: using guessed type int __fastcall get_remote_addr(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 103B8: using guessed type int __fastcall get_hwaddr_by_ip(_DWORD, _DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10478: using guessed type int __fastcall get_url_redirect_option(_DWORD);
// 104E4: using guessed type int __fastcall get_url_redirect_usermsg(_DWORD);
// 11048: using guessed type int __fastcall get_url_redirect_btnmsg(_DWORD);
// 113E4: using guessed type int __fastcall get_url_redirect_autoconfirm(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11528: using guessed type int __fastcall get_url_redirect_usermsg2(_DWORD);
// 115A0: using guessed type int __fastcall get_twinip_wan_virtual_ip(_DWORD);

//----- (00047DA8) --------------------------------------------------------
int sub_47DA8()
{
  int v0; // r5@1
  int v1; // r0@1
  int v2; // r0@1
  char *v3; // r1@2
  int v4; // r0@4
  int v5; // r0@4
  int v6; // r0@4
  int v7; // ST04_4@4
  int v8; // r0@4
  int v9; // r0@4
  char v11; // [sp+Ch] [bp-38Ch]@4

  v0 = get_iptv_config();
  puts("<form method=get action=\"timepro.cgi\" name=\"iptv_fm\">");
  puts("<input type=hidden name=\"tmenu\" value='expertconf'>");
  puts("<input type=hidden name=\"smenu\" value='iptv'>");
  puts("<input type=hidden name=\"act\" value=\"iptv\">");
  printf("<input type=hidden name=\"cur_op\" value=\"%d\">\n", v0);
  v1 = puts("<input type=hidden name=commit>");
  v2 = print_start_content_table(v1);
  str(v2);
  print_item_desc("IPTV 설정");
  puts("<td class=item_td colspan=5>");
  if ( v0 )
    v3 = "";
  else
    v3 = "checked";
  v4 = printf("<input type=radio name=\"mc_run\" onclick=\"CheckIPTVForm();\" value=0 %s>IPTV 사용안함", v3);
  br(v4);
  v5 = printf("<input type=radio name=\"mc_run\" onclick=\"CheckIPTVForm();\" value=%d %s>사설IP주소를 사용하는 IPTV (IGMP Proxy) - SKB, LGU+");
  br(v5);
  get_si("hw", &v11);
  printf("<input type=radio name=\"mc_run\" onclick=\"CheckIPTVForm();\" value=%d %s>공인IP주소를 사용하는 IPTV - KT&nbsp;<b>(지정포트: %d번)</b>");
  v6 = print_nbsp(5);
  v7 = get_igmp_proxy(v6) != 0;
  print_popup_button(
    &unk_80E9F,
    "mcgroupview",
    "width=500px,height=300px,scrollbars=yes,menubar=no,toolbar=no,resizable=no",
    "mcgroup_bt");
  printf("</td>");
  puts("<td class=item_td align=right width=43>");
  puts("<input class=navi_bt type=button name=\"mc_apply\" value=\"적용\" onclick=\"setIPTV();\">");
  v8 = printf("</td>");
  v9 = etr(v8);
  print_end_content_table(v9);
  printf("</form>");
  return printf("<script> CheckIPTVForm(); </script>");
}
// 10124: using guessed type int __fastcall get_si(_DWORD, _DWORD);
// 102B0: using guessed type int get_iptv_config(void);
// 10844: using guessed type int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 111C8: using guessed type int __fastcall get_igmp_proxy(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00047F4C) --------------------------------------------------------
const char *__fastcall sub_47F4C(int a1)
{
  const char *result; // r0@1
  int v2; // r0@2
  int v3; // r0@2

  result = (const char *)get_pvalue(a1, "mc_run");
  if ( result )
  {
    v2 = atoi(result);
    v3 = set_iptv_config(v2);
    result = (const char *)saveconf(v3);
  }
  return result;
}
// 104CC: using guessed type int __fastcall set_iptv_config(_DWORD);
// 10BF8: using guessed type int __fastcall saveconf(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00047F74) --------------------------------------------------------
int sub_47F74()
{
  int v0; // r0@1
  FILE *v1; // r0@1
  FILE *v2; // r7@1
  char *v3; // r0@3
  const char *v4; // r8@4
  int v5; // r0@4
  char v6; // r9@4
  char *v7; // r0@5
  int v8; // r10@6
  char *v9; // r0@6
  int v10; // r0@7
  char *v11; // r0@8
  const char *v12; // r10@9
  char *v13; // r0@9
  int v14; // r9@10
  char *v15; // r0@10
  int v16; // r0@11
  const char *v17; // r1@12
  int v18; // r0@19
  int v19; // r0@19
  char v21; // [sp+8h] [bp-A0h]@3

  printf("<form method=get action=\"timepro.cgi\" name=\"mcgroup_list_fm\">");
  printf("<input type=hidden name=\"tmenu\" value=\"popup\">");
  printf("<input type=hidden name=\"smenu\" value=\"mcgroup_list\">");
  print_sub_title("그룹 리스트", 0);
  v0 = printf("<br>");
  print_start_content_table(v0);
  print_item_desc("그룹 IP (MAC) 주소");
  print_item_desc("멤버 IP 주소");
  print_item_desc("포트");
  print_item_desc("상태");
  v1 = fopen("/var/run/mcgroup", "r");
  v2 = v1;
  if ( v1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          v1 = (FILE *)fgets(&v21, 128, v2);
          if ( !v1 )
            goto LABEL_19;
          v3 = strchr(&v21, 32);
        }
        while ( !v3 );
        *v3 = 0;
        v4 = v3 + 1;
        v5 = strcmp(&v21, "G");
        v6 = v5;
        if ( v5 )
          break;
        v7 = strchr(v4, 32);
        if ( v7 )
        {
          *v7 = v6;
          v8 = (int)(v7 + 1);
          v9 = strchr(v7 + 1, 32);
          if ( v9 )
          {
            *v9 = v6;
            str(v9);
            v10 = printf("<td class=item_td colspan=4> %s (%s)</td>\n", v4, v8);
            goto LABEL_17;
          }
        }
      }
      v11 = strchr(v4, 32);
      if ( v11 )
      {
        *v11 = 0;
        v12 = v11 + 1;
        v13 = strchr(v11 + 1, 32);
        if ( v13 )
        {
          *v13 = 0;
          v14 = (int)(v13 + 1);
          v15 = strchr(v13 + 1, 10);
          if ( v15 )
          {
            *v15 = 0;
            str(v15);
            puts("<td class=item_td></td>");
            printf("<td class=item_td>%s</td>\n", v4);
            v16 = atoi(v12);
            if ( v16 >= 0 )
            {
              if ( v16 > 31 )
                v17 = "무선";
              else
                v17 = v12;
            }
            else
            {
              v17 = "N.A.";
            }
            printf("<td class=item_td>%s</td>\n", v17);
            v10 = printf("<td class=item_td>%s</td>\n", v14);
LABEL_17:
            etr(v10);
          }
        }
      }
    }
  }
LABEL_19:
  str(v1);
  puts("<td class=item_td align=center colspan=4>");
  printf(
    "<input type=button class=\"navi_bt\" name=refresh_bt value=\"%s\" onclick=\"document.forms[0].submit();\");\">",
    "갱신");
  print_nbsp(5);
  printf("<input type=button class=\"navi_bt\" name=close_bt value=\"%s\" onclick=\"self.close();\");\">", "닫기");
  v18 = printf("</td>");
  v19 = etr(v18);
  print_end_content_table(v19);
  return printf("</form>");
}
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);

//----- (00048278) --------------------------------------------------------
signed int __fastcall sub_48278(int a1, int a2)
{
  int v2; // r6@1
  int i; // r4@1
  signed int v4; // r1@5
  const char *v5; // r0@8
  const char *v6; // r0@10
  int v7; // r2@10
  const char *v8; // r1@10
  const char *v9; // r3@16
  const char *v10; // r0@22
  char *v11; // r1@22
  const char *v12; // r0@37
  const char *v13; // r1@37
  int v15; // [sp+0h] [bp-30h]@10
  int v16; // [sp+4h] [bp-2Ch]@0
  int v17; // [sp+Ch] [bp-24h]@20

  v2 = a2;
  for ( i = a1; ; i = *(_DWORD *)i )
  {
    if ( !i )
      return 0;
    if ( strcmp((const char *)(i + 368), "09") && v2 == *(_DWORD *)(i + 4) )
      break;
  }
  printf("<tr><td class=item_td>");
  if ( *(_DWORD *)(i + 4) == 1 )
    v4 = 3;
  else
    v4 = 2;
  printf("<img src=/images2/usb%d0.png> ", v4);
  printf(
    "<span style=\"font: normal normal normal 9pt arial; color:#000000\">%s%d</span>",
    "USB포트",
    *(_DWORD *)(i + 4));
  printf("</td>");
  printf("<td style=\"height:20px; padding: 5px 10px 5px 10px; background-color:#FFFFFF; border-collapse:collapse; border-style:solid none solid none; border-width:1 1 1 1;  border-color:#EFEBDE\" align=left>");
  if ( !strcmp((const char *)(i + 368), "08") )
  {
    v5 = "저장장치";
LABEL_13:
    printf(v5);
    goto LABEL_19;
  }
  if ( !strcmp((const char *)(i + 368), "02") )
  {
    printf("USB테더링장치");
    v6 = "<br>%s : %s<br>%s : %s<br>";
    v15 = i + 152;
    v7 = i + 24;
    v8 = "제조사";
  }
  else
  {
    if ( !strcmp((const char *)(i + 368), "07") )
    {
      v5 = "USB프린터";
      goto LABEL_13;
    }
    if ( !get_ifexist("usb0") )
    {
      printf("USB기타장치");
      v6 = "<br>%s<br>%s<br>(%s:%s:%s)";
      v15 = i + 16;
      v16 = i + 8;
      v8 = (const char *)(i + 24);
      v7 = i + 152;
      v9 = (const char *)(i + 368);
      goto LABEL_18;
    }
    printf("USB테더링장치");
    v6 = "<br>%s : %s<br>%s : %s<br>";
    v7 = i + 24;
    v8 = "제조사";
    v15 = i + 152;
  }
  v9 = "제품명";
LABEL_18:
  printf(v6, v8, v7, v9, v15, v16);
LABEL_19:
  printf("</td>");
  printf("<td class=item_td align=left>");
  if ( strcmp((const char *)(i + 368), "08") )
  {
    if ( !strcmp((const char *)(i + 368), "02")
      || !strcmp((const char *)(i + 368), "e0")
      || !strcmp((const char *)(i + 368), "0a") )
    {
      if ( tethering_is_running() )
      {
        v10 = "%s";
        v11 = "USB테더링사용중";
        goto LABEL_35;
      }
      if ( get_usb_tethering_op() && get_ifexist("usb0") )
      {
        v10 = "%s";
        v11 = "WAN포트제거 후 사용가능";
        goto LABEL_35;
      }
LABEL_34:
      v10 = "%s";
      v11 = "사용하지않음";
      goto LABEL_35;
    }
    if ( strcmp((const char *)(i + 368), "07") || get_cupsd_printer_status(0) )
      goto LABEL_34;
LABEL_33:
    v10 = "%s";
    v11 = "사용중";
    goto LABEL_35;
  }
  get_mount_list(&v17, i + 372);
  if ( v17 )
    goto LABEL_33;
  if ( !is_usb_removed(i + 372) )
    goto LABEL_34;
  v10 = "%s";
  v11 = "제거됨";
LABEL_35:
  printf(v10, v11);
  printf("</td>");
  printf("<td class=item_td align=left>");
  if ( !strcmp((const char *)(i + 368), "08") )
  {
    if ( v17 )
    {
      v12 = "<input type=button name=remove_bt value=\"%s\" onclick=\"RemoveUSB('%s');\">";
      v13 = "장치 제거";
    }
    else
    {
      v12 = "<input type=button name=mount_bt value=\"%s\" onclick=\"MountUSB('%s');\">";
      v13 = "장치 사용";
    }
    printf(v12, v13, i + 372);
    free_mount_list(&v17);
  }
  printf("</td></tr>");
  return 1;
}
// 102A4: using guessed type int __fastcall free_mount_list(_DWORD);
// 10CD0: using guessed type int __fastcall get_cupsd_printer_status(_DWORD);
// 10D6C: using guessed type int __fastcall is_usb_removed(_DWORD);
// 11504: using guessed type int __fastcall get_ifexist(_DWORD);
// 11594: using guessed type int __fastcall get_mount_list(_DWORD, _DWORD);
// 1175C: using guessed type int get_usb_tethering_op(void);
// 117F8: using guessed type int tethering_is_running(void);

//----- (000485C4) --------------------------------------------------------
int __fastcall sub_485C4(int a1)
{
  int v1; // r4@1
  const char *v2; // r0@1
  const char *v3; // r5@1
  int v4; // r0@3
  int v5; // r4@3
  int v6; // r6@4
  int v7; // r0@11
  int v8; // r5@11
  int v9; // r6@12
  int v11; // [sp+0h] [bp-90h]@5

  v1 = a1;
  printf("<html>");
  puts("<form method=get action=timepro.cgi name=usbapply_fm>");
  puts("<input type=hidden name=tmenu value=iframe_usb_apply>");
  puts("<input type=hidden name=act value=>");
  puts("<input type=hidden name=devname value=>");
  printf("</form>");
  v2 = (const char *)get_pvalue(v1, "act");
  v3 = v2;
  if ( v2 )
  {
    if ( !strcmp(v2, "remove") )
    {
      v4 = get_pvalue(v1, "devname");
      v5 = v4;
      if ( v4 )
      {
        v6 = check_unpermitted_chars(v4);
        if ( !v6 )
        {
          set_device_removed(v5, 1);
          snprintf((char *)&v11, 0x80u, "umount:%s", v5);
          signal_nas(&v11);
          while ( get_num_of_mountdev(v5) && v6 != 30 )
          {
            ++v6;
            sleep(1u);
          }
          goto LABEL_19;
        }
      }
    }
    else
    {
      if ( strcmp(v3, "mount") )
      {
LABEL_19:
        puts("<script>");
        printf("parent.location.href='timepro.cgi?tmenu=nasconf&smenu=basic';");
        puts("</script>");
        return printf("</html>");
      }
      v7 = get_pvalue(v1, "devname");
      v8 = v7;
      if ( v7 )
      {
        v9 = check_unpermitted_chars(v7);
        if ( !v9 )
        {
          snprintf((char *)&v11, 0x80u, "mount:%s", v8);
          signal_nas(&v11);
          while ( !get_num_of_mountdev(v8) && v9 != 30 )
          {
            ++v9;
            sleep(1u);
          }
          goto LABEL_19;
        }
      }
    }
  }
  return printf("</html>");
}
// 1049C: using guessed type int __fastcall signal_nas(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10FAC: using guessed type int __fastcall set_device_removed(_DWORD, _DWORD);
// 11384: using guessed type int __fastcall get_num_of_mountdev(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);

//----- (00048788) --------------------------------------------------------
char *__fastcall sub_48788(int a1, const char *a2)
{
  int v2; // r5@1
  const char *v3; // r4@1

  v2 = a1;
  v3 = a2;
  if ( !strcmp(a2, "fuseblk") )
  {
    if ( !get_fuse_fsname(v2, byte_917DC) )
      strcpy(byte_917DC, "마운팅중...");
  }
  else
  {
    sf_strncpy(byte_917DC, v3, 128);
    if ( !strcmp(byte_917DC, "tntfs") )
      strcpy(byte_917DC, "ntfs");
    strtoupper(byte_917DC);
  }
  return byte_917DC;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10C64: using guessed type int __fastcall get_fuse_fsname(_DWORD, _DWORD);
// 10F10: using guessed type int __fastcall strtoupper(_DWORD);

//----- (00048820) --------------------------------------------------------
int __fastcall sub_48820(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r6@5
  int v4; // r5@5
  signed int v5; // r1@6
  int i; // r4@9
  int v7; // r0@11
  int v8; // r0@11
  char *v9; // r0@11
  char v11; // [sp+4h] [bp-16Ch]@9
  char v12; // [sp+104h] [bp-6Ch]@11
  char v13; // [sp+124h] [bp-4Ch]@11
  int v14; // [sp+144h] [bp-2Ch]@1
  int v15; // [sp+148h] [bp-28h]@9

  v2 = a1;
  v14 = 0;
  while ( v2 )
  {
    if ( a2 == *(_DWORD *)(v2 + 4) )
    {
      get_mount_list(&v14, v2 + 372);
      if ( v14 )
      {
        v3 = 0;
        printf("<tr>");
        v4 = 0;
        printf("<td class=item_td align=left rowspan=%d>", v14 + 1);
        if ( *(_DWORD *)(v2 + 4) == 1 )
          v5 = 3;
        else
          v5 = 2;
        printf((const char *)&unk_815D2, v5);
        printf(
          "<span style=\"font: normal normal normal 9pt arial; color:#000000\">%s%d</span>",
          "USB포트",
          *(_DWORD *)(v2 + 4));
        printf("</td>");
        printf("</tr>");
        do
        {
          sprintf(&v11, "HDD%d", ++v4);
          for ( i = v15; i; i = *(_DWORD *)i )
          {
            if ( !strcmp((const char *)(i + 100), &v11) )
            {
              ++v3;
              v7 = get_readable_sizestr(*(_QWORD *)(i + 216), *(_QWORD *)(i + 216) >> 32);
              sf_strncpy(&v13, v7, 32);
              v8 = get_readable_sizestr(*(_QWORD *)(i + 232), *(_QWORD *)(i + 232) >> 32);
              sf_strncpy(&v12, v8, 32);
              printf("<tr>");
              printf("<td class=item_td align=left>/%s</td>", i + 100);
              v9 = sub_48788(i + 20, (const char *)(i + 164));
              printf("<td class=item_td align=left>%s</td>", v9);
              printf("<td class=item_td align=left>%s</td>", &v13);
              printf("<td class=item_td align=left>%s</td>", &v12);
              printf("</tr>");
            }
          }
        }
        while ( v3 != v14 && v4 != 128 );
      }
      free_mount_list(&v14);
      return v14;
    }
    v2 = *(_DWORD *)v2;
  }
  return v14;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 102A4: using guessed type int __fastcall free_mount_list(_DWORD);
// 110E4: using guessed type int __fastcall get_readable_sizestr(_DWORD, _DWORD);
// 11594: using guessed type int __fastcall get_mount_list(_DWORD, _DWORD);

//----- (00048C10) --------------------------------------------------------
int __fastcall sub_48C10(int result, const char *a2, int a3)
{
  const char *v3; // r7@1
  int v4; // r6@1
  int i; // r4@1
  int j; // r8@2
  int v7; // r0@10
  int v8; // [sp+0h] [bp-A0h]@2

  v3 = a2;
  v4 = a3;
  for ( i = result; i; i = *(_DWORD *)i )
  {
    result = conv_time(*(_DWORD *)(i + 176), &v8, 1);
    for ( j = *(_DWORD *)(i + 216); j; j = *(_DWORD *)j )
    {
      result = strcmp((const char *)(i + 12), v3);
      if ( !result )
      {
        result = strcmp((const char *)(j + 20), "0.0.0.0");
        if ( result )
        {
          result = strcmp((const char *)(j + 20), "127.0.0.1");
          if ( result )
          {
            str(result);
            printf("<td class=item_td> %s </td>", v4);
            printf("<td class=item_td> ");
            if ( !strcmp((const char *)(i + 44), "root") || !strcmp((const char *)(i + 44), "nobody") )
              putchar(45);
            else
              printf("%s", i + 44);
            printf("</td>");
            printf("<td class=item_td> %s </td>", j + 20);
            v7 = printf("<td class=item_td> %s </td>", &v8);
            result = etr(v7);
            break;
          }
        }
      }
    }
  }
  return result;
}
// 10A24: using guessed type int __fastcall conv_time(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);

//----- (00048D4C) --------------------------------------------------------
int __fastcall sub_48D4C(int result, const char *a2, int a3)
{
  const char *v3; // r7@1
  int v4; // r6@1
  int i; // r4@1
  signed int v6; // r8@2
  int j; // r10@3
  int v8; // r0@10
  int v9; // [sp+0h] [bp-A8h]@3

  v3 = a2;
  v4 = a3;
  for ( i = result; i; i = *(_DWORD *)i )
  {
    result = strcmp((const char *)(i + 12), v3);
    v6 = result;
    if ( !result )
    {
      result = conv_time(*(_DWORD *)(i + 176), &v9, 1);
      for ( j = *(_DWORD *)(i + 216); j; j = *(_DWORD *)j )
      {
        result = strcmp((const char *)(j + 20), "0.0.0.0");
        if ( result )
        {
          result = strcmp((const char *)(j + 20), "127.0.0.1");
          if ( result )
          {
            str(result);
            printf("<td class=item_td> %s </td>", v4);
            printf("<td class=item_td> ");
            if ( !strcmp((const char *)(i + 44), "root") || !strcmp((const char *)(i + 44), "nobody") )
              putchar(45);
            else
              printf("%s", i + 44);
            v6 = 1;
            printf("</td>");
            printf("<td class=item_td> %s </td>", j + 20);
            v8 = printf("<td class=item_td> %s </td>", &v9);
            result = etr(v8);
          }
        }
      }
      if ( v6 )
        break;
    }
  }
  return result;
}
// 10A24: using guessed type int __fastcall conv_time(_DWORD, _DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);

//----- (00049034) --------------------------------------------------------
int __fastcall sub_49034(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r6@1

  v3 = a3;
  v4 = a1;
  v5 = a2;
  printf("<TR height=20 ID=%s STYLE=\"cursor:pointer; background-Color:#%s\" ONCLICK=\"ClickNasService(this);\">", a1);
  return printf("<TD></TD><TD>%s</TD><TD CLASS=text_gray ID=%s_value>%s</TD><TD>%s</TD></TR>", v5, v4, v3);
}

//----- (00049094) --------------------------------------------------------
int __fastcall dir_filter(int a1)
{
  int v1; // r3@1
  bool v2; // zf@1
  int result; // r0@4

  v1 = *(_BYTE *)(a1 + 10);
  v2 = v1 == 4;
  if ( v1 != 4 )
    v2 = v1 == 0;
  if ( v2 )
  {
    if ( v1 == 10 )
    {
      result = 0;
    }
    else if ( *(_BYTE *)(a1 + 11) == 46 )
    {
      result = 0;
    }
    else
    {
      result = strcmp((const char *)(a1 + 11), "lost+found") != 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (000490F0) --------------------------------------------------------
int __fastcall sub_490F0(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1

  v2 = a1;
  v3 = a2;
  puts("<script>");
  printf("if(parent.document.getElementById('%s'))", v2);
  printf("parent.document.getElementById('%s').innerHTML = '%s';", v2, v3);
  printf("if(parent.parent.document.getElementById('%s'))", v2);
  printf((const char *)&unk_7BDC2, v2, v3);
  return puts("</script>");
}

//----- (00049160) --------------------------------------------------------
signed int __fastcall sub_49160(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  int v4; // r6@1
  signed int v5; // r4@3
  void *v6; // r0@4
  char *v7; // r0@4
  const char *v8; // r2@4
  const char *v9; // r3@4
  void *v10; // r0@6
  int v11; // r0@6
  int v13; // [sp+0h] [bp-290h]@3
  char s; // [sp+200h] [bp-90h]@9

  v2 = a1;
  v3 = a2;
  v4 = get_service_enable(a2);
  if ( !check_nas_service(v2, v3) )
  {
    if ( !v4 )
    {
      v5 = 0;
      snprintf((char *)&v13, 0x80u, "%s", "중단됨");
      goto LABEL_9;
    }
    v10 = sub_16094();
    v11 = snprintf((char *)&v13, 0x80u, (const char *)&unk_81C49, v10);
    v8 = "%s";
    v7 = (char *)&v13 + v11;
    v9 = "시작중";
    goto LABEL_7;
  }
  if ( !v4 )
  {
    v6 = sub_16094();
    v7 = (char *)&v13 + snprintf((char *)&v13, 0x80u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\">", v6);
    v8 = " %s";
    v9 = "중단중";
LABEL_7:
    snprintf(v7, 0x80u, v8, v9);
    v5 = 1;
    goto LABEL_9;
  }
  v5 = 0;
  snprintf((char *)&v13, 0x80u, "%s", "동작중");
LABEL_9:
  snprintf(&s, 0x80u, "%s_status", v3);
  sub_490F0((int)&s, (int)&v13);
  return v5;
}
// 10AD8: using guessed type int __fastcall check_nas_service(_DWORD, _DWORD);
// 10C10: using guessed type int __fastcall get_service_enable(_DWORD);

//----- (000492E8) --------------------------------------------------------
char *__fastcall sub_492E8(const char *a1)
{
  const char *v1; // r5@1
  char *v2; // r4@1
  int v3; // r0@2
  int v5; // r6@4
  FILE *v6; // r5@4

  v1 = a1;
  v2 = (char *)file_exists(a1);
  if ( v2 )
  {
    v3 = get_filesize(v1);
    if ( !v3 )
      return strdup("");
    v5 = v3 + 4;
    v2 = (char *)malloc(v3 + 4);
    strcpy(v2, "");
    v6 = fopen(v1, "r");
    if ( v6 )
    {
      fgets(v2, v5, v6);
      fclose(v6);
    }
    else
    {
      v2 = 0;
    }
  }
  return v2;
}
// 10C94: using guessed type int __fastcall get_filesize(_DWORD);
// 115C4: using guessed type int __fastcall file_exists(_DWORD);

//----- (00049370) --------------------------------------------------------
void *sub_49370()
{
  void *v0; // r0@3
  char *v1; // r1@3
  int v3; // [sp+0h] [bp-530h]@2
  char v4; // [sp+24h] [bp-50Ch]@3
  char v5; // [sp+500h] [bp-30h]@1

  if ( !get_wan_ip("wan1", &v5) )
  {
    get_ifconfig("br0", &v5, 0);
LABEL_6:
    v0 = &unk_9185C;
    v1 = &v5;
    goto LABEL_7;
  }
  if ( !ddnsapi_read_config_by_service_type(0, "ipdisk_router", &v3) )
    goto LABEL_6;
  v0 = &unk_9185C;
  v1 = &v4;
LABEL_7:
  sf_strncpy(v0, v1, 128);
  return &unk_9185C;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 112AC: using guessed type int __fastcall ddnsapi_read_config_by_service_type(_DWORD, _DWORD, _DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);

//----- (000493F8) --------------------------------------------------------
void *__fastcall sub_493F8(const char *a1)
{
  const char *v1; // r4@1
  char *v2; // r0@2
  const char *v3; // r1@2
  void *v4; // r0@9
  char v6; // [sp+Ch] [bp-22Ch]@9
  int v7; // [sp+1Ch] [bp-21Ch]@9

  v1 = a1;
  strcpy((char *)&unk_918DC, "");
  if ( !strcmp(v1, "ftp") )
  {
    v2 = (char *)&unk_918DC;
    v3 = "http://download.iptime.co.kr/online_upgrade/iptimenas_setup.exe";
LABEL_5:
    strcpy(v2, v3);
    return &unk_918DC;
  }
  if ( !strcmp(v1, "rsync") )
  {
    v2 = (char *)&unk_918DC;
    v3 = "http://download.iptime.co.kr/online_upgrade/iptime_cloudbackup_setup.exe";
    goto LABEL_5;
  }
  if ( !strcmp(v1, "torrent") )
  {
    v2 = (char *)&unk_918DC;
    v3 = "http://download.iptime.co.kr/transmission_ui.html";
    goto LABEL_5;
  }
  if ( !strcmp(v1, "torrent_web") )
  {
    get_torrent_config(&v6);
    v4 = sub_49370();
    snprintf((char *)&unk_918DC, 0x100u, (const char *)&unk_81D70, v4, v7);
  }
  else if ( !strcmp(v1, "cupsd") )
  {
    snprintf((char *)&unk_918DC, 0x100u, "http://download.iptime.co.kr/online_upgrade/iptime_network_printer_setup.exe");
  }
  return &unk_918DC;
}
// 11510: using guessed type int __fastcall get_torrent_config(_DWORD);

//----- (0004950C) --------------------------------------------------------
int sub_4950C()
{
  char v1; // [sp+8h] [bp-D30h]@2
  int v2; // [sp+408h] [bp-930h]@2
  int v3; // [sp+808h] [bp-530h]@2
  int v4; // [sp+C08h] [bp-130h]@2
  int v5; // [sp+D08h] [bp-30h]@2

  if ( make_auth() != -1 )
  {
    get_ipcloud_rand_str(&v5);
    snprintf((char *)&v3, 0x400u, "rv=%s&auth=%s&", &v5, &v4);
    encode_ipcloud_crypt(&v3, &v2);
    unlink("/tmp/ipdisk_ddns_response");
    snprintf(
      &v1,
      0x400u,
      "/usr/bin/wget 'http://members.ipcloud.co.kr:%d/ipcloud/ipdisk_unregister.php?value=%s' -q -O %s",
      33798,
      &v2,
      "/tmp/ipdisk_ddns_response");
    system(&v1);
  }
  return 0;
}
// 108F8: using guessed type int make_auth(void);
// 10CDC: using guessed type int __fastcall encode_ipcloud_crypt(_DWORD, _DWORD);
// 11108: using guessed type int __fastcall get_ipcloud_rand_str(_DWORD);

//----- (000495C0) --------------------------------------------------------
signed int __fastcall sub_495C0(int a1)
{
  int v1; // r4@1
  int v2; // r1@1
  const char *v3; // r10@2
  const char *v4; // r0@4
  int v5; // r9@5
  int v6; // r10@7
  int v7; // r7@7
  bool v8; // zf@7
  int v9; // r0@11
  int v10; // r0@13
  int v11; // r0@15
  const char *v12; // r0@17
  int v13; // r5@19
  const char *v14; // r0@19
  const char *v15; // r0@22
  const char *v16; // r0@24
  char *v17; // r2@26
  const char *v18; // r0@27
  int v19; // r0@30
  const char *v20; // r1@30
  const char *v21; // r0@32
  const char *v22; // r0@34
  int v23; // r0@37
  char *v24; // r1@37
  int v25; // r0@41
  char *v26; // r1@41
  const char *v27; // r0@45
  int v28; // r0@49
  const char *v29; // r0@51
  const char *v30; // r0@53
  const char *v31; // r0@55
  int v32; // r0@59
  const char *v33; // r0@61
  const char *v34; // r0@64
  int v35; // r0@66
  int v36; // r9@66
  int v37; // r0@68
  const char *v38; // r6@68
  int v39; // r0@76
  const char *v40; // r0@78
  const char *v41; // r0@81
  const char *v42; // r0@83
  const char *v43; // r0@85
  const char *v44; // r0@87
  int v45; // r0@89
  int v46; // r0@91
  const char *v47; // r0@99
  const char *v48; // r0@102
  int v49; // r1@105
  int v50; // r0@107
  int v51; // r0@109
  const char *v52; // r0@121
  const char *v53; // r0@124
  int v54; // r1@127
  int v55; // r0@129
  const char *v56; // r0@131
  int v57; // r0@133
  const char *v58; // r7@133
  const char *v59; // r0@145
  int v60; // r0@146
  int v61; // r0@147
  const char *v62; // r0@149
  const char *v63; // r0@151
  const char *v64; // r0@155
  int v65; // r0@157
  char *v66; // r1@157
  int v67; // r5@163
  const char *v68; // r11@164
  int v69; // r1@171
  int v70; // r1@173
  char file; // [sp+8h] [bp-2290h]@7
  int v73; // [sp+Ch] [bp-228Ch]@10
  int v74; // [sp+2Ch] [bp-226Ch]@10
  int v75; // [sp+42Ch] [bp-1E6Ch]@10
  int v76; // [sp+46Ch] [bp-1E2Ch]@10
  int v77; // [sp+4ECh] [bp-1DACh]@10
  int v78; // [sp+C08h] [bp-1690h]@102
  int v79; // [sp+C8Ch] [bp-160Ch]@114
  int v80; // [sp+C9Ch] [bp-15FCh]@113
  int v81; // [sp+1008h] [bp-1290h]@71
  int v82; // [sp+1090h] [bp-1208h]@138
  int v83; // [sp+10A0h] [bp-11F8h]@137
  int v84; // [sp+1408h] [bp-E90h]@124
  int v85; // [sp+140Ch] [bp-E8Ch]@132
  int v86; // [sp+1410h] [bp-E88h]@128
  int v87; // [sp+1490h] [bp-E08h]@131
  int v88; // [sp+14A0h] [bp-DF8h]@137
  int v89; // [sp+16A0h] [bp-BF8h]@102
  int v90; // [sp+16A4h] [bp-BF4h]@106
  int v91; // [sp+1724h] [bp-B74h]@109
  int v92; // [sp+1734h] [bp-B64h]@113
  int v93; // [sp+1934h] [bp-964h]@76
  int v94; // [sp+1938h] [bp-960h]@86
  int v95; // [sp+193Ch] [bp-95Ch]@88
  int v96; // [sp+1940h] [bp-958h]@84
  int v97; // [sp+1944h] [bp-954h]@77
  int v98; // [sp+1948h] [bp-950h]@91
  int v99; // [sp+1958h] [bp-940h]@94
  int v100; // [sp+1B58h] [bp-740h]@59
  int v101; // [sp+1B5Ch] [bp-73Ch]@60
  int v102; // [sp+1B60h] [bp-738h]@68
  int v103; // [sp+1B70h] [bp-728h]@71
  int v104; // [sp+1D70h] [bp-528h]@164
  int v105; // [sp+1D74h] [bp-524h]@172
  int v106; // [sp+1DF4h] [bp-4A4h]@174
  signed int v107; // [sp+1F78h] [bp-320h]@166
  int v108; // [sp+1F7Ch] [bp-31Ch]@34
  char v109; // [sp+1F80h] [bp-318h]@39
  char v110; // [sp+2000h] [bp-298h]@26
  int v111; // [sp+2080h] [bp-218h]@46
  int v112; // [sp+2088h] [bp-210h]@155
  int v113; // [sp+2090h] [bp-208h]@159
  int v114; // [sp+2124h] [bp-174h]@15
  int v115; // [sp+2148h] [bp-150h]@16
  int v116; // [sp+214Ch] [bp-14Ch]@16
  int v117; // [sp+2154h] [bp-144h]@32
  int v118; // [sp+21A8h] [bp-F0h]@10
  int v119; // [sp+21ACh] [bp-ECh]@50
  int v120; // [sp+21B0h] [bp-E8h]@56
  int v121; // [sp+2228h] [bp-70h]@3
  int v122; // [sp+2268h] [bp-30h]@150
  int v123; // [sp+226Ch] [bp-2Ch]@152

  v1 = a1;
  v2 = get_pvalue(a1, "service");
  if ( !v2 )
    return 0;
  sf_strncpy(&v121, v2, 64);
  if ( !strcmp((const char *)&v121, "ipdisk") )
  {
    v4 = (const char *)get_pvalue(v1, "run");
    if ( v4 )
      v5 = atoi(v4);
    else
      v5 = 1;
    v6 = get_pvalue(v1, "hostname");
    v7 = get_pvalue(v1, "email");
    memset(&file, 0, 0x500u);
    v8 = v7 == 0;
    if ( v7 )
      v8 = v6 == 0;
    if ( !v8 )
    {
      sf_strncpy(&v74, v6, 1024);
      strcat((char *)&v74, ".ipdisk.co.kr");
      sf_strncpy(&v75, v7, 64);
      sf_strncpy(&v76, v7, 64);
      strcpy((char *)&v77, "wan1");
      strcpy((char *)&v73, "ipdisk_router");
      snprintf((char *)&v118, 0x80u, "ddns+%s", &v74);
      system((const char *)&unk_81E66);
      ddnsapi_remove_by_service_type("ipdisk_router");
      if ( v5 )
        v9 = ddnsapi_add_config(&file);
      else
        v9 = sub_4950C();
      v10 = signal_save(v9);
      signal_wan(v10);
    }
    goto LABEL_163;
  }
  if ( !strcmp((const char *)&v121, "ftp") )
  {
    v11 = get_ftpd_config(&v114);
    if ( local_gateway_is_default_gateway(v11) )
    {
      system2("/sbin/upnpc -d %d tcp", v115);
      system2("/sbin/upnpc -d %d tcp", v116);
    }
    v12 = (const char *)get_pvalue(v1, "run");
    if ( v12 )
      v114 = atoi(v12);
    v13 = v114;
    v14 = (const char *)get_pvalue(v1, "port_method");
    if ( v14 && !strcmp(v14, "default") )
    {
      v115 = 21;
    }
    else
    {
      v15 = (const char *)get_pvalue(v1, "ftp_port");
      if ( v15 )
        v115 = atoi(v15);
    }
    v16 = (const char *)get_pvalue(v1, &unk_81E9C);
    if ( v16 && !strcmp(v16, "default") )
    {
      v17 = &v110;
      v116 = 9000;
    }
    else
    {
      v18 = (const char *)get_pvalue(v1, "ipdisk_port");
      if ( v18 )
        v116 = atoi(v18);
      v17 = &v110;
    }
    *((_DWORD *)v17 + 84) = 1;
    v19 = get_pvalue(v1, "ftp_encoding");
    v20 = "AUTO";
    if ( v19 )
      v20 = (const char *)v19;
    sf_strncpy(&v117, v20, 64);
    set_ftpd_config(&v114);
    system((const char *)&unk_81E66);
    v21 = (const char *)ddnsapi_clear_status_by_service_type("ipdisk_router");
    goto LABEL_162;
  }
  if ( !strcmp((const char *)&v121, "samba") )
  {
    get_samba_config(&v108);
    v22 = (const char *)get_pvalue(v1, "run");
    if ( v22 )
      v108 = atoi(v22);
    v13 = v108;
    if ( v108 )
    {
      v23 = get_pvalue(v1, &unk_81ECE);
      v24 = "";
      if ( v23 )
        v24 = (char *)v23;
      sf_strncpy(&v109, v24, 128);
      if ( !v109 )
        strcpy(&v109, "iptimenas");
      v25 = get_pvalue(v1, "samba_group");
      v26 = "";
      if ( v25 )
        v26 = (char *)v25;
      sf_strncpy(&v110, v26, 128);
      if ( !v110 )
        strcpy(&v110, "WORKGROUP");
      v27 = (const char *)get_pvalue(v1, "samba_login");
      if ( v27 )
        v111 = atoi(v27);
    }
    v21 = (const char *)set_samba_config(&v108);
    goto LABEL_162;
  }
  if ( !strcmp((const char *)&v121, "url") )
  {
    v28 = get_urlsvc_config(&v118);
    if ( local_gateway_is_default_gateway(v28) )
      system2("/sbin/upnpc -d %d tcp", v119);
    v29 = (const char *)get_pvalue(v1, "run");
    if ( v29 )
      v118 = atoi(v29);
    v13 = v118;
    v30 = (const char *)get_pvalue(v1, "url_port");
    if ( v30 )
      v119 = atoi(v30);
    v31 = (const char *)get_pvalue(v1, "url_login");
    if ( v31 )
      v120 = atoi(v31);
    v21 = (const char *)set_urlsvc_config(&v118);
    goto LABEL_162;
  }
  if ( !strcmp((const char *)&v121, "rsync") )
  {
    v32 = get_rsync_config(&v100);
    if ( local_gateway_is_default_gateway(v32) )
      system2("/sbin/upnpc -d %d tcp", v101);
    v33 = (const char *)get_pvalue(v1, "run");
    if ( v33 )
      v100 = atoi(v33);
    v13 = v100;
    if ( !v100 )
      goto LABEL_74;
    v34 = (const char *)get_pvalue(v1, &unk_81F18);
    if ( v34 )
      v101 = atoi(v34);
    v35 = get_pvalue(v1, "rsync_hddname");
    v36 = v35;
    if ( !v35 )
      return v36;
    v3 = (const char *)check_unpermitted_chars(v35);
    if ( !v3 )
    {
      sf_strncpy(&v102, v36, 16);
      v37 = get_pvalue(v1, "rsync_folder");
      v38 = (const char *)v37;
      if ( v37 )
      {
        v36 = check_unpermitted_chars(v37);
        if ( v36 )
          return (signed int)v3;
        if ( !strstr(v38, "..") )
        {
          sf_strncpy(&v103, v38, 512);
          snprintf((char *)&v81, 0x3FFu, "/mnt/%s/%s", &v102, &v103);
          iconv_to_utf8(&v81, &file, 3072);
          quote_r(&file, 3072);
          if ( file_exists(&file) || !system2("mkdir -p '%s'", &file) )
          {
            chmod(&file, 0x1FFu);
LABEL_74:
            v21 = (const char *)set_rsync_config(&v100);
LABEL_162:
            if ( v13 )
            {
LABEL_163:
              v67 = 0;
              do
              {
                memset(&v104, 0, 0x20Cu);
                v21 = (const char *)get_pvalue_array(v1, "property", v67);
                v68 = v21;
                if ( v21 )
                {
                  if ( !strcmp(v21, "off") )
                  {
                    v107 = 0;
                  }
                  else if ( !strcmp(v68, "readwrite") )
                  {
                    v107 = 1;
                  }
                  else if ( !strcmp(v68, "readonly") )
                  {
                    v107 = 2;
                  }
                  v69 = get_pvalue_array(v1, "user_id", v67);
                  if ( v69 )
                    sf_strncpy(&v105, v69, 64);
                  v70 = get_pvalue_array(v1, "passwd", v67);
                  if ( v70 )
                    sf_strncpy(&v106, v70, 128);
                  v21 = (const char *)check_unpermitted_chars(&v105);
                  if ( v21 )
                    break;
                  v21 = (const char *)check_unpermitted_password_chars(&v106);
                  if ( v21 )
                    break;
                  remove_user_system(&v121, v67);
                  if ( v107 || (_BYTE)v105 || (_BYTE)v106 )
                  {
                    set_nas_user(&v121, v67, &v104);
                    v21 = (const char *)set_nas_user_system(&v121, &v104);
                  }
                  else
                  {
                    v21 = (const char *)set_nas_user(&v121, v67, 0);
                  }
                }
                ++v67;
              }
              while ( v67 != 5 );
            }
            signal_save(v21);
            if ( !strcmp((const char *)&v121, "ftp") )
              strcpy((char *)&v121, (const char *)&unk_82079);
            signal_nas(&v121);
            sleep(3u);
            return 1;
          }
          return -1;
        }
        return v36;
      }
      return (signed int)v38;
    }
    return 0;
  }
  if ( strcmp((const char *)&v121, "torrent") )
  {
    if ( !strcmp((const char *)&v121, "media") )
    {
      v47 = (const char *)get_pvalue(v1, "update_media_db");
      if ( v47 && !strcmp(v47, "update") )
        istatus_set_intvalue_direct("update_media_db", 1);
      get_media_config(&v89);
      get_media_config(&v78);
      v48 = (const char *)get_pvalue(v1, "run");
      if ( v48 )
        v89 = atoi(v48);
      v13 = v89;
      if ( v89 )
      {
        v49 = get_pvalue(v1, "media_name");
        if ( v49 )
          sf_strncpy(&v90, v49, 128);
        v50 = get_pvalue(v1, "media_hddname");
        v3 = (const char *)v50;
        if ( !v50 )
          return (signed int)v3;
        if ( check_unpermitted_chars(v50) )
          return 0;
        sf_strncpy(&v91, v3, 16);
        v51 = get_pvalue(v1, "media_folder");
        v3 = (const char *)v51;
        if ( !v51 )
          return (signed int)v3;
        v36 = check_unpermitted_chars(v51);
        if ( v36 )
          return 0;
        if ( strstr(v3, "..") )
          return v36;
        sf_strncpy(&v92, v3, 512);
        if ( strcmp((const char *)&v92, (const char *)&v80) || strcmp((const char *)&v91, (const char *)&v79) )
          istatus_set_intvalue_direct("update_media_db", 1);
        snprintf((char *)&v81, 0x3FFu, "/mnt/%s/%s", &v91, &v92);
        iconv_to_utf8(&v81, &file, 3072);
        quote_r(&file, 3072);
        if ( !file_exists(&file) && system2("mkdir -p '%s'", &file) )
          return -1;
        chmod(&file, 0x1FFu);
      }
      v21 = (const char *)set_media_config(&v89);
      goto LABEL_162;
    }
    if ( strcmp((const char *)&v121, "itunes") )
    {
      if ( !strcmp((const char *)&v121, "tethering") )
      {
        v59 = (const char *)get_pvalue(v1, "run");
        if ( v59 )
        {
          v60 = atoi(v59);
          v59 = (const char *)set_usb_tethering_op(v60);
        }
        v61 = signal_update(v59);
        signal_save(v61);
        return 1;
      }
      if ( !strcmp((const char *)&v121, "cupsd") )
      {
        v62 = (const char *)get_pvalue(v1, "run");
        if ( v62 )
          v122 = atoi(v62);
        v63 = (const char *)get_pvalue(v1, "cupsd_remote");
        if ( v63 )
          v123 = atoi(v63);
        set_cupsd_config(&v122);
        goto LABEL_163;
      }
      if ( !strcmp((const char *)&v121, "afp") )
      {
        get_afp_config(&v112);
        v64 = (const char *)get_pvalue(v1, "run");
        if ( v64 )
          v112 = atoi(v64);
        v13 = v112;
        v65 = get_pvalue(v1, "afp_name");
        v66 = "";
        if ( v65 )
          v66 = (char *)v65;
        sf_strncpy(&v113, v66, 128);
        if ( !(_BYTE)v113 )
          strcpy((char *)&v113, "iptimenas");
        v21 = (const char *)set_afp_config(&v112);
        goto LABEL_162;
      }
      return 0;
    }
    v52 = (const char *)get_pvalue(v1, "update_itunes_db");
    if ( v52 && !strcmp(v52, "update") )
      istatus_set_intvalue_direct("update_itunes_db", 1);
    get_itunes_config(&v84);
    get_itunes_config(&v81);
    v53 = (const char *)get_pvalue(v1, "run");
    if ( v53 )
      v84 = atoi(v53);
    v13 = v84;
    if ( v84 )
    {
      v54 = get_pvalue(v1, "itunes_name");
      if ( v54 )
        sf_strncpy(&v86, v54, 128);
      v55 = get_pvalue(v1, "itunes_hddname");
      v3 = (const char *)v55;
      if ( !v55 )
        return (signed int)v3;
      if ( check_unpermitted_chars(v55) )
        return 0;
      sf_strncpy(&v87, v3, 16);
      v56 = (const char *)get_pvalue(v1, &unk_82010);
      if ( v56 )
        v85 = 60 * atoi(v56);
      v57 = get_pvalue(v1, "itunes_folder");
      v58 = (const char *)v57;
      if ( !v57 )
        return v57;
      v3 = (const char *)check_unpermitted_chars(v57);
      if ( v3 )
        return 0;
      if ( strstr(v58, "..") )
        return (signed int)v3;
      sf_strncpy(&v88, v58, 512);
      if ( strcmp((const char *)&v88, (const char *)&v83) || strcmp((const char *)&v87, (const char *)&v82) )
        istatus_set_intvalue_direct("update_itunes_db", 1);
      snprintf((char *)&v78, 0x3FFu, "/mnt/%s/%s", &v87, &v88);
      iconv_to_utf8(&v78, &file, 3072);
      quote_r(&file, 3072);
      if ( !file_exists(&file) && system2("mkdir -p '%s'", &file) )
        return -1;
      chmod(&file, 0x1FFu);
    }
    v21 = (const char *)set_itunes_config(&v84);
    goto LABEL_162;
  }
  v39 = get_torrent_config(&v93);
  if ( local_gateway_is_default_gateway(v39) )
    system2("/sbin/upnpc -d %d tcp", v97);
  v40 = (const char *)get_pvalue(v1, "run");
  if ( v40 )
    v93 = atoi(v40);
  v13 = v93;
  if ( !v93 )
    goto LABEL_97;
  v41 = (const char *)get_pvalue(v1, "tr_remote_port");
  if ( v41 )
    v97 = atoi(v41);
  v42 = (const char *)get_pvalue(v1, "keep_seeding");
  if ( v42 )
    v96 = atoi(v42);
  v43 = (const char *)get_pvalue(v1, "max_down_rate");
  if ( v43 )
    v94 = atoi(v43);
  v44 = (const char *)get_pvalue(v1, "max_up_rate");
  if ( v44 )
    v95 = atoi(v44);
  v45 = get_pvalue(v1, "torrent_hddname");
  v3 = (const char *)v45;
  if ( v45 )
  {
    v38 = (const char *)check_unpermitted_chars(v45);
    if ( v38 )
      return 0;
    sf_strncpy(&v98, v3, 16);
    v46 = get_pvalue(v1, "torrent_folder");
    v3 = (const char *)v46;
    if ( !v46 )
      return (signed int)v3;
    v36 = check_unpermitted_chars(v46);
    if ( v36 )
      return (signed int)v38;
    if ( strstr(v3, "..") )
      return v36;
    sf_strncpy(&v99, v3, 512);
    snprintf((char *)&v81, 0x3FFu, "/mnt/%s/%s", &v98, &v99);
    iconv_to_utf8(&v81, &file, 3072);
    quote_r(&file, 3072);
    if ( !file_exists(&file) && system2("mkdir -p '%s'", &file) )
      return -1;
    chmod(&file, 0x1FFu);
LABEL_97:
    v21 = (const char *)set_torrent_config(&v93);
    goto LABEL_162;
  }
  return (signed int)v3;
}
// 10010: using guessed type int __fastcall get_rsync_config(_DWORD);
// 10034: using guessed type int __fastcall set_samba_config(_DWORD);
// 10184: using guessed type int __fastcall istatus_set_intvalue_direct(_DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10364: using guessed type int __fastcall quote_r(_DWORD, _DWORD);
// 10400: using guessed type int __fastcall remove_user_system(_DWORD, _DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 1046C: using guessed type int __fastcall local_gateway_is_default_gateway(_DWORD);
// 1049C: using guessed type int __fastcall signal_nas(_DWORD);
// 104A8: using guessed type int __fastcall set_torrent_config(_DWORD);
// 10580: using guessed type int __fastcall get_ftpd_config(_DWORD);
// 105A4: using guessed type int __fastcall get_urlsvc_config(_DWORD);
// 1061C: using guessed type int __fastcall get_media_config(_DWORD);
// 10778: using guessed type int __fastcall iconv_to_utf8(_DWORD, _DWORD, _DWORD);
// 109B8: using guessed type int __fastcall set_media_config(_DWORD);
// 109F4: using guessed type int __fastcall set_cupsd_config(_DWORD);
// 10A3C: using guessed type int __fastcall set_usb_tethering_op(_DWORD);
// 10A78: using guessed type int __fastcall set_itunes_config(_DWORD);
// 10B2C: using guessed type int __fastcall ddnsapi_add_config(_DWORD);
// 10B38: using guessed type int __fastcall set_urlsvc_config(_DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10D24: using guessed type int __fastcall set_rsync_config(_DWORD);
// 10D48: using guessed type int __fastcall get_samba_config(_DWORD);
// 10D60: using guessed type int __fastcall signal_wan(_DWORD);
// 10F70: using guessed type int system2(const char *, ...);
// 10FDC: using guessed type int __fastcall get_afp_config(_DWORD);
// 1115C: using guessed type int __fastcall get_itunes_config(_DWORD);
// 11168: using guessed type int __fastcall set_ftpd_config(_DWORD);
// 1130C: using guessed type int __fastcall set_nas_user_system(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11510: using guessed type int __fastcall get_torrent_config(_DWORD);
// 115C4: using guessed type int __fastcall file_exists(_DWORD);
// 11630: using guessed type int __fastcall get_pvalue_array(_DWORD, _DWORD, _DWORD);
// 1187C: using guessed type int __fastcall check_unpermitted_password_chars(_DWORD);
// 118DC: using guessed type int __fastcall ddnsapi_clear_status_by_service_type(_DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11B1C: using guessed type int __fastcall set_afp_config(_DWORD);
// 11B58: using guessed type int __fastcall ddnsapi_remove_by_service_type(_DWORD);
// 11BF4: using guessed type int __fastcall set_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004A628) --------------------------------------------------------
void __fastcall sub_4A628(int a1)
{
  int v1; // r6@1
  int v2; // r5@1
  void *v3; // r4@1
  signed int v4; // r8@1
  int v5; // r1@1
  signed int v6; // r6@4
  void *v7; // r0@11
  int v8; // r0@11
  int v9; // r0@13
  int v10; // r7@13
  int v11; // r0@13
  void *v12; // r0@23
  int v13; // r0@23
  int v14; // r7@23
  int v15; // r0@23
  void *v16; // r0@33
  int v17; // r0@33
  int v18; // r7@33
  int v19; // r0@33
  void *v20; // r0@38
  int v21; // r0@38
  int v22; // r7@38
  int v23; // r0@38
  char v24; // [sp+Ch] [bp-14DCh]@6
  int v25; // [sp+50Ch] [bp-FDCh]@33
  int v26; // [sp+514h] [bp-FD4h]@42
  int v27; // [sp+594h] [bp-F54h]@42
  int v28; // [sp+5A4h] [bp-F44h]@42
  int v29; // [sp+90Ch] [bp-BDCh]@26
  char v30; // [sp+910h] [bp-BD8h]@27
  int v31; // [sp+990h] [bp-B58h]@27
  int v32; // [sp+9A0h] [bp-B48h]@27
  int v33; // [sp+BA0h] [bp-948h]@21
  int v34; // [sp+BB0h] [bp-938h]@23
  int v35; // [sp+DC4h] [bp-724h]@31
  int v36; // [sp+DC8h] [bp-720h]@33
  int v37; // [sp+DDCh] [bp-70Ch]@33
  int v38; // [sp+FDCh] [bp-50Ch]@16
  int v39; // [sp+FE0h] [bp-508h]@18
  int v40; // [sp+11DCh] [bp-30Ch]@11
  int v41; // [sp+11E4h] [bp-304h]@47
  int v42; // [sp+12DCh] [bp-20Ch]@7
  int v43; // [sp+13DCh] [bp-10Ch]@9
  int v44; // [sp+1400h] [bp-E8h]@11
  int v45; // [sp+1460h] [bp-88h]@2
  int v46; // [sp+14A0h] [bp-48h]@36
  int v47; // [sp+14A4h] [bp-44h]@38
  char v48; // [sp+14C0h] [bp-28h]@51

  v1 = a1;
  v2 = get_num_of_mountdev(0);
  v3 = malloc(0x800u);
  memset(v3, 0, 0x800u);
  v4 = sub_495C0(v1);
  v5 = get_pvalue(v1, "service");
  if ( v5 )
    sf_strncpy(&v45, v5, 64);
  else
    strcpy((char *)&v45, "ipdisk");
  v6 = 5;
  print_file("/home/httpd/js/nasconf.js");
  printf("<BODY style=\"padding:0px 0px; margin:0px 0px;\">");
  printf("<form method=get action=\"timepro.cgi\" name=\"main_form\">");
  printf("<input type=hidden name=tmenu value=iframe>");
  printf("<input type=hidden name=\"smenu\" value=\"nas_service\">");
  printf("<input type=hidden name=\"click_id\" value=>");
  printf("<input type=hidden name=\"click_bg\" value=>");
  printf("<input type=hidden name=service value=>");
  printf("<input type=hidden name=run value=>");
  printf("<input type=hidden name=port_method value=>");
  printf("<input type=hidden name=ipdisk_port_method value=>");
  printf("<input type=hidden name=hostname value=>");
  printf("<input type=hidden name=email value=>");
  printf("<input type=hidden name=ftp_port value=>");
  printf("<input type=hidden name=ipdisk_port value=>");
  printf("<input type=hidden name=ftp_encoding value=>");
  printf("<input type=hidden name=rsync_port value=>");
  printf("<input type=hidden name=rsync_hddname value=>");
  printf("<input type=hidden name=rsync_folder value=>");
  printf("<input type=hidden name=tr_remote_port value=>");
  printf("<input type=hidden name=torrent_hddname value=>");
  printf("<input type=hidden name=torrent_folder value=>");
  printf("<input type=hidden name=media_name value=>");
  printf("<input type=hidden name=media_hddname value=>");
  printf("<input type=hidden name=media_folder value=>");
  printf("<input type=hidden name=update_media_db value=>");
  printf("<input type=hidden name=itunes_name value=>");
  printf("<input type=hidden name=itunes_hddname value=>");
  printf("<input type=hidden name=itunes_folder value=>");
  printf("<input type=hidden name=update_itunes_db value=>");
  printf("<input type=hidden name=itunes_scan_period value=>");
  printf("<input type=hidden name=afp_port value=>");
  printf("<input type=hidden name=afp_name value=>");
  printf("<input type=hidden name=afp_login_restrict value=>");
  printf("<input type=hidden name=afp_sleep_timeout value=>");
  printf("<input type=hidden name=afp_login_attempt value=>");
  printf("<input type=hidden name=afp_login_timeout value=>");
  printf("<input type=hidden name=cupsd_remote value=>");
  printf("<input type=hidden name=samba_name value=>");
  printf("<input type=hidden name=samba_group value=>");
  printf("<input type=hidden name=url_login value=>");
  printf("<input type=hidden name=url_port value=>");
  do
  {
    printf("<input type=hidden name=user_id value=>");
    printf("<input type=hidden name=passwd value=>");
    printf("<input type=hidden name=property value=>");
    --v6;
  }
  while ( v6 );
  printf("<table style=\"border-collapse:collapse; border-style:none none none none; width:100%%;\" cellspacing=0px cellpadding=0px>\n");
  printf("<COL WIDTH=9><COL WIDTH=200><COL WIDTH=150><COL>");
  memset(&v24, 0, 0x500u);
  if ( ddnsapi_read_config_by_service_type(0, "ipdisk_router", &v24) )
  {
    snprintf((char *)&v42, 0x100u, "<span id=ipdisk_status></span>");
    snprintf(
      (char *)v3,
      0x200u,
      "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:300px; text-overflow:ellipsis;\">%s</span>");
  }
  else
  {
    snprintf((char *)&v42, 0x100u, "<span id=ipdisk_status></span>");
    snprintf((char *)&v42, 0x100u, "%s", "설정되지 않음");
    strcpy((char *)v3, "");
  }
  sub_49034((int)"ipdisk", (int)"ipDISK 주소 관리", (int)&v42);
  get_ftpd_config(&v43);
  strcpy((char *)&v42, "<span id=ftp_status>--</span>");
  if ( v43 )
  {
    v7 = sub_49370();
    v8 = snprintf((char *)&v40, 0x80u, "ftp://%s", v7, 0);
    if ( v44 != 21 )
      snprintf((char *)&v40 + v8, 0x80u, ":%d");
    v9 = snprintf(
           (char *)v3,
           0x200u,
           "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:300px; text-overflow:ellipsis;\">",
           &v40);
    v10 = (int)v3 + v9;
    v11 = snprintf((char *)v3 + v9, 0x200u, "<a target=_blank href='%s'>%s</a>", &v40, &v40);
    snprintf((char *)(v10 + v11), 0x200u, "</span>");
  }
  else
  {
    strcpy((char *)v3, "");
  }
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"ftp", (int)"ipDISK/FTP 서비스", (int)&v42);
  get_samba_config(&v38);
  strcpy((char *)&v42, "<span id=samba_status>--</span>");
  if ( v38 )
    snprintf((char *)v3, 0x200u, "\\\\%s</a>", &v39, 1);
  else
    strcpy((char *)v3, "");
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"samba", (int)"윈도우 파일공유 서비스", (int)&v42);
  get_torrent_config(&v33);
  strcpy((char *)&v42, "");
  strcpy((char *)v3, "");
  snprintf((char *)&v42, 0x100u, "<span id=torrent_status> -- </span>");
  if ( v33 )
  {
    v12 = sub_49370();
    snprintf((char *)&v38, 0x200u, (const char *)&unk_81D70, v12, v34);
    v13 = snprintf(
            (char *)v3,
            0x200u,
            "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:300px; text-overflow:ellipsis;\">",
            &v38);
    v14 = (int)v3 + v13;
    v15 = snprintf((char *)v3 + v13, 0x200u, "<a target=_blank href='%s'>%s</a>", &v38, &v38);
    snprintf((char *)(v14 + v15), 0x200u, "</span>");
  }
  else
  {
    strcpy((char *)v3, "");
  }
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"torrent", (int)"토렌트", (int)&v42);
  get_media_config(&v29);
  snprintf((char *)&v42, 0x100u, (const char *)&unk_82938);
  if ( v29 )
    snprintf((char *)v3, 0x200u, (const char *)&unk_8295A, &v30, &v31, &v32);
  else
    strcpy((char *)v3, "");
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"media", (int)"미디어서버", (int)&v42);
  get_rsync_config(&v35);
  strcpy((char *)&v42, "<span id=rsync_status>--</span>");
  if ( v35 )
  {
    v16 = sub_49370();
    snprintf((char *)&v25, 0x400u, "%s:%d/%s", v16, v36, &v37);
    v17 = snprintf(
            (char *)v3,
            0x200u,
            "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:300px; text-overflow:ellipsis;\">",
            &v25);
    v18 = (int)v3 + v17;
    v19 = snprintf((char *)v3 + v17, 0x200u, "%s", &v25);
    snprintf((char *)(v18 + v19), 0x200u, "</span>");
  }
  else
  {
    strcpy((char *)v3, "");
  }
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"rsync", (int)"Cloud백업 서비스", (int)&v42);
  get_urlsvc_config(&v46);
  snprintf((char *)&v42, 0x100u, "<span id=url_status>--</span>");
  if ( v46 )
  {
    v20 = sub_49370();
    snprintf((char *)&v38, 0x200u, "http://%s:%d/list", v20, v47);
    v21 = snprintf(
            (char *)v3,
            0x200u,
            "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:300px; text-overflow:ellipsis;\">",
            &v38);
    v22 = (int)v3 + v21;
    v23 = snprintf((char *)v3 + v21, 0x200u, "<a target=_blank href='%s'>%s</a>", &v38, &v38);
    snprintf((char *)(v22 + v23), 0x200u, "</span>");
  }
  else
  {
    strcpy((char *)v3, "");
  }
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"url", (int)"URL서비스", (int)&v42);
  get_itunes_config(&v25);
  snprintf((char *)&v42, 0x100u, "<span id=itunes_status> -- </span>");
  if ( v25 )
    snprintf((char *)v3, 0x200u, (const char *)&unk_8295A, &v26, &v27, &v28);
  else
    strcpy((char *)v3, "");
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"itunes", (int)"iTunes서버", (int)&v42);
  get_afp_config(&v40);
  snprintf((char *)&v42, 0x100u, "<span id=afp_status> -- </span>");
  if ( v40 )
    snprintf((char *)v3, 0x200u, "%s", &v41, 7);
  else
    strcpy((char *)v3, "");
  if ( !v2 )
    strcpy((char *)&v42, "중단됨(저장장치없음)");
  sub_49034((int)"afp", (int)"AFP서비스", (int)&v42);
  get_cupsd_config(&v48);
  snprintf((char *)&v42, 0x100u, "<span id=cupsd_status> -- </span>");
  get_ifconfig("br0", &v46, 0);
  if ( *(_DWORD *)&v48 )
    snprintf((char *)v3, 0x200u, "http://%s:%d/printers/%s", &v46, 631, "ipTIME_Printer");
  else
    strcpy((char *)v3, "");
  sub_49034((int)"cupsd", (int)"네트워크 프린터 서버", (int)&v42);
  snprintf((char *)&v42, 0x100u, "<span id=tethering_status> -- </span>");
  strcpy((char *)v3, "");
  sub_49034((int)"tethering", (int)"USB테더링", (int)&v42);
  printf("</table>");
  printf("</BODY>");
  printf("<script> ClickNasService(document.getElementById('%s'));\n", &v45);
  puts("UnMaskIt(parent.document,'apply_mask');");
  printf("</script>");
  printf("<iframe src=\"timepro.cgi?tmenu=iframe_nas_status\" scrolling=no align=left valign=center height=0 frameborder=no name=\"iframe_status\"></iframe>");
  if ( v4 == -1 )
    printf((const char *)&unk_82B7A, "폴더를 생성할 수 없습니다.");
  free(v3);
}
// 10010: using guessed type int __fastcall get_rsync_config(_DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10580: using guessed type int __fastcall get_ftpd_config(_DWORD);
// 105A4: using guessed type int __fastcall get_urlsvc_config(_DWORD);
// 1061C: using guessed type int __fastcall get_media_config(_DWORD);
// 10BB0: using guessed type int __fastcall get_cupsd_config(_DWORD);
// 10D48: using guessed type int __fastcall get_samba_config(_DWORD);
// 10EB0: using guessed type int __fastcall get_ifconfig(_DWORD, _DWORD, _DWORD);
// 10FDC: using guessed type int __fastcall get_afp_config(_DWORD);
// 1115C: using guessed type int __fastcall get_itunes_config(_DWORD);
// 112AC: using guessed type int __fastcall ddnsapi_read_config_by_service_type(_DWORD, _DWORD, _DWORD);
// 11384: using guessed type int __fastcall get_num_of_mountdev(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11510: using guessed type int __fastcall get_torrent_config(_DWORD);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);

//----- (0004B1B8) --------------------------------------------------------
int sub_4B1B8()
{
  int v0; // r7@1
  char *v1; // r1@2
  char *v2; // r1@5
  char *v3; // r0@7
  bool v4; // zf@9
  char *v5; // r1@10
  int v7; // [sp+0h] [bp-598h]@1
  char s1; // [sp+4h] [bp-594h]@9
  char v9; // [sp+24h] [bp-574h]@7
  char v10; // [sp+420h] [bp-178h]@10
  char v11; // [sp+500h] [bp-98h]@7

  memset(&v7, 0, 0x500u);
  v0 = ddnsapi_read_config_by_service_type(0, "ipdisk_router", &v7);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\">%s</td>", "서비스");
  printf("<td colspan=3>");
  if ( v0 )
    v1 = "checked";
  else
    v1 = "";
  printf("<input type=radio name=ipdisk_run value=1 %s onclick=\"InitipDISK();\"> %s", v1, "실행");
  print_nbsp(10);
  if ( v0 )
    v2 = "";
  else
    v2 = "checked";
  printf("<input type=radio name=ipdisk_run value=0 %s onclick=\"InitipDISK();\"> %s", v2, "중단");
  printf("</td></tr>");
  printf("<tr height=20px><td style=\"padding-left:5px;\">%s</td>", "ipDISK 주소");
  printf("<td colspan=3>");
  sf_strncpy(&v11, &v9, 128);
  v3 = strchr(&v11, 46);
  if ( v3 )
    *v3 = 0;
  printf("<input type=text name=hostname size=31 maxlength=31 value=%s>", &v11);
  printf((const char *)&unk_82D09);
  printf("</td></tr>");
  printf("<tr><td style=\"padding-left:5px;\">%s</td>", "ipDISK 이메일");
  printf("<td colspan=2>");
  v4 = strcmp(&s1, "ipdisk_router") == 0;
  if ( v4 )
    v5 = &v10;
  else
    v5 = "";
  if ( v4 )
    v5 += 4;
  printf("<input type=text name=email size=31 maxlength=31 value=%s>", v5);
  printf("</td>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitipDISK();");
  return puts("</script>");
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 112AC: using guessed type int __fastcall ddnsapi_read_config_by_service_type(_DWORD, _DWORD, _DWORD);

//----- (0004B37C) --------------------------------------------------------
int sub_4B37C()
{
  char *v0; // r1@2
  char *v1; // r1@5
  char *v2; // r1@8
  char *v3; // r1@11
  char *v4; // r1@14
  char *v5; // r1@17
  char *v6; // r1@20
  char *v7; // r1@23
  char *v8; // r1@26
  int v9; // r4@28
  char *v10; // r1@30
  char *v11; // r1@33
  char *v12; // r1@36
  int v13; // r1@38
  int v14; // r2@38
  int v15; // r3@38
  char v17; // [sp+8h] [bp-2B0h]@29
  char v18; // [sp+Ch] [bp-2ACh]@38
  char v19; // [sp+8Ch] [bp-22Ch]@38
  int v20; // [sp+210h] [bp-A8h]@29
  int v21; // [sp+214h] [bp-A4h]@1
  int v22; // [sp+238h] [bp-80h]@22
  int v23; // [sp+23Ch] [bp-7Ch]@25
  int v24; // [sp+244h] [bp-74h]@7

  get_ftpd_config(&v21);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\">%s</td>", "서비스");
  printf("<td colspan=3>");
  if ( v21 )
    v0 = "checked";
  else
    v0 = "";
  printf("<input type=radio name=ftp_run value=1 %s onclick=\"InitFTP();\"> %s", v0, "실행");
  print_nbsp(10);
  if ( v21 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=ftp_run value=0 %s onclick=\"InitFTP();\"> %s", v1, "중단");
  printf("</td></tr>");
  printf("<tr height=23px>");
  printf("<td style=\"padding-left:5px;\">%s</td>", "문자셋");
  printf("<td colspan=3>");
  printf("<select style=\"width:137px;\" name=ftp_encoding>");
  if ( !strcmp((const char *)&v24, "EUC-KR") )
    v2 = "selected";
  else
    v2 = "";
  printf("<option value=AUTO %s> 자동 </option>", v2);
  if ( !strcmp((const char *)&v24, "EUC-KR") )
    v3 = "selected";
  else
    v3 = "";
  printf("<option value=EUC-KR %s> EUC-KR </option>", v3);
  if ( !strcmp((const char *)&v24, "UTF-8") )
    v4 = "selected";
  else
    v4 = "";
  printf("<option value=UTF-8 %s> UTF-8 </option>", v4);
  if ( !strcmp((const char *)&v24, "GB2312") )
    v5 = "selected";
  else
    v5 = "";
  printf("<option value=GB2312 %s> GB2312</option>", v5);
  if ( !strcmp((const char *)&v24, "BIG-5") )
    v6 = "selected";
  else
    v6 = "";
  printf("<option value=BIG-5 %s> BIG-5</option>", v6);
  printf("</select>");
  printf("</td></tr>");
  printf("<tr height=23px><td style=\"padding-left:5px;\">%s</td>", "ipDISK(FTP)포트");
  printf("<td colspan=3><input type=text name=ftp_port size=5 maxlength=5 value=%d>", v22);
  if ( v22 == 21 )
    v7 = "checked";
  else
    v7 = "";
  printf(
    "<input type=checkbox name=ftp_port_method value=default onclick=\"ClickFTPPortMethod();\" %s> %s</td>",
    v7,
    "기본포트사용");
  printf("</td></tr>");
  printf("<tr height=23px>");
  printf("<td style=\"padding-left:5px;\">%s</td>", &unk_82FE9);
  printf("<td colspan=3><input type=text name=ipdisk_port maxlength=5 size=5 value=%d>", v23);
  if ( v23 == 9000 )
    v8 = "checked";
  else
    v8 = "";
  printf(
    "<input type=checkbox name=ipdisk_port_method value=default %s  onclick=\"ClickServicePortMethod()\"> %s</td>",
    v8,
    "기본포트사용");
  v9 = 0;
  printf("</tr>");
  printf("<tr height=3px><td colspan=4></td></tr>");
  printf((const char *)&unk_830D5, "사용자 설정");
  printf("<table>");
  printf("<tr><td>%s</td><td>%s</td><td>%s</td></tr>", "속성", "사용자 ID", "사용자 암호");
  do
  {
    get_nas_user("ftp", v9, &v17);
    printf("<tr height=23px>");
    printf("<td><select name=ftp_property onchange=\"ChangeUserProperty('ftp','%d');\" >", v9);
    if ( v20 )
      v10 = "";
    else
      v10 = "selected";
    printf("<option value=off %s> %s", v10, "사용안함");
    if ( v20 == 1 )
      v11 = "selected";
    else
      v11 = "";
    printf("<option value=readwrite %s> %s", v11, "읽기/쓰기");
    if ( v20 == 2 )
      v12 = "selected";
    else
      v12 = "";
    printf("<option value=readonly %s>%s ", v12, "읽기전용");
    printf("</select>");
    printf("</td>");
    printf("<td><input type=text name=ftp_userid size=21 maxlength=32 value=%s></td>", &v18);
    printf(
      "<td><input type=password style=\"width:130px;height:20px;\" name=ftp_passwd size=21 maxlength=32 value='%s'>",
      &v19);
    printf(
      "<input type=text name=ftp_passwd_text style=\"height:20px;display:none;ime-mode:disabled;width:130px;\"  size=21 m"
      "axlength=32 value='%s'>",
      &v19);
    v13 = v9;
    v14 = v9;
    v15 = v9++;
    printf(
      "<INPUT TYPE=checkbox NAME=ftp_password_view value=1 onclick=\"PasswordView(ftp_passwd[%d],ftp_passwd_text[%d],ftp_"
      "password_view[%d]);\" > %s",
      v13,
      v14,
      v15,
      "암호보기");
    puts("</td></tr>");
  }
  while ( v9 != 5 );
  printf(
    "<tr><td colspan=3><span class=gray_text>%s</span></td></tr>",
    "*FTP서비스와 AFP서비스는 사용자ID 및 암호를 공유하여 사용합니다.");
  printf("</table>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("ClickFTPPortMethod();");
  puts("ClickServicePortMethod();");
  puts("InitFTP();");
  return puts("</script>");
}
// 10580: using guessed type int __fastcall get_ftpd_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004B7D0) --------------------------------------------------------
int sub_4B7D0()
{
  char *v0; // r1@2
  char *v1; // r1@5
  int v2; // r4@7
  char *v3; // r1@9
  char *v4; // r1@12
  char *v5; // r1@15
  int v6; // r1@17
  int v7; // r2@17
  int v8; // r3@17
  char v10; // [sp+8h] [bp-338h]@8
  char v11; // [sp+Ch] [bp-334h]@17
  char v12; // [sp+8Ch] [bp-2B4h]@17
  int v13; // [sp+210h] [bp-130h]@8
  int v14; // [sp+214h] [bp-12Ch]@1
  char v15; // [sp+218h] [bp-128h]@7
  int v16; // [sp+298h] [bp-A8h]@7

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=samba_setup_table><td style='width:100%%'>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  get_samba_config(&v14);
  printf("<tr height=23>");
  printf("<td style=\"padding-left:5px;\">%s</td>", "서비스");
  printf("<td colspan=3>");
  if ( v14 )
    v0 = "checked";
  else
    v0 = "";
  printf("<input type=radio name=samba_run value=1 %s onclick=\"InitSamba();\"> %s", v0, "실행");
  print_nbsp(10);
  if ( v14 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=samba_run value=0 %s onclick=\"InitSamba();\"> %s", v1, "중단");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서버이름");
  printf("<td><input type=text name=samba_name value=\"%s\" size=20 maxlength=32></td>", &v15);
  printf("<td style=\"padding-left:5px;\">%s</td>", "작업그룹");
  printf("<td><input type=text name=samba_group value=\"%s\" size=25 maxlength=32></td></tr>", &v16);
  v2 = 0;
  printf("<tr height=10px><td colspan=4></td></tr>");
  printf((const char *)&unk_830D5, "사용자 설정");
  printf("<table>");
  printf("<tr><td>%s</td><td>%s</td><td>%s</td></tr>", "속성", "사용자 ID", "사용자 암호");
  do
  {
    get_nas_user("samba", v2, &v10);
    printf("<tr height=23px>");
    printf("<td><select name=samba_property onchange=\"ChangeUserProperty('samba','%d');\" >", v2);
    if ( v13 )
      v3 = "";
    else
      v3 = "selected";
    printf("<option value=off %s> %s", v3, "사용안함");
    if ( v13 == 1 )
      v4 = "selected";
    else
      v4 = "";
    printf("<option value=readwrite %s> %s", v4, "읽기/쓰기");
    if ( v13 == 2 )
      v5 = "selected";
    else
      v5 = "";
    printf("<option value=readonly %s>%s ", v5, "읽기전용");
    printf("</select>");
    printf("</td>");
    printf("<td><input type=text name=samba_userid size=21 maxlength=32 value=%s></td>", &v11);
    printf(
      "<td><input type=password style=\"width:130px;height:20px;\" name=samba_passwd size=21 maxlength=32 value='%s'>",
      &v12);
    printf(
      "<input type=text name=samba_passwd_text style=\"height:20px;display:none;ime-mode:disabled;width:130px;\"  size=21"
      " maxlength=32 value='%s'>",
      &v12);
    v6 = v2;
    v7 = v2;
    v8 = v2++;
    printf(
      "<INPUT TYPE=checkbox NAME=samba_password_view value=1 onclick=\"PasswordView(samba_passwd[%d],samba_passwd_text[%d"
      "],samba_password_view[%d]);\" > %s",
      v6,
      v7,
      v8,
      "암호보기");
    puts("</td></tr>");
  }
  while ( v2 != 5 );
  printf("</table>");
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitSamba();");
  return puts("</script>");
}
// 10D48: using guessed type int __fastcall get_samba_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004BAC0) --------------------------------------------------------
int sub_4BAC0()
{
  char *v0; // r1@2
  char *v1; // r1@5
  char *v2; // r1@8
  char *v3; // r1@11
  char *v4; // r1@14
  int v6; // [sp+0h] [bp-228h]@13
  char v7; // [sp+4h] [bp-224h]@13
  char v8; // [sp+84h] [bp-1A4h]@13
  int v9; // [sp+20Ch] [bp-1Ch]@1
  int v10; // [sp+210h] [bp-18h]@13
  int v11; // [sp+214h] [bp-14h]@7

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  get_urlsvc_config(&v9);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v9 )
    v0 = "checked";
  else
    v0 = "";
  printf("<td colspan=3><input type=radio name=url_run value=1 %s onclick=\"InitURL();\"> %s", v0, "실행");
  print_nbsp(14);
  if ( v9 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=url_run value=0 %s onclick=\"InitURL();\"> %s", v1, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23px><td style=\"padding-left:5px;\">%s</td>", "사용자 인증");
  printf("<td colspan=3>");
  if ( v11 )
    v2 = "checked";
  else
    v2 = "";
  printf("<input type=radio name=url_login value=1 %s onclick=\"InitURL();\"> %s", v2, "사용함");
  print_nbsp(10);
  if ( v11 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=url_login value=0 %s onclick=\"InitURL();\"> %s", v3, "사용하지 않음");
  get_urlsvc_config(&v9);
  get_urlsvc_config(&v9);
  printf("</td></tr>");
  get_nas_user("url", 0, &v6);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "사용자 ID");
  printf("<td><input type=text name=url_userid size=20 maxlength=32 value=%s></td>", &v7);
  printf("<td style=\"padding-left:5px;\">%s</td>", "사용자 암호");
  printf(
    "<td><input type=password style=\"width:94px;height:20px;\" name=url_passwd size=12 maxlength=32 value='%s'>",
    &v8);
  printf(
    "<input type=text name=url_passwd_text style=\"width:94px;height:20px;display:none;ime-mode:disabled;\"  size=15 maxl"
    "ength=32 value='%s'>",
    &v8);
  printf(
    "<INPUT TYPE=checkbox NAME=url_password_view value=1 onclick=\"PasswordView(url_passwd,url_passwd_text,url_password_view);\" > %s",
    "암호보기");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "포트번호");
  puts("<td colspan=3>");
  printf("<input type=text name=url_port style=\"width:60px;\" size=5 maxlength=5 value=%d>", v10);
  if ( v10 == 8000 )
    v4 = "checked";
  else
    v4 = "";
  printf(
    "<input type=checkbox name=url_port_method value=default onclick=\"ClickURLPortMethod();\" %s>%s</td>",
    v4,
    "기본포트사용");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitURL();");
  return puts("</script>");
}
// 105A4: using guessed type int __fastcall get_urlsvc_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004BD0C) --------------------------------------------------------
int __fastcall sub_4BD0C(int a1, int a2, int a3, char a4)
{
  char v4; // r6@1
  _DWORD *i; // r4@1
  _DWORD *v6; // r5@4
  signed int v7; // r4@4
  int v8; // r9@5
  int v9; // r4@6
  int v10; // r6@6
  int v11; // ST0C_4@8
  size_t v12; // r0@8
  size_t v13; // r2@8
  int v14; // r3@8
  unsigned int v15; // t1@9
  char *v16; // r0@18
  int v18; // [sp+14h] [bp-CBCh]@4
  char v19; // [sp+18h] [bp-CB8h]@12
  int v20; // [sp+418h] [bp-8B8h]@1
  int v21; // [sp+818h] [bp-4B8h]@12
  int v22; // [sp+C18h] [bp-B8h]@5
  int v23; // [sp+C98h] [bp-38h]@1
  _DWORD *v24; // [sp+C9Ch] [bp-34h]@1
  void *ptr; // [sp+CA4h] [bp-2Ch]@1

  v4 = a4;
  ptr = 0;
  snprintf((char *)&v20, 0x200u, "%s:%s", a1, a2);
  get_mount_list(&v23, 0);
  for ( i = v24; i; i = (_DWORD *)*i )
    printf("<option value=\"%s_create_DxLoE2LK\">%s에 새로만들기");
  v6 = v24;
  v7 = -1;
  v18 = v4 & 1;
  while ( v6 )
  {
    snprintf((char *)&v22, 0x80u, "%s/%s");
    v8 = scandir(
           (const char *)&v22,
           (struct dirent ***)&ptr,
           (int (*)(const struct dirent *))dir_filter,
           (int (*)(const void *, const void *))sub_49288);
    if ( v8 <= 0 )
      break;
    v9 = 0;
    v10 = 0;
    do
    {
      if ( v18 )
      {
        v11 = *(_DWORD *)((char *)ptr + v9);
        v12 = strlen((const char *)(*(_DWORD *)((char *)ptr + v9) + 11));
        v13 = 0;
        v14 = v11 + 10;
        while ( v13 < v12 )
        {
          v15 = *(_BYTE *)(v14++ + 1);
          if ( v15 > 0x7E )
            goto LABEL_13;
          ++v13;
        }
      }
      iconv_to_local(*(_DWORD *)((char *)ptr + v9) + 11, &v19, 1024);
      snprintf((char *)&v21, 0x400u, "%s:%s", v6 + 25, &v19);
      strcmp((const char *)&v21, (const char *)&v20);
      printf("<option value=\"%s\" %s>", &v21);
      printf("/%s/%s\n", v6 + 25, &v19);
      free(*(void **)((char *)ptr + v9));
LABEL_13:
      ++v10;
      v9 += 4;
    }
    while ( v10 < v8 );
    v6 = (_DWORD *)*v6;
    v7 = v8;
  }
  if ( v7 == -1 && strlen((const char *)&v20) > 1 )
  {
    v16 = strchr((const char *)&v20, 58);
    printf("<option value=\"%s\" selected>/HDD1/%s", &v20, v16 + 1);
  }
  if ( ptr )
    free(ptr);
  return free_mount_list(&v23);
}
// 102A4: using guessed type int __fastcall free_mount_list(_DWORD);
// 10E98: using guessed type int __fastcall iconv_to_local(_DWORD, _DWORD, _DWORD);
// 11594: using guessed type int __fastcall get_mount_list(_DWORD, _DWORD);
// 49288: using guessed type int sub_49288();

//----- (0004BF54) --------------------------------------------------------
int sub_4BF54()
{
  char *v0; // r1@2
  char *v1; // r1@5
  char *v2; // r1@8
  int v4; // [sp+4h] [bp-434h]@1
  int v5; // [sp+8h] [bp-430h]@7
  int v6; // [sp+Ch] [bp-42Ch]@10
  int v7; // [sp+1Ch] [bp-41Ch]@10
  char v8; // [sp+21Ch] [bp-21Ch]@10
  char v9; // [sp+220h] [bp-218h]@10
  char v10; // [sp+2A0h] [bp-198h]@10

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=80><COL WIDTH=200><COL WIDTH=80><COL WIDTH=200>");
  get_rsync_config(&v4);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v4 )
    v0 = "checked";
  else
    v0 = "";
  printf("<td colspan=3><input type=radio name=rsync_run value=1 %s onclick=\"InitRsync();\"> %s", v0, "실행");
  print_nbsp(14);
  if ( v4 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=rsync_run value=0 %s onclick=\"InitRsync();\"> %s", v1, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "포트번호");
  puts("<td colspan=3>");
  printf("<input type=text name=rsync_port style=\"width:60px;\" size=5 maxlength=5 value=%d>", v5);
  if ( v5 == 1873 )
    v2 = "checked";
  else
    v2 = "";
  printf(
    "<input type=checkbox name=rsync_port_method value=default onclick=\"ClickRsyncPortMethod();\" %s>%s</td>",
    v2,
    "기본포트사용");
  printf("</td></tr>");
  get_nas_user("rsync", 0, &v8);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "사용자 ID");
  printf("<td><input type=text name=rsync_userid size=23 maxlength=32 value=%s></td>", &v9);
  printf("<td style=\"padding-left:5px;\">%s</td>", "사용자 암호");
  printf(
    "<td><input type=password style=\"width:94px;height:20px;\" name=rsync_passwd size=12 maxlength=32 value='%s'>",
    &v10);
  printf(
    "<input type=text name=rsync_passwd_text style=\"width:94px;height:20px;display:none;ime-mode:disabled;\"  size=15 ma"
    "xlength=32 value='%s'>",
    &v10);
  printf(
    "<INPUT TYPE=checkbox NAME=rsync_password_view value=1 onclick=\"PasswordView(rsync_passwd,rsync_passwd_text,rsync_pa"
    "ssword_view);\" > %s",
    "암호보기");
  printf("</td></tr>");
  printf("<input type=hidden name=rsync_folder>");
  printf("<input type=hidden name=rsync_hddname>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "백업폴더");
  puts("<td colspan=2>");
  printf("<select style=\"width:290;\" name=rsync_path onchange=\"ChangeBackupFolder();\">");
  printf("<option value='select_backup_folder'>%s", "백업폴더를 선택하여 주십시오.");
  sub_4BD0C((int)&v6, (int)&v7, (int)"/mnt", 0);
  printf("</select>");
  printf("</td><td>");
  printf(
    "<input type=text name=new_folder size=30 maxlength=256 value=\"%s\" style=\"color:#888888; display:none;\" onfocus=\""
    "FocusNewFolder(new_folder,default_folder);\">",
    "새로운 폴더명을 입력하십시오.");
  printf("<input type=hidden name=\"default_folder\" value=\"%s\">", "새로운 폴더명을 입력하십시오.");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitRsync();");
  return puts("</script>");
}
// 10010: using guessed type int __fastcall get_rsync_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004C1E4) --------------------------------------------------------
int sub_4C1E4()
{
  char *v0; // r1@2
  char *v1; // r1@5
  char *v2; // r1@8
  const char *v3; // r0@11
  int v5; // [sp+0h] [bp-2A8h]@1
  int v6; // [sp+10h] [bp-298h]@7
  char v7; // [sp+14h] [bp-294h]@10
  char v8; // [sp+24h] [bp-284h]@10
  char v9; // [sp+224h] [bp-84h]@1
  char v10; // [sp+228h] [bp-80h]@7
  int v11; // [sp+2A8h] [bp+0h]@7
  char v12; // [sp+430h] [bp+188h]@12

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=torrent_setup_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=80><COL WIDTH=200><COL WIDTH=80><COL WIDTH=200>");
  get_torrent_config(&v5);
  get_nas_user("torrent", 0, &v9);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v5 )
    v0 = "checked";
  else
    v0 = "";
  printf("<td colspan=3><input type=radio name=torrent_run value=1 %s onclick=\"InitTorrent();\"> %s", v0, "실행");
  print_nbsp(14);
  if ( v5 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=torrent_run value=0 %s onclick=\"InitTorrent();\"> %s", v1, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "사용자 ID");
  printf("<td><input type=text name=torrent_userid size=23 maxlength=32 value=%s></td>", &v10);
  printf("<td style=\"padding-left:5px;\">%s</td>", "암호");
  printf(
    "<td><input type=password style=\"width:94px;height:20px;\" name=torrent_passwd size=12 maxlength=32 value='%s'>",
    &v11);
  printf(
    "<input type=text name=torrent_passwd_text style=\"width:94px;height:20px;display:none;ime-mode:disabled;\"  size=15 "
    "maxlength=32 value='%s'>",
    &v11);
  printf(
    "<INPUT TYPE=checkbox NAME=torrent_password_view value=1 onclick=\"PasswordView(torrent_passwd,torrent_passwd_text,to"
    "rrent_password_view);\" > %s",
    "암호보기");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "포트번호");
  puts("<td colspan=3>");
  printf("<input type=text name=tr_remote_port style=\"width:60px;\" size=5 maxlength=5 value=%d>", v6);
  if ( v6 == 9091 )
    v2 = "checked";
  else
    v2 = "";
  printf(
    "<input type=checkbox name=tr_remote_port_method value=default onclick=\"ClickTorrentPortMethod();\" %s>%s</td>",
    v2,
    "기본포트사용");
  printf("</td></tr>");
  printf("<input type=hidden name=torrent_folder>");
  printf("<input type=hidden name=torrent_hddname>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "다운로드폴더");
  puts("<td colspan=1>");
  printf("<select style=\"width:250;\" name=torrent_path onchange=\"ChangeTorrentFolder();\">");
  printf("<option value='select_torrent_folder'>%s", "다운로드 폴더를 선택하여 주십시오.");
  sub_4BD0C((int)&v7, (int)&v8, (int)"/mnt", 0);
  printf("</select>");
  printf("</td><td colspan=2 style=\"padding-left:5px;\">");
  printf(
    "<input type=hidden name=\"torrent_default_folder\" value=\"%s\">",
    "새로운 폴더명을 입력하십시오.");
  printf(
    "<input type=text name=torrent_new_folder size=30 maxlength=256 value=\"%s\" style=\"color:#888888; display:none;\" o"
    "nfocus=\"FocusNewFolder(torrent_new_folder, torrent_default_folder);\">",
    "새로운 폴더명을 입력하십시오.");
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("<tr id=torrent_install_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr><td align=left style=\"padding-left:5px;\">");
  if ( !get_mount_devpath("/tmp/mnt/HDD1", 0) )
  {
    v3 = "USB저장장치가 연결되어있지 않습니다.";
LABEL_15:
    printf(v3);
    goto LABEL_16;
  }
  if ( !get_wan_ip("wan1", &v12) && !get_default_gateway("br0", &v12) )
  {
    printf("공유기가 인터넷에 연결되어있지 않기 때문에, 토렌트를 사용할 수 없습니다.<br><br>");
    v3 = (const char *)&unk_848E8;
    goto LABEL_15;
  }
LABEL_16:
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitTorrent();");
  puts("</script>");
  puts("<script>");
  printf("ShowIt('torrent_setup_table');");
  printf("HideIt('torrent_install_table');");
  return puts("</script>");
}
// 1079C: using guessed type int __fastcall get_default_gateway(_DWORD, _DWORD);
// 10E80: using guessed type int __fastcall get_mount_devpath(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11510: using guessed type int __fastcall get_torrent_config(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004C564) --------------------------------------------------------
int sub_4C564()
{
  char *v0; // r1@2
  char *v1; // r1@5
  const char *v2; // r2@8
  char *v3; // r0@8
  const char *v4; // r0@11
  int v6; // [sp+4h] [bp-4CCh]@1
  char v7; // [sp+8h] [bp-4C8h]@7
  char v8; // [sp+88h] [bp-448h]@7
  char v9; // [sp+98h] [bp-438h]@7
  char v10; // [sp+298h] [bp-238h]@8
  char v11; // [sp+29Ch] [bp-234h]@10
  int v12; // [sp+498h] [bp-38h]@12

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=media_setup_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=100><COL WIDTH=220><COL WIDTH=80><COL WIDTH=160>");
  get_media_config(&v6);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v6 )
    v0 = "checked";
  else
    v0 = "";
  printf("<td colspan=3><input type=radio name=media_run value=1 %s onclick=\"InitMedia();\"> %s", v0, "실행");
  print_nbsp(14);
  if ( v6 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=media_run value=0 %s onclick=\"InitMedia();\"> %s", v1, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서버이름");
  printf(
    "<td colspan=3><input type=text style=\"width:220;\" name=media_name value=\"%s\"  maxlength=64></td></tr>",
    &v7);
  printf("</td>");
  printf("</tr>");
  printf("<input type=hidden name=media_folder>");
  printf("<input type=hidden name=media_hddname>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "미디어 폴더");
  puts("<td colspan=1>");
  printf("<select style=\"width:220;\" name=media_path onchange=\"ChangeMediaFolder();\">");
  printf("<option value='select_media_folder'>%s", "미디어 폴더를 선택하여 주십시오.");
  sub_4BD0C((int)&v8, (int)&v9, (int)"/mnt", 0);
  printf("</select>");
  printf("</td><td colspan=2 style=\"padding-left:5px;\">");
  printf("<input type=hidden name=\"media_default_folder\" value=\"%s\">", "새로운 폴더명을 입력하십시오.");
  printf(
    "<input type=text name=media_new_folder size=30 maxlength=256 value=\"%s\" style=\"color:#888888; display:none;\" onf"
    "ocus=\"FocusNewFolder(media_new_folder, media_default_folder);\">",
    "새로운 폴더명을 입력하십시오.");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "미디어DB폴더");
  if ( v8 )
  {
    v2 = (const char *)get_media_db_folder(&v6);
    v3 = &v10;
  }
  else
  {
    v2 = "/mnt--";
    v3 = &v10;
  }
  snprintf(v3, 0x200u, v2);
  printf(
    "<td><span id=media_db_folder>%s</span></td><td align=left  style=\"padding-left:5px;\" colspan=2><input type=button "
    "name=update_db value=\"%s\" onclick=\"UpdateMediaDB();\" %s></td></tr>",
    &v11,
    "미디어DB 수동 업데이트");
  printf("<tr><td style=\"padding-left:5px;\"></td>");
  printf("<td colspan=3><span id=media_db_status>-</span></td></tr>");
  printf("<tr><td style=\"padding-left:5px;\"></td>");
  printf("<td colspan=3><span id=media_db_update_file style=\"color:#888888; overflow:hidden; display:inline-block; white-space:nowrap; width:500px; text-overflow:ellipsis;\"></span></td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("<tr id=media_install_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr><td align=left style=\"padding-left:5px;\">");
  if ( !get_mount_devpath("/tmp/mnt/HDD1", 0) )
  {
    v4 = "USB저장장치가 연결되어있지 않습니다.<br>미디어 서버는 USB저장장치를 연결한 후,설"
         "치 및 실행이 가능합니다.";
LABEL_15:
    printf(v4);
    goto LABEL_16;
  }
  if ( !get_wan_ip("wan1", &v12) && !get_default_gateway("br0", &v12) )
  {
    printf("공유기가 인터넷에 연결되어있지 않기 때문에, 미디어 서버를 사용할 수 없습니다.<br><br>");
    v4 = (const char *)&unk_848E8;
    goto LABEL_15;
  }
LABEL_16:
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitMedia();");
  puts("</script>");
  puts("<script>");
  printf("ShowIt('media_setup_table');");
  printf("HideIt('media_install_table');");
  return puts("</script>");
}
// 1061C: using guessed type int __fastcall get_media_config(_DWORD);
// 1079C: using guessed type int __fastcall get_default_gateway(_DWORD, _DWORD);
// 10814: using guessed type int __fastcall get_media_db_folder(_DWORD);
// 10E80: using guessed type int __fastcall get_mount_devpath(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);

//----- (0004C8E0) --------------------------------------------------------
int sub_4C8E0()
{
  char *v0; // r1@2
  char *v1; // r1@5
  signed int v2; // r6@7
  char *v3; // r1@8
  signed int v4; // r4@10
  signed int v5; // r1@11
  signed int v6; // r3@11
  bool v7; // zf@11
  char *v8; // r2@12
  const char *v9; // r2@16
  char *v10; // r0@16
  int v12; // [sp+0h] [bp-4B0h]@1
  int v13; // [sp+4h] [bp-4ACh]@7
  char v14; // [sp+8h] [bp-4A8h]@7
  char v15; // [sp+88h] [bp-428h]@7
  char v16; // [sp+98h] [bp-418h]@7
  char v17; // [sp+298h] [bp-218h]@16
  char v18; // [sp+29Ch] [bp-214h]@18

  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=itunes_setup_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=100><COL WIDTH=220><COL WIDTH=80><COL WIDTH=160>");
  get_itunes_config(&v12);
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v12 )
    v0 = "checked";
  else
    v0 = "";
  printf("<td colspan=3><input type=radio name=itunes_run value=1 %s onclick=\"InitiTunes();\"> %s", v0, "실행");
  print_nbsp(14);
  if ( v12 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=itunes_run value=0 %s onclick=\"InitiTunes();\"> %s", v1, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서버이름");
  printf(
    "<td colspan=3><input type=text style=\"width:220;\" name=itunes_name value=\"%s\"  maxlength=64></td></tr>",
    &v14);
  v2 = 180;
  printf("<input type=hidden name=itunes_folder>");
  printf("<input type=hidden name=itunes_hddname>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "iTunes 음악 폴더");
  puts("<td colspan=1>");
  printf("<select style=\"width:220;\" name=itunes_path onchange=\"ChangeiTunesFolder();\">");
  printf("<option value='select_itunes_folder'>%s", "iTunes 음악 폴더를 선택하여 주십시오.");
  sub_4BD0C((int)&v15, (int)&v16, (int)"/mnt", 0);
  printf("</select>");
  printf("</td><td colspan=2 style=\"padding-left:5px;\">");
  printf(
    "<input type=hidden name=\"itunes_default_folder\" value=\"%s\">",
    "새로운 폴더명을 입력하십시오.");
  printf(
    "<input type=text name=itunes_new_folder size=30 maxlength=256 value=\"%s\" style=\"color:#888888; display:none;\" on"
    "focus=\"FocusNewFolder(itunes_new_folder, itunes_default_folder);\">",
    "새로운 폴더명을 입력하십시오.");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "자동 검색");
  printf("<td colspan=3>");
  if ( v13 )
    v3 = "checked";
  else
    v3 = "";
  v4 = 3;
  printf("<input type=checkbox name=itunes_scan_chk %s onchange=\"InitiTunes();\">", v3);
  printf("<select name=itunes_scan_period>");
  do
  {
    v5 = v4;
    v6 = v4;
    v4 += 3;
    v7 = v13 == v2;
    v2 += 180;
    if ( v7 )
      v8 = "selected";
    else
      v8 = "";
    printf("<option value=%d %s> %d", v5, v8, v6);
  }
  while ( v4 != 33 );
  printf("</select> %s", &unk_854DD);
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "MediaDB");
  if ( v15 )
  {
    v9 = (const char *)get_itunes_db_folder(&v12);
    v10 = &v17;
  }
  else
  {
    v9 = "/mnt--";
    v10 = &v17;
  }
  snprintf(v10, 0x200u, v9);
  printf(
    "<td><span id=itunes_db_folder>%s</span></td><td align=left  style=\"padding-left:5px;\" colspan=2><input type=button"
    " name=update_itunes_db_bt value=\"%s\" onclick=\"UpdateiTunesDB();\" %s></td></tr>",
    &v18,
    "미디어DB 수동 업데이트");
  printf("<tr><td style=\"padding-left:5px;\"></td>");
  printf("<td colspan=3><span id=itunes_db_status>-</span></td></tr>");
  printf("<tr><td style=\"padding-left:5px;\"></td>");
  printf("<td colspan=3><span id=itunes_db_update_file style=\"color:#888888; overflow:hidden; display:inline-block; white-space:nowrap; width:500px; text-overflow:ellipsis;\"></span></td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("<tr id=itunes_install_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr><td align=left style=\"padding-left:5px;\">");
  if ( !get_mount_devpath("/tmp/mnt/HDD1", 0) )
    printf("USB저장장치가 연결되어있지 않습니다.<br>iTunes 서버는 USB저장장치를 연결한 후,설치 및 실행이 가능합니다.");
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitiTunes();");
  puts("</script>");
  puts("<script>");
  printf("ShowIt('itunes_setup_table');");
  printf("HideIt('itunes_install_table');");
  return puts("</script>");
}
// 10658: using guessed type int __fastcall get_itunes_db_folder(_DWORD);
// 10E80: using guessed type int __fastcall get_mount_devpath(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 1115C: using guessed type int __fastcall get_itunes_config(_DWORD);

//----- (0004CCA8) --------------------------------------------------------
int sub_4CCA8()
{
  char *v0; // r1@2
  char *v1; // r1@5
  int v2; // r4@7
  char *v3; // r1@9
  char *v4; // r1@12
  char *v5; // r1@15
  int v6; // r1@17
  int v7; // r2@17
  int v8; // r3@17
  char v10; // [sp+8h] [bp-2C8h]@8
  char v11; // [sp+Ch] [bp-2C4h]@17
  char v12; // [sp+8Ch] [bp-244h]@17
  int v13; // [sp+210h] [bp-C0h]@8
  int v14; // [sp+214h] [bp-BCh]@1
  int v15; // [sp+21Ch] [bp-B4h]@7

  get_afp_config(&v14);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr height=23px><td style=\"padding-left:5px;\">%s</td>", "서비스");
  printf("<td colspan=3>");
  if ( v14 )
    v0 = "checked";
  else
    v0 = "";
  printf("<input type=radio name=afp_run value=1 %s onclick=\"InitAFP();\"> %s", v0, "실행");
  print_nbsp(10);
  if ( v14 )
    v1 = "";
  else
    v1 = "checked";
  printf("<input type=radio name=afp_run value=0 %s onclick=\"InitAFP();\"> %s", v1, "중단");
  printf("</td></tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서버이름");
  printf("<td><input type=text name=afp_name value=\"%s\" size=20 maxlength=32></td>", &v15);
  v2 = 0;
  printf("</tr>");
  printf("<tr height=3px><td colspan=4></td></tr>");
  printf((const char *)&unk_830D5, "사용자 설정");
  printf("<table>");
  printf("<tr><td>%s</td><td>%s</td><td>%s</td></tr>", "속성", "사용자 ID", "사용자 암호");
  do
  {
    get_nas_user("afp", v2, &v10);
    printf("<tr height=23px>");
    printf("<td><select name=afp_property onchange=\"ChangeUserProperty('afp','%d');\" >", v2);
    if ( v13 )
      v3 = "";
    else
      v3 = "selected";
    printf("<option value=off %s> %s", v3, "사용안함");
    if ( v13 == 1 )
      v4 = "selected";
    else
      v4 = "";
    printf("<option value=readwrite %s> %s", v4, "읽기/쓰기");
    if ( v13 == 2 )
      v5 = "selected";
    else
      v5 = "";
    printf("<option value=readonly %s>%s ", v5, "읽기전용");
    printf("</select>");
    printf("</td>");
    printf("<td><input type=text name=afp_userid size=21 maxlength=32 value=%s></td>", &v11);
    printf(
      "<td><input type=password style=\"width:130px;height:20px;\" name=afp_passwd size=21 maxlength=32 value='%s'>",
      &v12);
    printf(
      "<input type=text name=afp_passwd_text style=\"height:20px;display:none;ime-mode:disabled;width:130px;\"  size=21 m"
      "axlength=32 value='%s'>",
      &v12);
    v6 = v2;
    v7 = v2;
    v8 = v2++;
    printf(
      "<INPUT TYPE=checkbox NAME=afp_password_view value=1 onclick=\"PasswordView(afp_passwd[%d],afp_passwd_text[%d],afp_"
      "password_view[%d]);\" > %s",
      v6,
      v7,
      v8,
      "암호보기");
    puts("</td></tr>");
  }
  while ( v2 != 5 );
  printf(
    "<tr><td colspan=3><span class=gray_text>%s</span></td></tr>",
    "*FTP서비스와 AFP서비스는 사용자ID 및 암호를 공유하여 사용합니다.");
  printf("</table>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitAFP();");
  return puts("</script>");
}
// 10FDC: using guessed type int __fastcall get_afp_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11870: using guessed type int __fastcall get_nas_user(_DWORD, _DWORD, _DWORD);

//----- (0004CF68) --------------------------------------------------------
int sub_4CF68()
{
  int v0; // r6@1
  char *v1; // r1@2
  char *v2; // r1@5
  int v3; // r0@7
  int v4; // r0@7
  int v5; // r0@7
  int v6; // r0@7
  int v7; // r0@7
  int v8; // r0@7
  int v9; // r0@7
  int v10; // r0@7

  v0 = get_usb_tethering_op();
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=tethering_setup_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=100><COL WIDTH=220><COL WIDTH=80><COL WIDTH=160>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  if ( v0 )
    v1 = "checked";
  else
    v1 = "";
  printf("<td colspan=3><input type=radio name=tethering_run value=1 %s> %s", v1, "실행");
  print_nbsp(14);
  if ( v0 )
    v2 = "";
  else
    v2 = "checked";
  printf("<input type=radio name=tethering_run value=0 %s> %s", v2, "중단");
  printf("</td>");
  printf("</tr>");
  v3 = printf("<tr height=%d valign=bottom><td colspan=2 style=\"padding-left:5px;\">", 225);
  v4 = br(v3);
  br(v4);
  printf("<span class=gray_text>");
  v5 = printf("<b>USB 테더링 기능 설명</b>");
  br(v5);
  v6 = printf("1. USB테더링 기능을 사용하면, 스마트폰을 통한 인터넷을 사용할 수 있습니다.");
  br(v6);
  v7 = printf("2. 공유기와 스마트폰을 USB케이블로 연결 하고, 스마트폰의 [USB테더링기능]을 활성화한 후 사용 가능합니다.");
  br(v7);
  v8 = printf("3. 안드로이드 계열 스마트폰을 지원합니다.(일부 호환되지 않는 기종이 있을 수 있습니다.)");
  br(v8);
  v9 = printf("4. 스마트폰이 3G/LTE등으로 연결된 경우, 요금제에 따라 데이터 요금이 발생할 수 있습니다.");
  br(v9);
  v10 = printf("5. 공유기의 WAN포트가 연결되어 있는 상태에서는 동작하지 않습니다.");
  br(v10);
  printf("</span>");
  printf("</td></tr>");
  printf("</TABLE>");
  return printf("</td></tr></TABLE>");
}
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);
// 1175C: using guessed type int get_usb_tethering_op(void);

//----- (0004D0DC) --------------------------------------------------------
int __fastcall sub_4D0DC(int a1, int a2, int a3)
{
  char *v3; // r1@2
  char *v4; // r1@5
  char *v5; // r1@8
  int v6; // r0@10
  int v7; // r0@10
  int v8; // r0@10
  int v9; // r0@10
  int v11; // [sp+0h] [bp-18h]@1
  int v12; // [sp+4h] [bp-14h]@1
  int v13; // [sp+8h] [bp-10h]@1

  v11 = a1;
  v12 = a2;
  v13 = a3;
  get_cupsd_config(&v11);
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<tr id=cupsd_setup_table><td>");
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%%>");
  printf("<COL WIDTH=100><COL WIDTH=220><COL WIDTH=80><COL WIDTH=160>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "서비스");
  printf("<td colspan=3><input type=radio name=cupsd_run value=1 %s onclick=\"InitCUPS();\"> %s");
  print_nbsp(14);
  if ( v11 )
    v3 = "";
  else
    v3 = "checked";
  printf("<input type=radio name=cupsd_run value=0 %s onclick=\"InitCUPS();\"> %s", v3, "중단");
  printf("</td>");
  printf("</tr>");
  printf("<tr height=23><td style=\"padding-left:5px;\">%s</td>", "외부(WAN) 접속");
  if ( v12 )
    v4 = "checked";
  else
    v4 = "";
  printf("<td colspan=3><input type=radio name=cupsd_remote value=1 %s onclick=\"InitCUPS();\"> %s", v4, "허용");
  print_nbsp(14);
  if ( v12 )
    v5 = "";
  else
    v5 = "checked";
  printf("<input type=radio name=cupsd_remote value=0 %s onclick=\"InitCUPS();\"> %s", v5, "차단");
  printf("</td>");
  printf("</tr>");
  v6 = printf("<tr height=%d valign=bottom><td colspan=2 style=\"padding-left:5px;\">", 202);
  v7 = br(v6);
  br(v7);
  printf("<span class=gray_text>");
  v8 = printf("<b>네트워크 프린터 기능 설명</b>");
  br(v8);
  v9 = printf("네트워크 프린터 서버 기능을 통해 공유기에 연결된 USB 프린터를 네트워크 프린터 방식으로 이용할 수 있습니다.");
  br(v9);
  printf("</span>");
  printf("</td></tr>");
  printf("</TABLE>");
  printf("</td></tr>");
  printf("</TABLE>");
  puts("<script>");
  puts("InitCUPS();");
  return puts("</script>");
}
// 10BB0: using guessed type int __fastcall get_cupsd_config(_DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11360: using guessed type int __fastcall br(_DWORD);

//----- (0004D2B0) --------------------------------------------------------
int __fastcall sub_4D2B0(const char *a1, int a2)
{
  int v2; // r5@1
  const char *v3; // r4@1
  int result; // r0@21
  int v5; // r2@21

  v2 = a2;
  v3 = a1;
  if ( !strcmp(a1, "ipdisk") )
    sub_4B1B8();
  if ( !strcmp(v3, "ftp") )
    sub_4B37C();
  if ( !strcmp(v3, "samba") )
    sub_4B7D0();
  if ( !strcmp(v3, "url") )
    sub_4BAC0();
  if ( !strcmp(v3, "rsync") )
    sub_4BF54();
  if ( !strcmp(v3, "torrent") )
    sub_4C1E4();
  if ( !strcmp(v3, "media") )
    sub_4C564();
  if ( !strcmp(v3, "itunes") )
    sub_4C8E0();
  if ( !strcmp(v3, "afp") )
    sub_4CCA8();
  if ( !strcmp(v3, "tethering") )
    sub_4CF68();
  result = strcmp(v3, "cupsd");
  if ( !result )
    result = sub_4D0DC((int)v3, v2, v5);
  return result;
}

//----- (0004D448) --------------------------------------------------------
int __fastcall sub_4D448(const char *a1, int a2)
{
  const char *v2; // r4@1
  int v3; // r5@1

  v2 = a1;
  v3 = a2;
  printf("<TABLE border=0 valign=top CELLSPACING=0 CELLPADDING=0 WIDTH=100%% ID=%s_table STYLE=\"display:none;\">", a1);
  printf(
    "<tr><td width=200 height=20 valign=center style=\"padding:3px;\">&nbsp; <b>%s</b></td><td width=440px align=right>%s</td></tr>",
    v3);
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td colspan=2></td></tr>");
  printf("<tr><td  colspan=2 valign=top style=\"padding:5px\" >");
  sub_4D2B0(v2, 0);
  return puts((const char *)&unk_5C75F);
}

//----- (0004D4BC) --------------------------------------------------------
int __fastcall sub_4D4BC(int a1)
{
  int v1; // r5@1
  _DWORD *i; // r4@1
  int v3; // r0@4
  int v4; // r6@4
  int v5; // r3@4
  void *v6; // r0@6
  void *v7; // r0@6
  void *v8; // r0@6
  int v9; // r5@6
  void *v10; // r0@6
  void *v11; // r0@6
  char dest[512]; // [sp+Ch] [bp-31Ch]@1
  char v14[256]; // [sp+20Ch] [bp-11Ch]@4
  char v15; // [sp+30Ch] [bp-1Ch]@1
  _DWORD *v16; // [sp+310h] [bp-18h]@1

  v1 = a1;
  strcpy(dest, "");
  puts("<table style=\"border-collapse:collapse; border-style:none solid solid solid; border-width:0px 1px 1px 1px; border-color:#eeeeee; width:642;\" cellspacing=0px cellpadding=0px>");
  printf("<form method=get action=\"timepro.cgi\" name=\"nasmisc_fm\">");
  printf("<input type=hidden name=tmenu value=basicapp>");
  printf("<input type=hidden name=\"smenu\" value=\"service\">");
  printf("<input type=hidden name=\"act\" value=\"\">");
  get_mount_list(&v15, 0);
  for ( i = v16; i; i = (_DWORD *)*i )
    printf("<input type=hidden ID=%s_fs value=%s>", i + 25, i + 41);
  v3 = free_mount_list(&v15);
  str(v3);
  printf("<td width=100%% height=%d>", 220);
  v4 = snprintf(v14, 0x40u, (const char *)&unk_86169);
  v5 = get_pvalue(v1, "act");
  if ( v5 )
    snprintf(&v14[v4], 0x80u, "&act=%s", v5);
  printf(
    "<iframe name=\"nas_service_iframe\" src=\"%s\" frameborder=no width=100%% height=100%% align=left scrolling=yes></iframe>",
    v14);
  printf("</td></tr>");
  printf("<tr height=%d style=\"background-Color:#eeeeee\"><td valign=top>\n", 285);
  sub_4D448("ipdisk", (int)"ipDISK 주소 관리");
  v6 = sub_493F8("ftp");
  snprintf(dest, 0x100u, "<a target=_blank href=\"%s\">%s</a>", v6, "[ PC용 ipDISK Drive 프로그램 다운로드 ]");
  sub_4D448("ftp", (int)"ipDISK/FTP 서비스");
  sub_4D448("samba", (int)"윈도우 파일공유 서비스");
  v7 = sub_493F8("rsync");
  snprintf(dest, 0x100u, "<a target=_blank href=\"%s\">%s</a>", v7, "[ PC용 Cloud백업 프로그램 다운로드 ]");
  sub_4D448("rsync", (int)"Cloud백업 서비스");
  strcpy(dest, "");
  sub_4D448("url", (int)"URL서비스");
  v8 = sub_493F8("torrent_web");
  v9 = snprintf(dest, 0x100u, "<a target=_blank href=\"%s\">[%s]</a>", v8, "토렌트 웹UI 접속");
  v10 = sub_493F8("torrent");
  snprintf(&dest[v9], 0x100u, (const char *)&unk_862E4, v10, "토렌트 접속기 다운로드");
  sub_4D448("torrent", (int)"토렌트");
  sub_4D448("media", (int)"미디어서버");
  sub_4D448("itunes", (int)"iTunes서버");
  sub_4D448("afp", (int)"AFP서비스");
  sub_4D448("tethering", (int)"USB테더링");
  v11 = sub_493F8("cupsd");
  snprintf(dest, 0x100u, "<a target=_blank href=\"%s\">[%s]</a>", v11, &unk_86341);
  sub_4D448("cupsd", (int)"네트워크 프린터 서버");
  printf("</td></tr>");
  printf("<tr height=1px style=\"background-Color:#dddddd\"><td></td></tr>");
  printf("<tr align=right valign=middle height=28 style=\"background-Color:#eeeeee\"><td>");
  printf("<input type=button id=apply_bt name=params_bt value=\"%s\" onclick=\"ApplyNas();\">", "적용");
  printf("</td></tr>");
  printf("</form>");
  return printf("</table>");
}
// 102A4: using guessed type int __fastcall free_mount_list(_DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11594: using guessed type int __fastcall get_mount_list(_DWORD, _DWORD);
// 4D4BC: using guessed type char dest[512];
// 4D4BC: using guessed type char var_11C[256];

//----- (0004D828) --------------------------------------------------------
int __fastcall sub_4D828(int a1)
{
  int v1; // r4@1
  const char *v2; // r4@1
  int v3; // r8@3
  char *v4; // r0@9
  char v5; // r3@9
  char *v6; // r5@13
  void *v7; // r0@14
  int v8; // r8@19
  char *v9; // r0@19
  const char *v10; // r7@19
  size_t v11; // r0@20
  char *v12; // r6@20
  size_t v13; // r5@21
  size_t v14; // r0@21
  size_t v15; // r0@22
  char *v16; // r5@22
  size_t v17; // r0@22
  char *v18; // r0@24
  char *v19; // r6@24
  int v20; // r0@24
  int v21; // r0@24
  signed int v22; // r6@30
  const char *v23; // r2@33
  char *v24; // r0@33
  int v25; // r8@39
  char *v26; // r0@39
  const char *v27; // r7@39
  size_t v28; // r0@40
  char *v29; // r6@40
  size_t v30; // r5@41
  size_t v31; // r0@41
  size_t v32; // r0@42
  char *v33; // r5@42
  size_t v34; // r0@42
  char *v35; // r0@44
  char *v36; // r6@44
  int v37; // r0@44
  int v38; // r0@44
  signed int v39; // r6@50
  const char *v40; // r2@53
  char *v41; // r0@53
  int v42; // r5@69
  char *v43; // r0@72
  const char *v44; // r2@72
  const char *v45; // r3@72
  int v46; // r0@79
  int v47; // r0@83
  char *v48; // r1@83
  char *v49; // r0@84
  const char *v50; // r2@84
  const char *v51; // r3@84
  const char *v52; // r0@90
  char v54; // [sp+Ch] [bp-125Ch]@4
  int v55; // [sp+30h] [bp-1238h]@5
  int v56; // [sp+80Ch] [bp-A5Ch]@39
  char v57; // [sp+894h] [bp-9D4h]@41
  int v58; // [sp+8A4h] [bp-9C4h]@41
  int v59; // [sp+AA4h] [bp-7C4h]@19
  char v60; // [sp+B28h] [bp-740h]@21
  int v61; // [sp+B38h] [bp-730h]@21
  int v62; // [sp+D38h] [bp-530h]@13
  int v63; // [sp+D3Ch] [bp-52Ch]@35
  int v64; // [sp+F38h] [bp-330h]@4
  char v65; // [sp+F54h] [bp-314h]@5
  int v66; // [sp+1138h] [bp-130h]@6
  time_t v67; // [sp+1178h] [bp-F0h]@27
  int v68; // [sp+123Ch] [bp-2Ch]@17

  v1 = a1;
  get_process_list();
  v2 = (const char *)get_pvalue(v1, "service");
  printf("<html>");
  print_file("/home/httpd/js/common.js");
  if ( !v2 || !strcmp(v2, "ipdisk") )
  {
    memset(&v64, 0, 0x5Cu);
    memset(&v54, 0, 0x500u);
    v3 = ddnsapi_read_config_by_service_type(0, "ipdisk_router", &v54);
    if ( v3 )
    {
      ddnsapi_get_status(&v55, &v64);
      if ( v65 )
      {
        v3 = 0;
        sf_strncpy(&v66, &v65, 256);
      }
      else
      {
        v3 = 1;
        strcpy((char *)&v66, "등록중");
      }
    }
    else
    {
      strcpy((char *)&v66, "설정되지 않음");
    }
    v4 = strchr((const char *)&v66, 59);
    if ( v4 )
      v5 = 0;
    if ( v4 )
      *v4 = v5;
    v6 = (char *)&v62
       + snprintf(
           (char *)&v62,
           0x80u,
           "<span title=\"%s\" style=\"overflow:hidden; white-space:nowrap; width:140px; text-overflow:ellipsis;\">",
           &v66);
    if ( v3 )
    {
      v7 = sub_16094();
      v6 += snprintf(v6, 0x80u, "<img width=10 height=10 src=\"/%s/apply_ani.gif\"> ", v7);
    }
    snprintf(v6, 0x80u, "%s</span>", &v66);
    puts("<script>");
    printf("if(parent.document.getElementById('ipdisk_status'))");
    printf("parent.document.getElementById('ipdisk_status').innerHTML = '%s';", &v62);
    puts("</script>");
    if ( !v2 )
    {
LABEL_17:
      v3 |= sub_49160((int)&v68, (int)"torrent");
      if ( !v2 )
        goto LABEL_19;
      goto LABEL_18;
    }
  }
  else
  {
    v3 = 0;
  }
  if ( !strcmp(v2, "torrent") )
    goto LABEL_17;
LABEL_18:
  if ( strcmp(v2, "media") )
    goto LABEL_38;
LABEL_19:
  v8 = v3 | sub_49160((int)&v68, (int)"media");
  get_media_config(&v59);
  v9 = sub_492E8("/tmp/.dlna-av_scan");
  v10 = v9;
  if ( v9 )
  {
    v11 = strlen(v9);
    v12 = (char *)malloc(3 * v11 + 16);
    strcpy(v12, "");
    if ( *v10 )
    {
      snprintf((char *)&v62, 0x200u, (const char *)&unk_864C0, &v60, &v61);
      v13 = strlen((const char *)&v62) + 1;
      v14 = strlen(v10);
      iconv_to_local(&v10[v13], v12, 3 * v14);
    }
    v15 = strlen(v12);
    v16 = (char *)malloc(v15 + 128);
    v17 = strlen(v12);
    snprintf(v16, v17 + 128, "DB 업데이트 중...");
    sub_490F0((int)&unk_864E6, (int)"DB 업데이트 중...");
    sub_490F0((int)"media_db_update_file", (int)v12);
    free((void *)v10);
    if ( v12 )
      free(v12);
    v22 = 1;
  }
  else
  {
    v18 = (char *)malloc(0x200u);
    v16 = v18;
    v19 = v18;
    v20 = get_media_db_filename(&v59);
    iconv_to_utf8(v20, &v54, 2048);
    v21 = stat(&v54, (struct stat *)&v66);
    if ( v21 == -1 )
    {
      snprintf(v16, 0x200u, "미디어DB 파일 없음");
    }
    else
    {
      if ( get_timed_status(v21) )
        sub_1655C(v67, (char *)&v64, 0x100u, (int)v10);
      else
        snprintf((char *)&v64, 0x100u, "--");
      snprintf(v19, 0x200u, "업데이트됨(%s)", &v64);
    }
    v22 = 0;
    sub_490F0((int)"media_db_update_file", (int)"");
  }
  sub_490F0((int)"media_db_status", (int)v16);
  if ( v60 )
  {
    v23 = (const char *)get_media_db_folder(&v59);
    v24 = (char *)&v62;
  }
  else
  {
    v23 = "/mnt--";
    v24 = (char *)&v62;
  }
  snprintf(v24, 0x200u, v23);
  sub_490F0((int)"media_db_folder", (int)&v63);
  if ( v16 )
    free(v16);
  v3 = v8 | v22;
  if ( v2 )
  {
LABEL_38:
    if ( strcmp(v2, "itunes") )
      goto LABEL_58;
  }
  v25 = v3 | sub_49160((int)&v68, (int)"itunes");
  get_itunes_config(&v56);
  v26 = sub_492E8((const char *)&unk_86556);
  v27 = v26;
  if ( v26 )
  {
    v28 = strlen(v26);
    v29 = (char *)malloc(3 * v28 + 16);
    strcpy(v29, "");
    if ( *v27 )
    {
      snprintf((char *)&v62, 0x200u, (const char *)&unk_864C0, &v57, &v58);
      v30 = strlen((const char *)&v62) + 1;
      v31 = strlen(v27);
      iconv_to_local(&v27[v30], v29, 3 * v31);
    }
    v32 = strlen(v29);
    v33 = (char *)malloc(v32 + 128);
    v34 = strlen(v29);
    snprintf(v33, v34 + 128, "DB 업데이트 중...");
    sub_490F0((int)&unk_864E6, (int)"DB 업데이트 중...");
    sub_490F0((int)"media_db_update_file", (int)v29);
    free((void *)v27);
    if ( v29 )
      free(v29);
    v39 = 1;
  }
  else
  {
    v35 = (char *)malloc(0x200u);
    v33 = v35;
    v36 = v35;
    v37 = get_itunes_db_filename(&v56);
    iconv_to_utf8(v37, &v54, 2048);
    v38 = stat(&v54, (struct stat *)&v66);
    if ( v38 == -1 )
    {
      snprintf(v33, 0x200u, "미디어DB 파일 없음");
    }
    else
    {
      if ( get_timed_status(v38) )
        sub_1655C(v67, (char *)&v64, 0x100u, (int)v27);
      else
        snprintf((char *)&v64, 0x100u, "--");
      snprintf(v36, 0x200u, "업데이트됨(%s)", &v64);
    }
    v39 = 0;
    sub_490F0((int)"itunes_db_update_file", (int)"");
  }
  sub_490F0((int)"itunes_db_status", (int)v33);
  if ( v57 )
  {
    v40 = (const char *)get_itunes_db_folder(&v56);
    v41 = (char *)&v62;
  }
  else
  {
    v40 = "/mnt--";
    v41 = (char *)&v62;
  }
  snprintf(v41, 0x200u, v40);
  sub_490F0((int)"itunes_db_folder", (int)&v63);
  if ( v33 )
    free(v33);
  v3 = v25 | v39;
  if ( !v2 )
  {
LABEL_59:
    v3 |= sub_49160((int)&v68, (int)"afp");
    if ( !v2 )
      goto LABEL_61;
    goto LABEL_60;
  }
LABEL_58:
  if ( !strcmp(v2, "afp") )
    goto LABEL_59;
LABEL_60:
  if ( strcmp(v2, "samba") )
    goto LABEL_62;
LABEL_61:
  v3 |= sub_49160((int)&v68, (int)"samba");
  if ( v2 )
  {
LABEL_62:
    if ( strcmp(v2, "rsync") )
      goto LABEL_64;
  }
  v3 |= sub_49160((int)&v68, (int)"rsync");
  if ( !v2 )
    goto LABEL_65;
LABEL_64:
  if ( !strcmp(v2, "ftp") )
  {
LABEL_65:
    v3 |= sub_49160((int)&v68, (int)"ftp");
    if ( !v2 )
      goto LABEL_67;
  }
  if ( strcmp(v2, "url") )
    goto LABEL_68;
LABEL_67:
  v3 |= sub_49160((int)&v68, (int)"url");
  if ( v2 )
  {
LABEL_68:
    if ( strcmp(v2, "tethering") )
      goto LABEL_81;
  }
  v42 = get_usb_tethering_op();
  if ( v42 )
  {
    if ( !get_ifexist("usb0") || get_wan_link("wan1") )
    {
      if ( get_ifexist("usb0") && get_wan_link("wan1") )
      {
        v44 = "%s";
        v45 = "테더링 장치 검색됨(WAN포트제거 후 사용가능)";
        v43 = (char *)&v64;
      }
      else
      {
        v43 = (char *)&v64;
        v44 = "%s";
        v45 = (const char *)&unk_865DB;
      }
    }
    else
    {
      v43 = (char *)&v64;
      v44 = "%s";
      v45 = "USB테더링사용중";
    }
    snprintf(v43, 0x80u, v44, v45);
    v42 = 1;
  }
  else
  {
    snprintf((char *)&v64, 0x80u, "%s", "중단됨");
  }
  v46 = sub_490F0((int)"tethering_status", (int)&v64);
  if ( !v2 )
  {
LABEL_82:
    if ( get_cupsd_status(v46) )
    {
      v47 = get_cupsd_printer_status(0);
      v48 = (char *)&v64;
      if ( !v47 )
      {
        v49 = (char *)&v64;
        v50 = "%s";
        v51 = "동작중";
LABEL_88:
        snprintf(v49, 0x80u, v50, v51);
        sub_490F0((int)"cupsd_status", (int)&v64);
LABEL_91:
        v52 = "<meta http-equiv=refresh content=\"2; URL=timepro.cgi?tmenu=iframe_nas_status\">";
        goto LABEL_92;
      }
    }
    else
    {
      get_cupsd_config(&v62);
      v48 = (char *)&v64;
      if ( !v62 )
      {
        v50 = "%s";
        v49 = (char *)&v64;
        v51 = "중단됨";
        goto LABEL_88;
      }
    }
    v49 = v48;
    v50 = "%s";
    v51 = "중단됨(프린터없음)";
    goto LABEL_88;
  }
  v3 |= v42;
LABEL_81:
  v46 = strcmp(v2, "cupsd");
  if ( !v46 )
    goto LABEL_82;
  if ( v3 )
    goto LABEL_91;
  v52 = "<meta http-equiv=refresh content=\"10; URL=timepro.cgi?tmenu=iframe_nas_status\">";
LABEL_92:
  printf(v52);
  printf("</html>");
  return free_process_list(&v68);
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 1061C: using guessed type int __fastcall get_media_config(_DWORD);
// 10658: using guessed type int __fastcall get_itunes_db_folder(_DWORD);
// 10778: using guessed type int __fastcall iconv_to_utf8(_DWORD, _DWORD, _DWORD);
// 10814: using guessed type int __fastcall get_media_db_folder(_DWORD);
// 1085C: using guessed type int __fastcall get_itunes_db_filename(_DWORD);
// 109A0: using guessed type int __fastcall get_cupsd_status(_DWORD);
// 10AB4: using guessed type int __fastcall get_wan_link(_DWORD);
// 10B14: using guessed type int get_process_list(void);
// 10BB0: using guessed type int __fastcall get_cupsd_config(_DWORD);
// 10CD0: using guessed type int __fastcall get_cupsd_printer_status(_DWORD);
// 10D30: using guessed type int __fastcall get_media_db_filename(_DWORD);
// 10DFC: using guessed type int __fastcall free_process_list(_DWORD);
// 10E98: using guessed type int __fastcall iconv_to_local(_DWORD, _DWORD, _DWORD);
// 1115C: using guessed type int __fastcall get_itunes_config(_DWORD);
// 112AC: using guessed type int __fastcall ddnsapi_read_config_by_service_type(_DWORD, _DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11504: using guessed type int __fastcall get_ifexist(_DWORD);
// 116C0: using guessed type int __fastcall ddnsapi_get_status(_DWORD, _DWORD);
// 1175C: using guessed type int get_usb_tethering_op(void);
// 11BB8: using guessed type int __fastcall print_file(_DWORD);
// 11C3C: using guessed type int __fastcall get_timed_status(_DWORD);

//----- (0004E274) --------------------------------------------------------
int __fastcall sub_4E274(int a1)
{
  int v1; // r5@1
  const char *v2; // r0@1
  const char *v3; // r4@1
  const char *v4; // r0@3
  int v5; // r4@3
  int v6; // r0@9
  int v7; // r0@9
  const char *v8; // r4@11
  size_t v9; // r0@13
  size_t v10; // r0@14
  const char *v11; // r1@16
  int v12; // r7@19
  char s; // [sp+Ch] [bp-10B4h]@15
  int v15; // [sp+100Ch] [bp-B4h]@13
  int v16; // [sp+108Ch] [bp-34h]@4

  v1 = a1;
  v2 = (const char *)get_pvalue(a1, "act");
  v3 = v2;
  if ( v2 )
  {
    if ( !strcmp(v2, "apply") )
    {
      v4 = (const char *)get_pvalue(v1, "op");
      v5 = atoi(v4);
      if ( v5 != get_plantynet_service(v5) )
      {
        plantynet_service_request("TCP", 85, 0, 0);
        get_plantynet_status(&v16);
        if ( !strcmp((const char *)&v16, "free") || !strcmp((const char *)&v16, "paid") )
        {
          if ( v5 )
            plantynet_service_event(3, 0);
          else
            v5 = 2;
        }
        v6 = set_plantynet_service(v5);
        v7 = signal_update(v6);
LABEL_28:
        signal_save(v7);
        return 0;
      }
    }
    else
    {
      if ( !strcmp(v3, "add") )
      {
        memset(&v16, 0, 0x14u);
        get_hw_value(v1, "hw", &v16);
        strtolower(&v16);
        v8 = (const char *)get_pvalue(v1, "dev_desc");
        if ( check_unpermitted_chars(v8) || !v8 )
        {
          v10 = strlen((const char *)&v16);
          v8 = 0;
          Base64encode(&v15, &v16, v10);
        }
        else
        {
          v9 = strlen(v8);
          Base64encode(&v15, v8, v9);
        }
        snprintf(&s, 0xFEu, "%s,%s", &v16, &v15);
        plantynet_service_event(256, &s);
        if ( v8 )
          v11 = v8;
        else
          v11 = (const char *)&v16;
        v7 = add_plantynet_freedevice(&v16, v11);
        goto LABEL_28;
      }
      v12 = strcmp(v3, "del");
      if ( !v12 )
      {
        memset(&s, 0, 0x1000u);
        while ( 1 )
        {
          v7 = get_value_array(v1, "delchk", v12, &v16);
          if ( !v7 )
            break;
          if ( s )
            snprintf(&s, 0xFFFu, "%s|%s", &s, &v16);
          else
            sf_strncpy(&s, &v16, 4096);
          ++v12;
          remove_plantynet_freedevice(&v16);
        }
        if ( s )
          v7 = plantynet_service_event(512, &s);
        goto LABEL_28;
      }
    }
  }
  return 0;
}
// 10058: using guessed type int __fastcall get_hw_value(_DWORD, _DWORD, _DWORD);
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10310: using guessed type int __fastcall get_plantynet_status(_DWORD);
// 1043C: using guessed type int __fastcall signal_save(_DWORD);
// 10454: using guessed type int __fastcall get_plantynet_service(_DWORD);
// 10694: using guessed type int __fastcall set_plantynet_service(_DWORD);
// 10910: using guessed type int __fastcall get_value_array(_DWORD, _DWORD, _DWORD, _DWORD);
// 10C04: using guessed type int __fastcall check_unpermitted_chars(_DWORD);
// 10C34: using guessed type int __fastcall plantynet_service_event(_DWORD, _DWORD);
// 11174: using guessed type int __fastcall Base64encode(_DWORD, _DWORD, _DWORD);
// 1136C: using guessed type int __fastcall add_plantynet_freedevice(_DWORD, _DWORD);
// 114BC: using guessed type int __fastcall get_pvalue(_DWORD, _DWORD);
// 11738: using guessed type int __fastcall plantynet_service_request(_DWORD, _DWORD, _DWORD, _DWORD);
// 11744: using guessed type int __fastcall remove_plantynet_freedevice(_DWORD);
// 11A8C: using guessed type int __fastcall signal_update(_DWORD);
// 11B4C: using guessed type int __fastcall strtolower(_DWORD);

//----- (0004E54C) --------------------------------------------------------
int sub_4E54C()
{
  int v0; // r0@1
  int v1; // r4@1
  int v2; // r0@2
  int v3; // r0@2
  int v4; // r0@2
  int result; // r0@2
  int v6; // r0@3
  int v7; // r0@3
  int v8; // r0@3
  int v9; // r0@3
  int v10; // r7@3
  signed int v11; // r5@4
  int v12; // r0@6
  int v13; // r0@6
  char *v14; // r1@7
  char *v15; // r1@10
  int v16; // r0@12
  int v17; // r0@12
  int v18; // r0@12
  int v19; // r0@12
  int v20; // r0@12
  int v21; // r0@12
  int v22; // r0@12
  int v23; // r0@12
  int v24; // r0@12
  char *v25; // r0@12
  char *v26; // r10@13
  int v27; // r0@15
  int v28; // r0@15
  int v29; // r0@15
  int v30; // r0@15
  int v31; // r10@15
  char *v32; // r1@16
  int v33; // r5@20
  int v34; // r0@20
  int v35; // r0@20
  int v36; // r0@20
  int v37; // r0@20
  int v38; // r0@20
  int i; // r0@20
  int v40; // r0@22
  int v41; // r0@24
  int v42; // r0@24
  char v43; // [sp+Ch] [bp-35Ch]@1
  char v44; // [sp+20Ch] [bp-15Ch]@21
  char v45; // [sp+30Ch] [bp-5Ch]@21
  char v46; // [sp+320h] [bp-48h]@3
  char v47; // [sp+334h] [bp-34h]@12

  v0 = get_wan_ip("wan1", &v43);
  v1 = v0;
  if ( v0 )
  {
    v6 = print_start_content_table(v0);
    str(v6);
    snprintf(&v43, 0x200u, (const char *)&unk_867CF, "http://iptime.iansim.net/service/serviceIntroduce.jsp");
    v7 = print_item(&v43, 0);
    v8 = etr(v7);
    print_end_content_table(v8);
    print_blank_line(1, 15);
    printf("<form method=get action=timepro.cgi name=plantynet_fm>");
    printf("<input type=hidden name=tmenu value=firewallconf>");
    printf("<input type=hidden name=smenu value=plantynet>");
    v9 = printf("<input type=hidden name=act value=>");
    v10 = get_plantynet_service(v9);
    plantynet_service_request("TCP", 85, 0, 0);
    get_plantynet_status(&v46);
    if ( !strcmp(&v46, "free") )
      v11 = 1;
    else
      v11 = strcmp(&v46, "paid") == 0;
    v12 = print_sub_title("서비스 설정", 1);
    v13 = print_start_content_table(v12);
    str(v13);
    print_item_desc("동작 설정");
    puts("<td class=item_td>");
    if ( v10 == 1 )
      v14 = "checked";
    else
      v14 = "";
    printf("<input type=radio name=op value=1 %s> %s", v14, "실행");
    print_nbsp(5);
    if ( v10 == 1 )
      v15 = "";
    else
      v15 = "checked";
    printf("<input type=radio name=op value=0 %s> %s", v15, "중단");
    puts("</td>");
    puts("<td class=item_td>");
    printf("<input type=button name=op_button value=\"적용\" onclick=\"ApplyPlantynet()\">");
    v16 = puts("</td>");
    v17 = etr(v16);
    str(v17);
    v18 = puts("<td colspan=3 class=item_td></td>");
    v19 = etr(v18);
    str(v19);
    printf("<td colspan=3 height=310 valign=top align=center style=\"padding: 0px; background-color:#f2f2fc; border:1px solid #cccccc; border-style:none solid solid solid;\" >");
    printf("<iframe name=\"ifr_plantynet\" scrolling=no style=\"border:1px solid #cccccc;\" frameborder=no width=600 height=310 src=\about:blank\"></iframe>");
    v20 = printf("</td>");
    v21 = etr(v20);
    print_end_content_table(v21);
    printf("</form>");
    get_hwaddr_kernel("br0", &v47);
    printf(
      "<form name=\"ifr_form\" target=\"ifr_plantynet\" method=\"POST\" action=\"%s\">",
      "http://iptime.iansim.net/service/serviceInfo.jsp");
    v22 = strtolower(&v47);
    printf("<input type=hidden name=MAC value=%s>", v22);
    printf("</form>");
    puts("<script language=\"JavaScript\">");
    puts("document.ifr_form.target=\"ifr_plantynet\";");
    puts("document.ifr_form.submit();");
    puts("</script>");
    print_blank_line(1, 15);
    printf("<form method=get action=timepro.cgi name=freedevice_fm>");
    printf("<input type=hidden name=tmenu value=firewallconf>");
    printf("<input type=hidden name=smenu value=plantynet>");
    printf("<input type=hidden name=act value=>");
    printf("<input type=hidden name=del value=>");
    v23 = print_sub_title(
            "부모 기기 (등록된 기기는 유해사이트 차단이 이루어지지 않습니다.)",
            1);
    v24 = print_start_content_table(v23);
    str(v24);
    print_item_desc("MAC 주소");
    puts("<td class=item_td align=left>");
    v25 = getenv("REMOTE_ADDR");
    get_internal_pc_hardware_address(v25, &v47);
    if ( v11 )
      v26 = "";
    else
      v26 = "disabled";
    printf(
      "<input type=checkbox class=navi_chk name=delchk onclick=\"SetHWOnCheckNoDisable(this,'hw','%s');\" %s> ",
      &v47,
      v26);
    printf("현재 접속된 PC의 MAC주소로 설정");
    printf("<br>");
    sub_15664((int)"hw", 0, v11 ^ 1);
    print_nbsp(5);
    print_popup_button(
      "timepro.cgi?tmenu=popup&smenu=selectmac&formname=freedevice_fm&macprefix=hw",
      "searchmac",
      "width=400px,height=250px,scrollbars=yes,menubar=no,toolbar=no,resizable=yes",
      "macbutton");
    v27 = printf("</td>");
    v28 = etr(v27);
    str(v28);
    print_item_desc("설명");
    puts("<td colspan=2 class=item_td>");
    v29 = printf("<input type=text name=\"dev_desc\" maxlength=24 size=24 value='' %s></td>\n", v26);
    v30 = etr(v29);
    v31 = get_plantynet_freedevice_num(v30);
    str(v31);
    puts("<td class=item_td colspan=2>");
    printf("<table class=nomargin_table width=100%%><tr><td align=left><font color='gray'>\n");
    printf("최대 %d개의 설정을 추가 할 수 있습니다.", 10);
    printf("</td><td align=right>");
    if ( v31 <= 9 )
    {
      if ( v11 )
        v32 = "";
      else
        v32 = "disabled";
    }
    else
    {
      v32 = "disabled";
    }
    v33 = 0;
    printf("<input type=button name=freedev_submit value=\"추가\" onclick=\"AddPlantynetFreeDevice();\" %s>", v32);
    printf("</td></tr></table>");
    v34 = printf("</td>");
    v35 = etr(v34);
    print_end_content_table(v35);
    v36 = print_blank_line(1, 20);
    v37 = print_start_content_table(v36);
    str(v37);
    print_item_desc("");
    print_item_desc("MAC 주소");
    print_item_desc("설명");
    printf("<td class=itemdesc_td align=left width=38>");
    printf(
      "<input class=navi_bt type=button name=del_bt value=\"%s\" onclick=\"DeletePlantynetFreeDevice()\" %s>",
      "삭제");
    v38 = printf("</td>");
    for ( i = etr(v38); v33 < v31; i = etr(v40) )
    {
      i = get_plantynet_freedevice(v33, &v45, &v44);
      if ( !i )
        break;
      ++v33;
      str(i);
      printf("<td class=item_td width=70>%d</td>\n", v33);
      sf_strncpy(&v43, &v45, 512);
      convert_mac(&v43);
      print_item(&v43, 200);
      print_item(&v44, 300);
      v40 = printf("<td class=item_td align=center ><input type=checkbox name=delchk value=\"%s\"></td>", &v45);
    }
    str(i);
    v41 = puts("<td class=item_td colspan=4> </td>");
    v42 = etr(v41);
    print_end_content_table(v42);
    result = puts("</form>");
  }
  else
  {
    v2 = print_start_content_table(0);
    str(v2);
    v3 = print_item(&unk_866ED, v1);
    v4 = etr(v3);
    result = print_end_content_table(v4);
  }
  return result;
}
// 10250: using guessed type int __fastcall sf_strncpy(_DWORD, _DWORD, _DWORD);
// 10274: using guessed type int __fastcall get_plantynet_freedevice_num(_DWORD);
// 10310: using guessed type int __fastcall get_plantynet_status(_DWORD);
// 10418: using guessed type int __fastcall get_hwaddr_kernel(_DWORD, _DWORD);
// 10454: using guessed type int __fastcall get_plantynet_service(_DWORD);
// 1055C: using guessed type int __fastcall get_internal_pc_hardware_address(_DWORD, _DWORD);
// 10844: using guessed type int __fastcall print_popup_button(_DWORD, _DWORD, _DWORD, _DWORD);
// 108A4: using guessed type int __fastcall convert_mac(_DWORD);
// 109AC: using guessed type int __fastcall print_item(_DWORD, _DWORD);
// 10A9C: using guessed type int __fastcall str(_DWORD);
// 10EBC: using guessed type int __fastcall etr(_DWORD);
// 10EF8: using guessed type int __fastcall print_sub_title(_DWORD, _DWORD);
// 1112C: using guessed type int __fastcall print_nbsp(_DWORD);
// 11348: using guessed type int __fastcall print_item_desc(_DWORD);
// 114EC: using guessed type int __fastcall print_start_content_table(_DWORD);
// 11540: using guessed type int __fastcall get_wan_ip(_DWORD, _DWORD);
// 115B8: using guessed type int __fastcall print_blank_line(_DWORD, _DWORD);
// 11738: using guessed type int __fastcall plantynet_service_request(_DWORD, _DWORD, _DWORD, _DWORD);
// 1190C: using guessed type int __fastcall print_end_content_table(_DWORD);
// 1196C: using guessed type int __fastcall get_plantynet_freedevice(_DWORD, _DWORD, _DWORD);
// 11B4C: using guessed type int __fastcall strtolower(_DWORD);

//----- (0004EB80) --------------------------------------------------------
unsigned int __fastcall sub_4EB80(unsigned int result, unsigned int a2)
{
  char v2; // r2@5
  unsigned int v3; // r1@5
  unsigned int v4; // r3@5
  unsigned int v5; // r2@5
  bool v6; // zf@14

  if ( a2 != 1 )
  {
    if ( a2 < 1 )
      JUMPOUT(&loc_4F324);
    if ( result <= a2 )
    {
      result = result == a2;
    }
    else if ( a2 & (a2 - 1) )
    {
      v2 = __clz(a2) - __clz(result);
      v3 = a2 << v2;
      v4 = 1 << v2;
      v5 = 0;
      while ( 1 )
      {
        if ( result >= v3 )
        {
          result -= v3;
          v5 |= v4;
        }
        if ( result >= v3 >> 1 )
        {
          result -= v3 >> 1;
          v5 |= v4 >> 1;
        }
        if ( result >= v3 >> 2 )
        {
          result -= v3 >> 2;
          v5 |= v4 >> 2;
        }
        if ( result >= v3 >> 3 )
        {
          result -= v3 >> 3;
          v5 |= v4 >> 3;
        }
        v6 = result == 0;
        if ( result )
        {
          v4 >>= 4;
          v6 = v4 == 0;
        }
        if ( v6 )
          break;
        v3 >>= 4;
      }
      result = v5;
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}

//----- (0004EC28) --------------------------------------------------------
unsigned int __fastcall sub_4EC28(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(&loc_4EC1C);
  return sub_4EB80(a1, a2);
}

//----- (0004EC48) --------------------------------------------------------
int __fastcall sub_4EC48(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(&loc_4F324);
  return sub_4EC50(a1, a2);
}

//----- (0004EC50) --------------------------------------------------------
int __fastcall sub_4EC50(int result, unsigned int a2)
{
  char v2; // nf@0
  int v3; // r12@1
  unsigned int v4; // r3@4
  char v5; // r0@8
  unsigned int v6; // r1@8
  unsigned int v7; // r2@8
  bool v8; // zf@17

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      result = -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        result = (v3 >> 31) | 1;
    }
    else if ( a2 & (a2 - 1) )
    {
      v5 = __clz(a2) - __clz(v4);
      v6 = a2 << v5;
      v7 = 1 << v5;
      result = 0;
      while ( 1 )
      {
        if ( v4 >= v6 )
        {
          v4 -= v6;
          result |= v7;
        }
        if ( v4 >= v6 >> 1 )
        {
          v4 -= v6 >> 1;
          result |= v7 >> 1;
        }
        if ( v4 >= v6 >> 2 )
        {
          v4 -= v6 >> 2;
          result |= v7 >> 2;
        }
        if ( v4 >= v6 >> 3 )
        {
          v4 -= v6 >> 3;
          result |= v7 >> 3;
        }
        v8 = v4 == 0;
        if ( v4 )
        {
          v7 >>= 4;
          v8 = v7 == 0;
        }
        if ( v8 )
          break;
        v6 >>= 4;
      }
      if ( v3 < 0 )
        result = -result;
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        result = -result;
    }
  }
  return result;
}

//----- (0004ED24) --------------------------------------------------------
int __fastcall sub_4ED24(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(&loc_4ED14);
  return sub_4EC50(a1, a2);
}

//----- (0004ED50) --------------------------------------------------------
int __fastcall sub_4ED50(int result, int a2, int a3, unsigned int a4)
{
  bool v4; // zf@1
  int v5; // r2@1
  signed int v6; // r2@8
  unsigned __int8 v7; // vf@8
  int v8; // r3@8
  int v9; // r1@9
  int v10; // r0@13
  int v11; // r1@15
  unsigned int v12; // r2@18
  unsigned int v13; // r0@18
  unsigned int v14; // r1@18
  unsigned int v15; // r3@18
  unsigned __int8 v16; // cf@19
  unsigned int v17; // off@22
  int v18; // r0@23
  unsigned int v19; // r12@27
  bool v20; // nf@27
  unsigned __int8 v21; // vf@27
  int v22; // r2@27
  unsigned int v23; // r0@27
  signed int v24; // r3@38
  bool v25; // zf@38
  bool v26; // zf@55
  int v27; // r2@55
  bool v28; // zf@60

  v5 = 2 * result;
  v4 = 2 * result == 0;
  if ( 2 * result )
  {
    a4 = 2 * a2;
    v4 = 2 * a2 == 0;
  }
  if ( !v4 )
  {
    v4 = v5 == a4;
    if ( v5 != a4 )
    {
      v4 = ~(v5 >> 24) == 0;
      if ( ~(v5 >> 24) )
        v4 = ~((signed int)a4 >> 24) == 0;
    }
  }
  if ( v4 )
  {
    v24 = 2 * a2;
    v25 = ~(v5 >> 24) == 0;
    if ( ~(v5 >> 24) )
      v25 = ~(v24 >> 24) == 0;
    if ( v25 )
    {
      v27 = ~(v5 >> 24);
      v26 = v27 == 0;
      if ( v27 )
        result = a2;
      else
        v26 = ~(v24 >> 24) == 0;
      if ( !v26 )
        a2 = result;
      v28 = result << 9 == 0;
      if ( !(result << 9) )
        v28 = a2 << 9 == 0;
      if ( v28 )
        v28 = result == a2;
      if ( !v28 )
        result |= 0x400000u;
    }
    else if ( v5 == v24 )
    {
      if ( result != a2 )
        return 0;
      if ( v5 & 0xFF000000 )
      {
        if ( (unsigned int)v5 < 0xFE000000 )
        {
          result += 0x800000;
          return result;
        }
        v15 = result & 0x80000000;
        return v15 | 0x7F800000;
      }
      v16 = __CFSHL__(result, 1);
      result *= 2;
      if ( v16 )
        result |= 0x80000000;
    }
    else if ( !v5 )
    {
      result = a2;
    }
  }
  else
  {
    v6 = (unsigned int)v5 >> 24;
    v7 = __OFSUB__(a4 >> 24, v6);
    v8 = (a4 >> 24) - v6;
    if ( !((unsigned __int8)((v8 < 0) ^ v7) | (v8 == 0)) )
    {
      v6 += v8;
      v9 = result ^ a2;
      result ^= v9;
      a2 = result ^ v9;
    }
    if ( (v8 < 0) ^ v7 )
      v8 = -v8;
    if ( (unsigned int)v8 <= 0x19 )
    {
      v4 = (result & 0x80000000) == 0;
      v10 = (result | 0x800000) & 0xFFFFFF;
      if ( !v4 )
        v10 = -v10;
      v4 = (a2 & 0x80000000) == 0;
      v11 = (a2 | 0x800000) & 0xFFFFFF;
      if ( !v4 )
        v11 = -v11;
      if ( v6 == v8 )
      {
        v11 ^= 0x800000u;
        if ( v6 )
        {
          LOBYTE(v8) = v8 - 1;
        }
        else
        {
          v10 ^= 0x800000u;
          v6 = 1;
        }
      }
      v12 = v6 - 1;
      v13 = v10 + (v11 >> v8);
      v14 = v11 << (32 - v8);
      v15 = v13 & 0x80000000;
      if ( (v13 & 0x80000000) != 0 )
      {
        v16 = v14 <= 0;
        v14 = -v14;
        v13 = -(v13 + !v16);
      }
      if ( v13 >= 0x800000 )
      {
        if ( v13 < 0x1000000 || (v13 >>= 1, v17 = __RCR__(v14, 1), v14 = v17, ++v12, v12 < 0xFE) )
        {
LABEL_23:
          v18 = (v12 << 23) + (v14 >= 0x80000000) + v13;
          if ( v14 == 0x80000000 )
            v18 &= 0xFFFFFFFE;
          return v18 | v15;
        }
        return v15 | 0x7F800000;
      }
      v16 = __CFSHL__(v14, 1);
      v14 *= 2;
      v13 += v16 + v13;
      --v12;
      if ( v13 & 0x800000 )
        goto LABEL_23;
      v19 = __clz(v13) - 8;
      v21 = __OFSUB__(v12, v19);
      v22 = v12 - v19;
      v20 = v22 < 0;
      v23 = v13 << v19;
      if ( (v22 < 0) ^ v21 )
        v22 = -v22;
      else
        v23 += v22 << 23;
      if ( v20 ^ v21 )
        result = v15 | (v23 >> v22);
      else
        result = v23 | v15;
    }
  }
  return result;
}

//----- (0004EEE8) --------------------------------------------------------
unsigned int __fastcall sub_4EEE8(unsigned int result)
{
  unsigned int v1; // r3@1
  unsigned int v2; // r1@4
  unsigned int v3; // r2@4
  unsigned __int8 v4; // vf@4
  int v5; // r2@4
  int v6; // r3@4
  char v7; // r2@6

  v1 = result & 0x80000000;
  if ( (result & 0x80000000 & 0x80000000) != 0 )
    result = -result;
  if ( result )
  {
    v2 = result;
    v3 = __clz(result);
    v4 = __OFSUB__(v3, 8);
    v5 = v3 - 8;
    v6 = (v1 | 0x4B000000) - 0x800000 - (v5 << 23);
    if ( (v5 < 0) ^ v4 )
    {
      v7 = v5 + 32;
      result = (result >> (32 - v7)) + __CFSHL__(result << v7, 1) + v6;
      if ( !(2 * (v2 << v7)) )
        result &= ~(v2 << v7 >> 31);
    }
    else
    {
      result = v6 + (result << v5);
    }
  }
  return result;
}

//----- (0004EF94) --------------------------------------------------------
int __fastcall sub_4EF94(unsigned int a1, unsigned int a2, int a3, int a4)
{
  bool v4; // zf@1
  int v5; // r2@1
  int v6; // r2@7
  int v7; // r12@7
  bool v8; // zf@7
  unsigned int v9; // r0@7
  unsigned int v10; // r1@10
  unsigned int v11; // r3@10
  unsigned int v12; // kr00_4@10
  bool v13; // cf@10
  unsigned int v14; // r0@12
  int v15; // r2@12
  bool v16; // zf@12
  bool v17; // nf@12
  unsigned __int8 v18; // vf@12
  int result; // r0@13
  unsigned int v20; // r12@16
  int v21; // r0@18
  bool v22; // zf@18
  bool v23; // nf@18
  unsigned __int8 v24; // vf@18
  int v25; // r2@18
  int v26; // r2@27
  unsigned int v27; // r12@27
  int v28; // off@27
  unsigned int v29; // r12@44
  bool v30; // zf@31
  bool v31; // zf@33
  unsigned int v32; // r12@33
  bool v33; // zf@38
  bool v34; // zf@41
  bool v35; // zf@46

  v5 = (a1 >> 23) & 0xFF;
  v4 = v5 == 0;
  if ( v5 )
  {
    a4 = (a2 >> 23) & 0xFF;
    v4 = a4 == 0;
  }
  if ( !v4 )
  {
    v4 = v5 == 255;
    if ( v5 != 255 )
      v4 = a4 == 255;
  }
  if ( v4 )
  {
    a4 = (a2 >> 23) & 0xFF;
    v33 = v5 == 255;
    if ( v5 != 255 )
      v33 = a4 == 255;
    if ( v33 )
    {
      v35 = a1 == 0;
      if ( a1 )
        v35 = a1 == 2147483648;
      if ( v35 )
        a1 = a2;
      else
        v35 = a2 == 0;
      if ( !v35 )
        v35 = a2 == 2147483648;
      if ( !v35 && (v5 != 255 || !(a1 << 9)) )
      {
        if ( a4 != 255 || !(a2 << 9) )
        {
          v14 = a1 ^ a2;
          return v14 & 0x80000000 | 0x7F800000;
        }
        a1 = a2;
      }
      return a1 | 0x7FC00000;
    }
    v34 = (a1 & 0x7FFFFFFF) == 0;
    if ( a1 & 0x7FFFFFFF )
      v34 = (a2 & 0x7FFFFFFF) == 0;
    if ( v34 )
      return (a1 ^ a2) & 0x80000000;
    v30 = v5 == 0;
    v29 = a1 & 0x80000000;
    while ( v30 )
    {
      a1 *= 2;
      v30 = (a1 & 0x800000) == 0;
      if ( a1 & 0x800000 )
        break;
      --v5;
    }
    a1 |= v29;
    v31 = a4 == 0;
    v32 = a2 & 0x80000000;
    while ( v31 )
    {
      a2 *= 2;
      v31 = (a2 & 0x800000) == 0;
      if ( a2 & 0x800000 )
        break;
      --a4;
    }
    a2 |= v32;
  }
  v6 = v5 + a4;
  v7 = a1 ^ a2;
  v9 = a1 << 9;
  v8 = v9 == 0;
  if ( v9 )
  {
    a2 <<= 9;
    v8 = a2 == 0;
  }
  if ( v8 )
  {
    v20 = v7 & 0x80000000;
    if ( !v9 )
      a2 <<= 9;
    v21 = v20 | (v9 >> 9) | (a2 >> 9);
    v24 = __OFSUB__(v6, 127);
    v25 = v6 - 127;
    v22 = v25 == 0;
    v23 = v25 < 0;
    if ( !((unsigned __int8)((v25 < 0) ^ v24) | (v25 == 0)) )
    {
      v24 = __OFSUB__(255, v25);
      v22 = 255 == v25;
      v23 = 255 - v25 < 0;
    }
    if ( !((unsigned __int8)(v23 ^ v24) | v22) )
      return v21 | (v25 << 23);
    v14 = v21 | 0x800000;
    v11 = 0;
    v18 = __OFSUB__(v25, 1);
    v15 = v25 - 1;
    v16 = v15 == 0;
    v17 = v15 < 0;
  }
  else
  {
    v12 = ((v9 >> 5) | 0x8000000) * ((a2 >> 5) | 0x8000000);
    v10 = ((v9 >> 5) | 0x8000000) * (unsigned __int64)((a2 >> 5) | 0x8000000) >> 32;
    v11 = v12;
    v13 = v10 >= 0x800000;
    if ( v10 < 0x800000 )
    {
      v10 = 2 * v10 | (v12 >> 31);
      v11 = 2 * v12;
    }
    v14 = v7 & 0x80000000 | v10;
    v15 = v6 - (!v13 + 127);
    v18 = __OFSUB__(v15, 253);
    v16 = v15 == 253;
    v17 = v15 - 253 < 0;
    if ( (unsigned int)v15 <= 0xFD )
    {
      result = (v15 << 23) + (v11 >= 0x80000000) + v14;
      if ( v11 == 0x80000000 )
        result &= 0xFFFFFFFE;
      return result;
    }
  }
  if ( !((unsigned __int8)(v17 ^ v18) | v16) )
    return v14 & 0x80000000 | 0x7F800000;
  if ( (unsigned __int8)((v15 + 25 < 0) ^ __OFADD__(v15, 25)) | (v15 == -25) )
  {
    result = v14 & 0x80000000;
  }
  else
  {
    v26 = -v15;
    v27 = v14 << (32 - v26);
    v28 = __RCR__(2 * v14 >> v26, 1);
    result = ((2 * v14 >> v26) & 1) + v28;
    if ( !(v11 | 2 * v27) )
      result &= ~(v27 >> 31);
  }
  return result;
}

//----- (0004F12C) --------------------------------------------------------
int __fastcall sub_4F12C(unsigned int a1, unsigned int a2, int a3, int a4)
{
  bool v4; // zf@1
  int v5; // r2@1
  int v6; // r2@7
  int v7; // r12@7
  unsigned int v8; // r1@7
  unsigned int v9; // r0@7
  unsigned int v10; // r1@8
  unsigned int v11; // r3@8
  unsigned int v12; // r0@8
  bool v13; // cf@8
  unsigned int v14; // r2@10
  unsigned int v15; // r12@10
  bool v16; // zf@19
  int result; // r0@25
  unsigned int v18; // r0@28
  bool v19; // zf@28
  bool v20; // nf@28
  unsigned __int8 v21; // vf@28
  int v22; // r2@28
  unsigned int v23; // r12@54
  bool v24; // zf@34
  bool v25; // zf@36
  unsigned int v26; // r12@36
  bool v27; // zf@51

  v5 = (a1 >> 23) & 0xFF;
  v4 = v5 == 0;
  if ( v5 )
  {
    a4 = (a2 >> 23) & 0xFF;
    v4 = a4 == 0;
  }
  if ( !v4 )
  {
    v4 = v5 == 255;
    if ( v5 != 255 )
      v4 = a4 == 255;
  }
  if ( v4 )
  {
    a4 = (a2 >> 23) & 0xFF;
    if ( v5 == 255 )
    {
      if ( a1 << 9 )
        JUMPOUT(&loc_4F120);
      if ( a4 != 255 )
        JUMPOUT(&loc_4F10C);
      JUMPOUT(&loc_4F120);
    }
    if ( a4 == 255 )
    {
      if ( !(a2 << 9) )
        JUMPOUT(&loc_4F0C4);
      JUMPOUT(&loc_4F120);
    }
    v27 = (a1 & 0x7FFFFFFF) == 0;
    if ( a1 & 0x7FFFFFFF )
      v27 = (a2 & 0x7FFFFFFF) == 0;
    if ( v27 )
    {
      if ( a1 & 0x7FFFFFFF )
        JUMPOUT(&loc_4F10C);
      if ( a2 & 0x7FFFFFFF )
        JUMPOUT(&loc_4F0C4);
      JUMPOUT(&loc_4F120);
    }
    v24 = v5 == 0;
    v23 = a1 & 0x80000000;
    while ( v24 )
    {
      a1 *= 2;
      v24 = (a1 & 0x800000) == 0;
      if ( a1 & 0x800000 )
        break;
      --v5;
    }
    a1 |= v23;
    v25 = a4 == 0;
    v26 = a2 & 0x80000000;
    while ( v25 )
    {
      a2 *= 2;
      v25 = (a2 & 0x800000) == 0;
      if ( a2 & 0x800000 )
        break;
      --a4;
    }
    a2 |= v26;
  }
  v6 = v5 - a4;
  v7 = a1 ^ a2;
  v8 = a2 << 9;
  v9 = a1 << 9;
  if ( v8 )
  {
    v10 = (v8 >> 4) | 0x10000000;
    v11 = (v9 >> 4) | 0x10000000;
    v12 = v7 & 0x80000000;
    v13 = v11 >= v10;
    if ( v11 < v10 )
      v11 *= 2;
    v14 = v13 + v6 + 125;
    v15 = 0x800000;
    do
    {
      if ( v11 >= v10 )
      {
        v11 -= v10;
        v12 |= v15;
      }
      if ( v11 >= v10 >> 1 )
      {
        v11 -= v10 >> 1;
        v12 |= v15 >> 1;
      }
      if ( v11 >= v10 >> 2 )
      {
        v11 -= v10 >> 2;
        v12 |= v15 >> 2;
      }
      if ( v11 >= v10 >> 3 )
      {
        v11 -= v10 >> 3;
        v12 |= v15 >> 3;
      }
      v11 *= 16;
      v16 = v11 == 0;
      if ( v11 )
      {
        v15 >>= 4;
        v16 = v15 == 0;
      }
    }
    while ( !v16 );
    if ( v14 > 0xFD )
      JUMPOUT(&loc_4F034);
    result = (v14 << 23) + (v11 >= v10) + v12;
    if ( v11 == v10 )
      result &= 0xFFFFFFFE;
  }
  else
  {
    v18 = v7 & 0x80000000 | (v9 >> 9);
    v21 = __OFADD__(v6, 127);
    v22 = v6 + 127;
    v19 = v22 == 0;
    v20 = v22 < 0;
    if ( !((unsigned __int8)((v22 < 0) ^ v21) | (v22 == 0)) )
    {
      v21 = __OFSUB__(255, v22);
      v19 = 255 == v22;
      v20 = 255 - v22 < 0;
    }
    if ( (unsigned __int8)(v20 ^ v21) | v19 )
      JUMPOUT(&loc_4F034);
    result = v18 | (v22 << 23);
  }
  return result;
}

//----- (0004F28C) --------------------------------------------------------
unsigned int __fastcall sub_4F28C(int a1)
{
  unsigned int v1; // r2@1
  bool v2; // cf@2
  int v3; // r2@2
  bool v4; // zf@4
  unsigned int result; // r0@4

  v1 = 2 * a1;
  if ( (unsigned int)(2 * a1) < 0x7F000000 )
  {
    result = 0;
  }
  else
  {
    v2 = v1 >> 24 <= 0x9E;
    v3 = 158 - (v1 >> 24);
    if ( v3 != 0 && v2 )
    {
      v4 = (a1 & 0x80000000) == 0;
      result = ((a1 << 8) | 0x80000000) >> v3;
      if ( !v4 )
        result = -result;
    }
    else if ( v3 == -97 && a1 << 9 )
    {
      result = 0;
    }
    else
    {
      result = a1 & 0x80000000;
      if ( !result )
        result = 0x7FFFFFFF;
    }
  }
  return result;
}

//----- (0004F2E8) --------------------------------------------------------
int __fastcall sub_4F2E8(__int64 a1, __int64 a2)
{
  int v2; // lr@0
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  if ( !a2 )
  {
    if ( a1 )
      HIDWORD(a1) = -1;
    v4 = HIDWORD(a1);
    v5 = v2;
    raise(8);
    JUMPOUT(__CS__, v5);
  }
  return sub_4F370(a1, a2, &v4);
}

//----- (0004F370) --------------------------------------------------------
int __fastcall sub_4F370(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // r6@1
  __int64 v4; // r4@1
  __int64 v5; // r0@1

  v3 = a2;
  v4 = a1;
  LODWORD(v5) = sub_4F810(a1, HIDWORD(a1), a2, HIDWORD(a2));
  *a3 = v4 - v3 * v5;
  return v5;
}

//----- (0004F3AC) --------------------------------------------------------
unsigned __int64 __fastcall sub_4F3AC(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  unsigned int v4; // r8@1
  unsigned int v5; // r4@1
  unsigned int v6; // r7@1
  unsigned int v7; // r12@1
  signed int v8; // r1@2
  unsigned int v9; // r9@6
  unsigned int v10; // r11@6
  int v11; // r5@6
  unsigned int v12; // r3@8
  int v13; // r1@12
  int v14; // r7@12
  unsigned int v15; // r0@12
  unsigned int v16; // r5@12
  int v17; // r4@12
  unsigned int v18; // r7@12
  unsigned int v19; // r5@16
  int v20; // r1@16
  unsigned int v21; // r10@16
  unsigned int v22; // r0@16
  unsigned int v23; // r8@16
  unsigned int v24; // r10@17
  unsigned int v25; // r7@20
  unsigned int v26; // r3@23
  unsigned int v27; // r8@24
  int v28; // r6@24
  unsigned int v29; // r6@25
  unsigned int v30; // r10@25
  int v31; // r1@25
  int v32; // r4@25
  unsigned int v33; // r0@25
  unsigned int v34; // r3@25
  int v35; // r7@25
  unsigned int v36; // r4@25
  unsigned int v37; // r4@29
  int v38; // r1@29
  unsigned int v39; // r10@29
  unsigned int v40; // r0@29
  unsigned int v41; // r8@29
  int v42; // r1@34
  int v43; // r10@34
  unsigned int v44; // r0@34
  unsigned int v45; // r8@34
  int v46; // r4@34
  unsigned int v47; // r10@34
  unsigned int v48; // r8@38
  int v49; // r1@38
  unsigned int v50; // r10@38
  unsigned int v51; // r0@38
  unsigned int v52; // r5@38
  unsigned int v53; // r10@39
  unsigned __int8 v54; // cf@46
  unsigned int v55; // r5@51
  unsigned int v56; // r7@51
  int v57; // r1@51
  unsigned int v58; // r0@51
  unsigned int v59; // r3@51
  int v60; // r7@51
  signed __int64 v61; // r10@51
  int v62; // r1@55
  unsigned int v63; // r0@55
  unsigned int v64; // r9@55
  unsigned int v65; // r3@55
  int v66; // r3@59
  int v67; // r5@59
  int v68; // r12@59
  int v69; // r2@59
  int v70; // r12@59
  int v71; // r5@59
  int v72; // r1@59
  unsigned int v73; // r5@59
  bool v74; // r3@62
  unsigned __int64 v75; // r2@69
  int v77; // [sp+4h] [bp-34h]@55
  unsigned int v78; // [sp+8h] [bp-30h]@51
  int v79; // [sp+Ch] [bp-2Ch]@4

  v4 = a2;
  v5 = a1;
  v6 = a3;
  v7 = a4;
  if ( a2 < 0 )
  {
    v4 = -(a2 + (a1 > 0));
    v5 = -a1;
    v8 = -1;
  }
  else
  {
    v8 = 0;
  }
  v79 = v8;
  if ( a4 < 0 )
  {
    v54 = a3 <= 0;
    a3 = -a3;
    v6 = a3;
    v7 = -(a4 + !v54);
    v79 = ~v8;
  }
  v9 = v6;
  v10 = v5;
  v11 = v4;
  if ( !v7 )
  {
    if ( v6 > v4 )
    {
      v12 = __clz(v6);
      if ( v12 )
      {
        v9 = v6 << v12;
        a3 = v5 >> (32 - v12);
        v10 = v5 << v12;
      }
      if ( v12 )
        v11 = a3 | (v4 << v12);
      sub_4EC28(v11, v9 >> 16);
      v14 = v13;
      v15 = sub_4EB80(v11, v9 >> 16);
      v16 = (unsigned __int16)v9 * v15;
      v17 = v15;
      v18 = (v10 >> 16) | (v14 << 16);
      if ( v18 < v16 )
      {
        v54 = __CFADD__(v18, v9);
        v18 += v9;
        v17 = v15 - 1;
        if ( !v54 && v18 < v16 )
        {
          v17 = v15 - 2;
          v18 += v9;
        }
      }
      v19 = v18 - v16;
      sub_4EC28(v19, v9 >> 16);
      v21 = (unsigned __int16)v10 | (v20 << 16);
      v22 = sub_4EB80(v19, v9 >> 16);
      v23 = (unsigned __int16)v9 * v22;
      if ( v21 < v23 )
      {
        v54 = __CFADD__(v21, v9);
        v24 = v21 + v9;
        --v22;
        if ( !v54 && v24 < v23 )
          --v22;
      }
      v25 = v22 | (v17 << 16);
      goto LABEL_67;
    }
    if ( !v6 )
      v9 = sub_4EB80(1u, 0);
    v26 = __clz(v9);
    if ( v26 )
    {
      v9 <<= v26;
      v29 = v4 >> (32 - v26);
      v10 = v5 << v26;
      v30 = (v5 >> (32 - v26)) | (v4 << v26);
      sub_4EC28(v29, v9 >> 16);
      v32 = v31;
      v33 = sub_4EB80(v29, v9 >> 16);
      v34 = (unsigned __int16)v9 * v33;
      v35 = v33;
      v36 = (v30 >> 16) | (v32 << 16);
      if ( v36 < v34 )
      {
        v54 = __CFADD__(v36, v9);
        v36 += v9;
        v35 = v33 - 1;
        if ( !v54 && v36 < v34 )
        {
          v35 = v33 - 2;
          v36 += v9;
        }
      }
      v37 = v36 - v34;
      sub_4EC28(v37, v9 >> 16);
      v39 = (unsigned __int16)v30 | (v38 << 16);
      v40 = sub_4EB80(v37, v9 >> 16);
      v41 = (unsigned __int16)v9 * v40;
      if ( v39 < v41 )
      {
        v54 = __CFADD__(v39, v9);
        v39 += v9;
        --v40;
        if ( !v54 && v39 < v41 )
        {
          --v40;
          v39 += v9;
        }
      }
      v28 = v40 | (v35 << 16);
      v27 = v39 - v41;
    }
    else
    {
      v27 = v4 - v9;
      v28 = 1;
    }
    sub_4EC28(v27, v9 >> 16);
    v43 = v42;
    v44 = sub_4EB80(v27, v9 >> 16);
    v45 = (unsigned __int16)v9 * v44;
    v46 = v44;
    v47 = (v10 >> 16) | (v43 << 16);
    if ( v47 < v45 )
    {
      v54 = __CFADD__(v47, v9);
      v47 += v9;
      v46 = v44 - 1;
      if ( !v54 && v47 < v45 )
      {
        v46 = v44 - 2;
        v47 += v9;
      }
    }
    v48 = v47 - v45;
    sub_4EC28(v48, v9 >> 16);
    v50 = (unsigned __int16)v10 | (v49 << 16);
    v51 = sub_4EB80(v48, v9 >> 16);
    v52 = (unsigned __int16)v9 * v51;
    if ( v50 < v52 )
    {
      v54 = __CFADD__(v50, v9);
      v53 = v50 + v9;
      --v51;
      if ( !v54 && v53 < v52 )
        --v51;
    }
    v25 = v51 | (v46 << 16);
    goto LABEL_69;
  }
  if ( v7 > v4 )
  {
    v28 = 0;
LABEL_68:
    v25 = 0;
    goto LABEL_69;
  }
  v28 = __clz(v7);
  if ( !v28 )
  {
    v54 = v4 >= v7;
    if ( v4 <= v7 )
      v54 = v5 >= v6;
    if ( v54 )
    {
      v25 = 1;
      goto LABEL_69;
    }
    v28 = 0;
    goto LABEL_68;
  }
  v55 = (v6 >> (32 - v28)) | (v7 << v28);
  v78 = v6 << v28;
  v56 = v4 >> (32 - v28);
  LODWORD(v61) = (v5 >> (32 - v28)) | (v4 << v28);
  sub_4EC28(v56, v55 >> 16);
  HIDWORD(v61) = v57;
  v58 = sub_4EB80(v56, v55 >> 16);
  v59 = (unsigned __int16)v55 * v58;
  v60 = v58;
  HIDWORD(v61) = v61 >> 16;
  if ( HIDWORD(v61) < v59 )
  {
    v54 = __CFADD__(HIDWORD(v61), v55);
    HIDWORD(v61) += v55;
    v60 = v58 - 1;
    if ( !v54 && HIDWORD(v61) < v59 )
    {
      v60 = v58 - 2;
      HIDWORD(v61) += v55;
    }
  }
  HIDWORD(v61) -= v59;
  sub_4EC28(HIDWORD(v61), v55 >> 16);
  v77 = v62;
  v63 = sub_4EB80(HIDWORD(v61), v55 >> 16);
  v64 = (unsigned __int16)v55 * v63;
  v65 = (unsigned __int16)v61 | (v77 << 16);
  if ( v65 < v64 )
  {
    v65 = ((unsigned __int16)v61 | (v77 << 16)) + v55;
    --v63;
    if ( !__CFADD__((unsigned __int16)v61 | (v77 << 16), v55) && v65 < v64 )
    {
      --v63;
      v65 += v55;
    }
  }
  v66 = v65 - v64;
  v25 = v63 | (v60 << 16);
  v67 = v25 & ~(v25 >> 16 << 16);
  v68 = v78 & ~(v78 >> 16 << 16);
  v69 = v67 * v68;
  v70 = (v25 >> 16) * v68;
  v71 = (v78 >> 16) * v67;
  v72 = (v25 >> 16) * (v78 >> 16);
  v54 = __CFADD__(v70, v71);
  v73 = v70 + v71;
  if ( v54 )
    v72 += 0x10000;
  if ( (__PAIR__(v72, v69) + __PAIR__(v73 >> 16, v73 << 16)) >> 32 > (unsigned int)v66
    || ((v74 = (__PAIR__(v72, v69) + __PAIR__(v73 >> 16, v73 << 16)) >> 32 == v66, v69 + (v73 << 16) > v5 << v28) ? (v28 = v74) : (v28 = 0),
        v28) )
  {
    --v25;
LABEL_67:
    v28 = 0;
  }
LABEL_69:
  v75 = __PAIR__(v28, v25);
  if ( v79 )
  {
    LODWORD(v75) = -v25;
    HIDWORD(v75) = -(v28 + (v25 > 0));
  }
  return v75;
}

//----- (0004F810) --------------------------------------------------------
signed int __fastcall sub_4F810(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // r5@1
  unsigned int v5; // r4@1
  unsigned int v6; // r8@1
  signed __int64 v7; // r10@1
  int v8; // r9@1
  unsigned int v9; // r3@3
  int v10; // r1@7
  unsigned int v11; // r0@7
  unsigned int v12; // r7@7
  int v13; // r4@7
  unsigned int v14; // r7@11
  int v15; // r1@11
  unsigned int v16; // r11@11
  unsigned int v17; // r0@11
  unsigned int v18; // r6@11
  unsigned int v19; // r11@12
  unsigned int v20; // r4@15
  unsigned int v21; // r3@18
  unsigned int v22; // r4@19
  unsigned int v23; // r7@20
  unsigned int v24; // r9@20
  int v25; // r1@20
  int v26; // r4@20
  unsigned int v27; // r7@20
  unsigned int v28; // r4@20
  unsigned int v29; // r7@24
  int v30; // r1@24
  unsigned int v31; // r4@24
  unsigned int v32; // r11@24
  int v33; // r1@29
  unsigned int v34; // r0@29
  unsigned int v35; // r9@29
  int v36; // r4@29
  unsigned int v37; // r9@33
  int v38; // r1@33
  unsigned int v39; // r11@33
  unsigned int v40; // r0@33
  unsigned int v41; // r6@33
  unsigned int v42; // r11@34
  unsigned int v43; // r7@39
  unsigned __int8 v44; // cf@40
  unsigned int v45; // r9@45
  unsigned int v46; // r6@45
  unsigned int v47; // r4@45
  int v48; // r1@45
  int v49; // r11@45
  unsigned int v50; // r0@45
  unsigned int v51; // r3@45
  int v52; // r9@45
  unsigned int v53; // r11@45
  unsigned int v54; // r11@49
  int v55; // r1@49
  unsigned int v56; // r0@49
  unsigned int v57; // r10@49
  unsigned int v58; // r3@49
  int v59; // r3@53
  int v60; // r12@53
  int v61; // r6@53
  int v62; // r2@53
  int v63; // r6@53
  int v64; // r12@53
  int v65; // r1@53
  unsigned int v66; // r12@53
  bool v67; // r3@56
  int v68; // r7@57
  int v70; // [sp+0h] [bp-30h]@49
  unsigned int v71; // [sp+4h] [bp-2Ch]@45

  v4 = a1;
  v5 = a2;
  v6 = a3;
  LODWORD(v7) = a1;
  v8 = a2;
  if ( !a4 )
  {
    if ( a3 <= a2 )
    {
      if ( !a3 )
        v6 = sub_4EB80(1u, 0);
      v21 = __clz(v6);
      if ( v21 )
      {
        v6 <<= v21;
        v23 = v5 >> (32 - v21);
        v24 = (v4 >> (32 - v21)) | (v5 << v21);
        LODWORD(v7) = v4 << v21;
        sub_4EC28(v5 >> (32 - v21), v6 >> 16);
        v26 = v25;
        v27 = (unsigned __int16)v6 * sub_4EB80(v23, v6 >> 16);
        v28 = (v24 >> 16) | (v26 << 16);
        if ( v28 < v27 )
        {
          v44 = __CFADD__(v28, v6);
          v28 += v6;
          if ( !v44 && v28 < v27 )
            v28 += v6;
        }
        v29 = v28 - v27;
        sub_4EC28(v29, v6 >> 16);
        v31 = (unsigned __int16)v24 | (v30 << 16);
        v32 = (unsigned __int16)v6 * sub_4EB80(v29, v6 >> 16);
        if ( v31 < v32 )
        {
          v44 = __CFADD__(v31, v6);
          v31 += v6;
          if ( !v44 && v31 < v32 )
            v31 += v6;
        }
        v22 = v31 - v32;
      }
      else
      {
        v22 = v5 - v6;
      }
      sub_4EC28(v22, v6 >> 16);
      HIDWORD(v7) = v33;
      v34 = sub_4EB80(v22, v6 >> 16);
      v35 = (unsigned __int16)v6 * v34;
      v36 = v34;
      HIDWORD(v7) = v7 >> 16;
      if ( HIDWORD(v7) < v35 )
      {
        v44 = __CFADD__(HIDWORD(v7), v6);
        HIDWORD(v7) += v6;
        v36 = v34 - 1;
        if ( !v44 && HIDWORD(v7) < v35 )
        {
          v36 = v34 - 2;
          HIDWORD(v7) += v6;
        }
      }
      v37 = HIDWORD(v7) - v35;
      sub_4EC28(v37, v6 >> 16);
      v39 = (unsigned __int16)v7 | (v38 << 16);
      v40 = sub_4EB80(v37, v6 >> 16);
      v41 = (unsigned __int16)v6 * v40;
      if ( v39 < v41 )
      {
        v44 = __CFADD__(v39, v6);
        v42 = v39 + v6;
        --v40;
        if ( !v44 && v42 < v41 )
          --v40;
      }
      v20 = v40 | (v36 << 16);
    }
    else
    {
      v9 = __clz(a3);
      if ( v9 )
      {
        v6 = a3 << v9;
        a3 = a1 >> (32 - v9);
        LODWORD(v7) = a1 << v9;
      }
      if ( v9 )
        v8 = a3 | (a2 << v9);
      sub_4EC28(v8, v6 >> 16);
      HIDWORD(v7) = v10;
      v11 = sub_4EB80(v8, v6 >> 16);
      v12 = (unsigned __int16)v6 * v11;
      v13 = v11;
      HIDWORD(v7) = v7 >> 16;
      if ( HIDWORD(v7) < v12 )
      {
        v44 = __CFADD__(HIDWORD(v7), v6);
        HIDWORD(v7) += v6;
        v13 = v11 - 1;
        if ( !v44 && HIDWORD(v7) < v12 )
        {
          v13 = v11 - 2;
          HIDWORD(v7) += v6;
        }
      }
      v14 = HIDWORD(v7) - v12;
      sub_4EC28(v14, v6 >> 16);
      v16 = (unsigned __int16)v7 | (v15 << 16);
      v17 = sub_4EB80(v14, v6 >> 16);
      v18 = (unsigned __int16)v6 * v17;
      if ( v16 < v18 )
      {
        v44 = __CFADD__(v16, v6);
        v19 = v16 + v6;
        --v17;
        if ( !v44 && v19 < v18 )
          --v17;
      }
      v20 = v17 | (v13 << 16);
    }
    return v20;
  }
  if ( a4 > a2 )
    return 0;
  v43 = __clz(a4);
  if ( !v43 )
  {
    v44 = a2 >= a4;
    if ( a2 <= a4 )
      v44 = a1 >= a3;
    if ( v44 )
      return 1;
    return 0;
  }
  v45 = a2 >> (32 - v43);
  v46 = (a3 >> (32 - v43)) | (a4 << v43);
  v47 = (a1 >> (32 - v43)) | (a2 << v43);
  v71 = a3 << v43;
  sub_4EC28(a2 >> (32 - v43), v46 >> 16);
  v49 = v48;
  v50 = sub_4EB80(v45, v46 >> 16);
  v51 = (unsigned __int16)v46 * v50;
  v52 = v50;
  v53 = (v47 >> 16) | (v49 << 16);
  if ( v53 < v51 )
  {
    v44 = __CFADD__(v53, v46);
    v53 += v46;
    v52 = v50 - 1;
    if ( !v44 && v53 < v51 )
    {
      v52 = v50 - 2;
      v53 += v46;
    }
  }
  v54 = v53 - v51;
  sub_4EC28(v54, v46 >> 16);
  v70 = v55;
  v56 = sub_4EB80(v54, v46 >> 16);
  v57 = (unsigned __int16)v46 * v56;
  v58 = (unsigned __int16)v47 | (v70 << 16);
  if ( v58 < v57 )
  {
    v58 = ((unsigned __int16)v47 | (v70 << 16)) + v46;
    --v56;
    if ( !__CFADD__((unsigned __int16)v47 | (v70 << 16), v46) && v58 < v57 )
    {
      --v56;
      v58 += v46;
    }
  }
  v59 = v58 - v57;
  v20 = v56 | (v52 << 16);
  v60 = v20 & ~(v20 >> 16 << 16);
  v61 = v71 & ~(v71 >> 16 << 16);
  v62 = v60 * v61;
  v63 = (v20 >> 16) * v61;
  v64 = (v71 >> 16) * v60;
  v65 = (v20 >> 16) * (v71 >> 16);
  v44 = __CFADD__(v63, v64);
  v66 = v63 + v64;
  if ( v44 )
    v65 += 0x10000;
  if ( (__PAIR__(v65, v62) + __PAIR__(v66 >> 16, v66 << 16)) >> 32 > (unsigned int)v59
    || ((v67 = (__PAIR__(v65, v62) + __PAIR__(v66 >> 16, v66 << 16)) >> 32 == v59, v62 + (v66 << 16) > v4 << v43) ? (v68 = v67) : (v68 = 0),
        v68) )
  {
    v20 = (v56 | (v52 << 16)) - 1;
  }
  return v20;
}

//----- (0004FC0C) --------------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 392 function(s)"
